---
title: 左神算法笔记进阶-经典结构
date: 2020-03-12 21:19:37
category:
- 左神算法进阶
- 经典结构
---

## 窗口最大值更新结构

### 最大值更新结构

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_window.png) 

当向此结构放数据时会检查一下结构中的已有数据，从时间戳最大的开始检查，如果检查过程中发现该数据小于即将放入的数据则将其弹出并检查下一个，直到即将放入的数据小于正在检查的数据或者结构中的数据都被弹出了为止，再将要放入的数据放入结构中并盖上时间戳。如此每次从该结构取数据时，都会返回结构中时间戳最小的数据，也是目前为止进入过此结构的所有数据中最大的那一个。

此结构可以使用一个双端队列来实现，一端只用来放数据（放数据之前的检查过程可能会弹出其他数据），另一端用来获取目前为止出现过的最大值。

示例如下：

```java
import java.util.LinkedList;

public class MaxValueWindow {

  private LinkedList<Integer> queue;
  public MaxValueWindow() {
    this.queue = new LinkedList();
  }

  //更新窗口最大值
  public void add(int i){
    while (!queue.isEmpty() && queue.getLast() <= i) {
      queue.pollLast();
    }
    queue.add(i);
  }

  //获取窗口最大值
  public int getMax() {
    if (!queue.isEmpty()) {
      return queue.peek();
    }
    return Integer.MIN_VALUE;
  }

  //使窗口最大值过期
  public void expireMaxValue() {
    if (!queue.isEmpty()) {
      queue.poll();
    }
  }

  public static void main(String[] args) {
    MaxValueWindow window = new MaxValueWindow();
    window.add(6);
    window.add(4);
    window.add(9);
    window.add(8);
    System.out.println(window.getMax());//9
    window.expireMaxValue();
    System.out.println(window.getMax());//8
  }
}
```

### 例题

#### 窗口移动

给你一个长度为`N`的整型数组和大小为`W`的窗口，用一个长度为`N-W+1`的数组记录窗口从数组由左向右移动过程中窗口内最大值。

对于数组`[1,2,3,4,5,6,7]`和窗口大小为`3`，窗口由左向右移动时有：

- `[1,2,3],4,5,6,7`，窗口起始下标为0时，框住的数是`1,2,3`，最大值是3
- `1,[2,3,4],5,6,7`，最大值是4
- `1,2,[3,4,5],6,7`，最大值是5
- ……

因此所求数组是`[3,4,5,6,7]`。

```java
public static void add(int arr[], int index, LinkedList<Integer> queue) {
  if (queue == null) {
    return;
  }
  while (!queue.isEmpty() && arr[queue.getLast()] < arr[index]) {
    queue.pollLast();
  }
  queue.add(index);
}

public static void expireIndex(int index, LinkedList<Integer> queue) {
  if (queue == null) {
    return;
  }
  if (!queue.isEmpty() && queue.peek() == index) {
    queue.pollFirst();
  }
}

public static int[] maxValues(int[] arr, int w) {
  int[] res = new int[arr.length - w + 1];
  LinkedList<Integer> queue = new LinkedList();
  for (int i = 0; i < w; i++) {
    add(arr, i, queue);
  }
  for (int i = 0; i < res.length; i++) {
    res[i] = queue.peek();
    if (i + w <= arr.length - 1) {
      expireIndex(i, queue);
      add(arr, i + w, queue);
    }
  }
  for (int i = 0; i < res.length; i++) {
    res[i] = arr[res[i]];
  }
  return res;
}

public static void main(String[] args) {
  int[] arr = {3, 2, 1, 5, 6, 2, 7, 8, 10, 6};
  System.out.println(Arrays.toString(maxValues(arr,3)));//[3, 5, 6, 6, 7, 8, 10, 10]
}
```

这里需要的注意的是，针对这道题将窗口最大值更新结构的`add`和`expire`方法做了改进（结构中存的是值对应的下标）。例如`[2,1,2],-1->2,[1,2,-1]`，应当翻译为`[2,1,2],-1`状态下的窗口最大值为2下标上的数`2`，变为`2,[1,2,-1]`时应当翻译为下标为0的数从窗口过期了，而不应该是数据`2`从窗口过期了（这样会误删窗口中下标为2的最大值2）。

#### 求达标的子数组个数

给你一个整型数组，判断其所有子数组中最大值和最小值的差值不超过`num`（如果满足则称该数组达标）的个数。（子数组指原数组中任意个连续下标上的元素组成的数组）

暴力解：遍历每个元素，再遍历以当前元素为首的所有子数组，再遍历子数组找到其中的最大值和最小值以判断其是否达标。很显然这种方法的时间复杂度为`o(N^3)`，但如果使用最大值更新结构，则能实现`O(N)`级别的解。

如果使用`L`和`R`两个指针指向数组的两个下标，且`L`在`R`的左边。当`L~R`这一子数组达标时，可以推导出以`L`开头的长度不超过`R-L+1`的所有子数组都达标；当`L~R`这一子数组不达标时，无论`L`向左扩多少个位置或者`R`向右扩多少个位置，`L~R`还是不达标。

`O(N)`的解对应的算法是：`L`和`R`都从0开始，`R`先向右移动，`R`每右移一个位置就使用最大值更新结构和最小值更新结构记录一下`L~R`之间的最大值和最小值的下标，当`R`移动到如果再右移一个位置`L~R`就不达标了时停止，这时以当前`L`开头的长度不超过`R-L+1`的子数组都达标；然后`L`右移一个位置，同时更新一下最大值、最小值更新结构（`L-1`下标过期了），再右移`R`至`R`如果右移一个位置`L~R`就不达标了停止（每右移`R`一次也更新最大、小值更新结构）……；直到`L`到达数组尾元素为止。将每次`R`停止时，`R-L+1`的数量累加起来就是`O(N)`的解，因为`L`和`R`都只向右移动，并且每次`R`停止时，以`L`开头的达标子串的数量直接通过`R-L+1`计算，所以时间复杂度就是将数组遍历了一遍即`O(N)`。

示例代码：

```java
public static int getComplianceChildArr(int arr[], int num) {
  //最大值、最小值更新结构
  LinkedList<Integer> maxq = new LinkedList();
  LinkedList<Integer> minq = new LinkedList<>();
  int L = 0;
  int R = 0;
  maxq.add(0);
  minq.add(0);
  int res = 0;
  while (L < arr.length) {
    while (R < arr.length - 1) {
      while (!maxq.isEmpty() && arr[maxq.getLast()] <= arr[R + 1]) {
        maxq.pollLast();
      }
      maxq.add(R + 1);
      while (!minq.isEmpty() && arr[minq.getLast()] >= arr[R + 1]) {
        minq.pollLast();
      }
      minq.add(R + 1);
      if (arr[maxq.peekFirst()] - arr[minq.peekFirst()] > num) {
        break;
      }
      R++;
    }
    res += (R - L + 1);
    if (maxq.peekFirst() == L) {
      maxq.pollFirst();
    }
    if (minq.peekFirst() == L) {
      minq.pollFirst();
    }
    L++;
  }
  return res;
}

public static void main(String[] args) {
  int[] arr = {1, 2, 3, 5};
  System.out.println(getComplianceChildArr(arr, 3));//9
```

## 单调栈结构

### 原始问题

给你一个数组，找出数组中每个数左边离它最近的比它大的数和右边离它最近的比它大的数。

> 思路：使用一个栈，要求每次元素进栈后要维持栈中从栈底到栈顶元素值是从大到小排列的约定。将数组中的元素依次进栈，如果某次元素进栈后会违反了上述的约定（即该进栈元素比栈顶元素大），就先弹出栈顶元素，并记录该栈顶元素的信息：
>
> - 该元素左边离它最近的比它大的是该元素出栈后的栈顶元素，如果出栈后栈空，那么该元素左边没有比它大的数
> - 该元素右边离它最近的比它大的是进栈元素
>
> 然后再尝试将进栈元素进栈，如果进栈后还会违反约定那就重复操作“弹出栈顶元素并记录该元素信息”，直到符合约定或栈中元素全部弹出时再将该进栈元素进栈。当数组所有元素都进栈之后，栈势必不为空，弹出栈顶元素并记录信息：
>
> - 该元素右边没有比它大的数
> - 该元素左边离它最近的比它大的数是该元素从栈弹出后的栈顶元素，如果该元素弹出后栈为空，那么该元素左边没有比它大的数
>
> 由于每个元素仅进栈一次、出栈一次，且出栈时能得到题目所求信息，因此时间复杂度为`O(N)`

示例代码：

```java
public static void findLeftAndRightBigger(int arr[]){
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
        //check the agreement before push the index of element
        while (!stack.empty() && arr[stack.peek()] < arr[i]) {
            //pop and record the info(print or save)
            int index = stack.pop();
            System.out.print("index:" + index + ",element:" + arr[index] + ",right bigger is:" + arr[i]);
            if (stack.empty()) {
                System.out.print(",hasn't left bigger\n");
            } else {
                System.out.println(",left bigger is:" + arr[stack.peek()]+"\n");
            }
        }
        //push
        stack.push(i);
    }
    while (!stack.empty()) {
        int index = stack.pop();
        System.out.print("index:" + index + ",element:" + arr[index] + ",hasn't right bigger");
        if (stack.empty()) {
            System.out.print(",hasn't left bigger\n");
        } else {
            System.out.println(",left bigger is:" + arr[stack.peek()]+"\n");
        }
    }
}

public static void main(String[] args) {
    int[] arr = {2, 1, 7, 4, 5, 9, 3};
    findLeftAndRightBigger(arr);
}
```

### 给你一些数，创建一棵大根堆二叉树

> 思路：使用一个栈底到栈顶单调递减的单调栈，将这些数`arr[]`依次入栈，记录每个数左边离它最近的比它大的数，保存在`left[]`中（下标和`arr[]`一一对应），记录每个数右边离它最近的比它大的数，保存在`right[]`中。
>
> 遍历`arr[]`建树：`left[i]`和`right[i]`都不存在的，说明`arr[i]`是最大的数，将其作为根节点；对于其他任何一个数`arr[i]`，`left[i]`和`right[i]`必有一个存在，如果都存在则将`arr[i]`作为`Math.min(left[i],right[i])`的孩子节点，如果只有一个存在（如`left[i]`）那就将`arr[i]`作为`left[i]`的孩子节点

> 思考：这样建出的树会不会是森林，会不会不是二叉树？

### 找出矩阵中一片1相连的最大矩形

矩阵中的数只会是0或1，求矩阵中一片1形成的最大长方形区域的面积。

此题可借鉴在直方图中找最大矩形的方法。首先一个数组可以对应一个直方图，如下所示：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_rectangle_area.png) 

接着，遍历数组，以当前遍历元素值为杆子的高并尝试向左右移动这根杆子（约定杆子不能出黄色区域）：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_rectangle_area1.png) 

如上图，0号杆子向左右移动一格都会使杆子出界（黄色区域），因此0号杆子的活动面积是`4x1=4`（杆长x能活动的格子数）；1号杆子向左、向右都只能移动一格，因此其活动面积是`2x3=6`；2号杆子的活动面积是`3x1=3`；3号杆子的活动面积是`1x5=5`；4号杆子的活动面积是`6x1=6`。因此该直方图中最大矩形面积就是所有杆子的活动面积中最大的那个，即6。

如果现在给你一个矩阵，比如

```java
0 0 0 0 1
0 0 0 0 1 
1 0 0 0 1
1 0 1 0 1
1 1 1 0 1
1 1 1 1 1
```

你能否将其中相连的一片1看成直方图中的黄色区域，如此的话求矩阵由一片1形成的最大矩形区域就是求直方图中最大矩形面积了。

所以对于输入的矩形，我们只要遍历每一行，以该行作为直方图的x轴，求出直方图的最大矩形面积，再比较所有行对应的最大矩形面积就能得出整个矩阵的一片1形成的最大矩形区域了。

以上面的矩阵为例，第一行、第三行、最后一行对应的直方图如下所示：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_rectangle_area2.png) 

分别可以用数组`[0,0,0,0,1]`、`[1,0,0,0,3]`、`[4,2,3,1,6]`来表示，那么此题关键的点就是遍历每一行并求出以该行为x轴的直方图的数组表示之后，如何得出此直方图的最大矩形面积。下面就使用单调栈来解决此问题：

以`[4,2,3,1,6]`的求解过程为例，使用一个栈底到栈顶单调递增的栈将数组中的数的下标作为该数的代表依次压栈（数的下标->数值），首先能压的是`0->4`，接着准备压`1->2`，发现`2`比栈顶的`4`小，压人后会违反栈底到栈顶单调递增的约定，因此弹出`0->4`并记录0号杆子的活动面积（`0->4`弹出后栈为空，说明0号杆子左移到x轴的-1就跑出黄色区域了，由于是`1->2`让它弹出的，所以0号杆子右移到x轴的1就出界了，因此0号杆子只能在x轴上的0位置上活动，活动面积是`4x1=4`，称这个记录的过程为**结算**）。由于弹出`0->4`之后栈空了，所以可以压入`1->2`、`2->3`，接着准备压`3->1`时发现`1`比栈顶`3`小，因此结算`2->3`（由于弹出`2->3`之后栈顶为`1->2`，因此2号杆子左移到x轴1位置时出界了，由于是`3->1`让其弹出的，所以2号杆子右移到x轴3位置就出界了，因此2号杆子的活动面积是`3x1=3`）。接着再准备压`3->1`，发现`1`比栈顶`1->2`的`2`小，因此结算`1->2`（弹出`1->2`后栈空，因此1号杆子左移到x轴-1时才出界，`3->1`让其出界的，因此右移到3时才出界，活动面积为`2x3=6`）……

所有数压完之后，栈肯定不为空，那么栈中剩下的还需要结算，因此依次弹出栈顶进行结算，比如`[4,2,3,1,6]`压完之后，栈中还剩`3->1,4->6`，因此弹出`4->6`并结算（由于`4->6`不是因为一个比`6`小的数要进来而让它弹出的，所以4号杆子右移到x轴`arr.length=5`位置才出界，由于弹出后栈不空且栈顶为`3->1`，所以左移到x轴的3位置上才出界的，所以活动面积为`6x1=6`；同样的方法结算`3->1`……直到栈中的都被结算完，整个过程结束。

示例代码：

```java
public static int maxRectangleArea(int matrix[][]){
    int arr[] = new int[matrix[0].length];
    int maxArea = Integer.MIN_VALUE;
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[i].length; j++) {
            arr[j] = matrix[i][j] == 1 ? arr[j]+1 : 0;
        }
        System.out.println(Arrays.toString(arr));
        maxArea = Math.max(maxArea, maxRecAreaOfThRow(arr));
    }
    return maxArea;
}

public static int maxRecAreaOfThRow(int arr[]){
    int maxArea = Integer.MIN_VALUE;
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
        while (!stack.empty() && arr[i] < arr[stack.peek()]) {
            int index = stack.pop();
            int leftBorder = stack.empty() ? -1 : stack.peek();
            maxArea = Math.max(maxArea, arr[index] * (i - leftBorder - 1));
        }
        stack.push(i);
    }
    while (!stack.empty()) {
        int index = stack.pop();
        int rightBorder = arr.length;
        int leftBorder = stack.empty() ? -1 : stack.peek();
        maxArea = Math.max(maxArea, arr[index] * (rightBorder - leftBorder - 1));
    }
    return maxArea;
}

public static void main(String[] args) {
    int matrix[][] = {
        {0, 0, 0, 0, 1},
        {0, 0, 0, 0, 1},
        {1, 0, 0, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 1, 1, 0, 1},
        {1, 1, 1, 1, 1}
    };
    System.out.println(maxRectangleArea(matrix));//6
}
```

### 烽火相望

【网易原题】给你一个数组，数组中的每个数代表一座山的高度，这个数组代表将数组中的数从头到尾连接而成的环形山脉。比如数组`[2,1,3,4,5]`形成的环形山脉如下：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications.png) 

其中蓝色的圆圈就代表一座山，圈中的数字代表这座山的高度。现在在每座山的山顶都点燃烽火，假设你处在其中的一个山峰上，要想看到另一座山峰的烽火需满足以下两个条件中的一个：

- 你想看的山峰在环形路径上与你所在的山峰相邻。比如你在山峰A上，那么你能够看到B和E上的烽火。
- 如果你想看的山峰和你所在的山峰不相邻，那么你可以沿环形路径顺时针看这座山也可以沿环形路径逆时针看这座山，只要你放眼望去沿途经过的山峰高度小于你所在的山峰和目标山峰，那么也能看到。比如C想看E，那么可以通过C->B->A->E的方式看，也可以通过C->D->E的方式看。前者由于经过的山峰的高度1和2比C的高度3和E的高度5都小，因此能看到；但后者经过的山峰D的高度4大于C的高度3，因此C在通过C->D->E这个方向看E的时候视线就被山峰D给挡住了。

问：所有山峰中，能互相看到烽火的两两山峰的对数。以`[2,1,3,4,5]`为例，能互相看见的有：`2,1`,`1,3`,`3,4`,`4,5`,`5,2`,`2,3`,`3,5`，共7对。

此题分一下两种情况

#### 1、数组中无重复的数

这种情况下，答案可以直接通过公式`2*N-3`可以求得（其中`N`为数组长度），证明如下：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications1.png) 

假设A是在山峰中最高，B在所有山峰中第二高。那么环形路径上介于A和B之间的任意一座山峰（比如K），逆时针方向在到达A之前或到达A时一定会遇到第一座比它高的山峰，记这座山峰和K是一对；顺时针方向，在到达B之前或到达B时，一定会遇到第一个比K高的山峰，记这座山峰和K是一对。也就是说对于除A,B之外的所有山峰，都能找到两对符合标准的，这算下来就是`(N-2)*2`了，最后AB也算一对，总数是`(N-2)*2+1=2N-3`。

但如果数组中有重复的数就不能采用上述的方法了

#### 2、数组中可能有重复的数

> 利用单调栈

首先找出数组中最大数第一次出现的位置，记为`M`。从这个数开始遍历数组并依次压栈（栈底到栈底从大到小的单调栈），以如下的环形山脉为例：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications2.png) 

从M开始压栈，同时附带一个计数器：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications3.png) 

当压入5时，违反单调栈约定因此结算4（4左边第一个比它高的是9，右边第一个比它高的是5，因此能和4配对的有两对）；接着再压入5、压入4，重点来了：连续两次再压入4该如何处理：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications4.png) 

这是数组中有重复的数时，如何使用单调栈解决此题的关键：如果压入的元素与栈顶元素相同，将栈顶元素的**计数器加1**，那么再压入两个4之后栈中情况：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications5.png) 

然后压入9，导致弹出并结算4。那么**如何结算计数器大于1的数据**呢？首先，这3座高度相同的山峰两两配对能够组成`C(3,2)=3`对，此外其中的每座山峰左边离它最近的比它高的是5、右边离它近的比它大的是9，因此这3座山峰每座都能和`5、9`配对，即`3*2=6`，因此结算结果为`3+6=9`……

如果数据压完了，那就从栈顶弹出数据进行结算，直到结算栈底上一个元素之前（栈底元素是最大值），弹出数据的结算逻辑都是`C(K,2)+K*2`（其中K是该数据的计数器数值）。

倒数第二条数据的结算逻辑有点复杂，如图，以结算4为例：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications6.png) 

如果K的数值大于1，那么这6座高度为4的山峰结算逻辑还是上述公式。但如果K为1，那么结算公式就是`C(K,2)+K*1`了。

最后对于最大值M的结算，假设其计数器的值为K，如果K=1，那么结算结果为0；如果K>1，那么结算结果为`C(K,2)`。

示例代码：

```java
public static class Record{
    int value;
    int times;
    public Record(int value) {
        this.value = value;
        this.times = 1;
    }
}

public static int comunications(int[] arr) {
    //index of first max value
    int maxIndex = 0;
    for (int i = 0; i < arr.length; i++) {
        maxIndex = arr[maxIndex] < arr[i] ? i : maxIndex;
    }

    Stack<Record> stack = new Stack<>();
    stack.push(new Record(arr[maxIndex]));

    int res = 0;
    int index = nextIndex(arr, maxIndex);
    while (index != maxIndex) {
        while (!stack.empty() && arr[index] > stack.peek().value) {
            Record record = stack.pop();
            res += getInternalPairs(record.times) + record.times * 2;
        }
        if (arr[index] == stack.peek().value) {
            stack.peek().times++;
        } else {
            stack.push(new Record(arr[index]));
        }
        index = nextIndex(arr, index);
    }

    while (!stack.empty()) {
        Record record = stack.pop();
        res += getInternalPairs(record.times);
        if (!stack.empty()) {
            res += record.times;
            if (stack.size() > 1) {
                res += record.times;
            } else {
                res += stack.peek().times > 1 ? record.times : 0;
            }
        }
    }
    return res;
}

//C(K,2)
public static int getInternalPairs(int times){
    return (times * (times - 1)) / 2;
}

public static int nextIndex(int[] arr, int index) {
    return index < arr.length - 1 ? index + 1 : 0;
}

public static void main(String[] args) {
    int[] arr = {9, 4, 5, 4, 4, 4, 9,1};
    System.out.println(comunications(arr));
}
```

## 搜索二叉树

搜索二叉树的定义：对于一棵二叉树中的任意子树，其左子树上的所有数值小于头结点的数值，其右子树上所有的数值大于头结点的数值，并且树中不存在数值相同的结点。也称二叉查找树。

### 平衡二叉树/AVL树

#### 平衡性

经典的平衡二叉树结构：在满足搜索二叉树的前提条件下，对于一棵二叉树中的任意子树，其左子树和其右子树的高度相差不超过1。

### 典型搜索二叉树——AVL树、红黑树、SBT树的原理

#### AVL树

AVL树是一种具有严苛平衡性的搜索二叉树。什么叫做严苛平衡性呢？那就是**所有子树的左子树和右子树的高度相差不超过1**。弊端是，每次发现因为插入、删除操作破坏了这种严苛的平衡性之后，都需要作出相应的调整以使其恢复平衡，调整较为频繁。

#### 红黑树

红黑树是每个节点都带有颜色属性的搜索二叉树，颜色或红色或黑色。在搜索二叉树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

- 性质1. 节点是红色或黑色。
- 性质2. 根节点是黑色。
- 性质3 每个叶节点（NIL节点，空节点）是黑色的。
- 性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这个树**大致上是平衡**的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

要知道为什么这些特性确保了这个结果，注意到**性质4导致了路径不能有两个毗连的红色节点**就足够了。**最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点**。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

#### SBT树

它是由中国广东中山纪念中学的陈启峰发明的。陈启峰于2006年底完成论文《Size Balanced Tree》，并在2007年的全国青少年信息学奥林匹克竞赛冬令营中发表。**相比红黑树、AVL树等自平衡二叉查找树，SBT更易于实现**。**据陈启峰在论文中称，SBT是“目前为止速度最快的高级二叉搜索树”**。**SBT能在O(log n)的时间内完成所有二叉搜索树(BST)的相关操作**，而与普通二叉搜索树相比，SBT仅仅加入了简洁的核心操作Maintain。由于SBT赖以保持平衡的是size域而不是其他“无用”的域，它可以很方便地实现动态顺序统计中的select和rank操作。

**SBT树的性质**是：对于数中任意结点，以该结点为根节点的子树的结点个数不能比以该结点的叔叔结点为根节点的子树的结点个数大。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/sbt_tree.png) 

> 由于红黑树的实现较为复杂，因此现在工程中大多使用SBT树作为平衡二叉树的实现。

### 旋转——Rebalance

左旋：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/red_black_tree.png) 

右旋：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/red_black_tree1.png) 

每种平衡二叉树都有自己的一套在插入、删除等操作改变树结构而破坏既定平衡性时的应对措施（但都是左旋操作和右旋操作的组合），以AVL数为例（有四种平衡调整操作，其中的数字只是结点代号而非结点数值）：

- `LL`调整：2号结点的左孩子的左孩子导致整个树不平衡，2号结点右旋一次

    ![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/ll_adjust.png) 

+ `RR`调整：3号结点的右孩子的右孩子导致树不平衡，3号结点左旋一次：

    ![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rr_adjust.png) 

+ `LR`调整：先左后右

    ![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/lr_adjust.png) 

+ `RL`调整：先右后左：

    ![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rl_adjust.png) 

红黑树的调整也是类似的，只不过调整方案更多。面试中一般不会让你手写红黑树（若有兴趣可参见文末附录），但我们一定能说清这些查找二叉树的性质，以及调整平衡的基本操作，再就是这些结构的使用。

### Java中红黑树的使用

Java中红黑树的实现有`TreeSet`和`TreeMap`，前者结点存储的是单一数据，而后者存储的是``的形式。

```java
public static void main(String[] args) {
    TreeMap<Integer,String> treeMap = new TreeMap();
    treeMap.put(5, "tom");
    treeMap.put(11, "jack");
    treeMap.put(30,"tony");
    treeMap.put(18, "alice");
    treeMap.put(25, "jerry");

    //红黑树中最右边的结点
    System.out.println(treeMap.lastEntry());
    System.out.println(treeMap.lastKey());
    //红黑树最左边的结点
    System.out.println(treeMap.firstKey());
    //如果有13这个key，那么返回这条记录，否则返回树中比13大的key中最小的那一个
    System.out.println(treeMap.ceilingEntry(13));
    //如果有21这个key，那么返回这条记录，否则返回树中比21小的key中最大的那一个
    System.out.println(treeMap.floorEntry(21));
    //比11大的key中，最小的那一个
    System.out.println(treeMap.higherKey(11));
    //比25小的key中，最大的那一个
    System.out.println(treeMap.lowerKey(25));
    //遍历红黑树，是按key有序遍历的
    for (Map.Entry<Integer, String> record : treeMap.entrySet()) {
        System.out.println("age:"+record.getKey()+",name:"+record.getValue());
    }
}
```

`TreeMap`的优势是`key`在其中是有序组织的，因此增加、删除、查找`key`的时间复杂度均为`log(2,N)`。

### 案例

#### The Skyline Problem

水平面上有 *N* 座大楼，每座大楼都是矩阵的形状，可以用一个三元组表示 `(start, end, height)`，分别代表其在x轴上的起点，终点和高度。大楼之间从远处看可能会重叠，求出 *N* 座大楼的外轮廓线。

外轮廓线的表示方法为若干三元组，每个三元组包含三个数字 (start, end, height)，代表这段轮廓的起始位置，终止位置和高度。

给出三座大楼：

```java
[
  [1, 3, 3],
  [2, 4, 4],
  [5, 6, 1]
]
```

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skyline.png) 

外轮廓线为：

```
[
  [1, 2, 3],
  [2, 4, 4],
  [5, 6, 1]
]
```

**解析**：

1. 将一座楼的表示`[start,end,height]`拆分成左右两个边界（边界包含：所处下标、边界高度、是楼的左边界还是右边界），比如`[1,3,3]`就可以拆分成`[1,3,true]`和`[3,3,false]`的形式（`true`代表左边界、`false`代表右边界）。
2. 将每座楼都拆分成两个边界，然后对边界按照边界所处的下标进行排序。比如`[[1,3,3],[2,4,4],[5,6,1]`拆分之后为`[[1,3,true],[3,3,false],[2,4,true],[,4,4,false],[5,1,true],[6,1,false]]`，排序后为`[[1,3,true],[2,4,true],[3,3,false],[4,4,false],[5,1,true],[6,1,false]]`
3. 将边界排序后，遍历每个边界的高度并依次加入到一棵`TreeMap`红黑树中（记为`countOfH`），以该高度出现的次数作为键值（第一次添加的高度键值为1），如果遍历过程中有重复的边界高度添加，要判断它是左边界还是右边界，前者直接将该高度在红黑树中的键值加1，后者则减1。以步骤2中排序后的边界数组为例，首先判断`countOfH`是否添加过边界`[1,3,true]`的高度`3`，发现没有，于是`put(3,1)`；接着对`[2,4,true]`，`put[4,1]`；然后尝试添加`[3,3,false]`的`3`，发现`countOfH`中添加过`3`，而`[3,3,false]`是右边界，因此将`countOfH.get(3)`的次数减1，当`countOfH`中的记录的键值为0时直接移除，于是移除高度为3的这一条记录；……

对于遍历过程经过的每一个边界，我们还需要一棵`TreeMap`红黑树（记为`maxHOfPos`）来记录对我们后续求外轮廓线有用的信息，也就是每个边界所处下标的最大建筑高度：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skyline1.png) 

这里有个细节要注意一下，那就是如果添加某个边界之后，`countOfH`树为空了，那么该边界所处下标的建筑高度要记为0，表示一片相邻建筑的结束，比如上图中下标为4和6的边界。这也是为了后续求外轮廓线提供判断的依据。

4. 遍历`maxHOfPos`中的记录，构造整个外轮廓线数组：

    ![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skyline2.png) 

起初没有遍历边界时，记`start=0,height=0`，接着遍历边界，如果边界高度`curHeight!=height`如上图中的`1->2：height=0,curHeight=3`，那么记`start=1,height=3`表示第一条组外轮廓线的`start`和`height`，接下来就是确定它的`end`了。确定了一条轮廓线的`start`和`height`之后会有两种情况：下一组轮廓线和这一组是挨着的（如上图`2->3`）、下一组轮廓线和这一组是相隔的（如上图中`3->4`）。因此在遍历到边界`[index:2,H:4]`时，发现`curHeight=4 != height=3`，于是可以确定轮廓线`start:1,heigth:3`的`end:2`。确定一条轮廓线后就要更新一下`start=2,heigth=4`表示下一组轮廓线的起始下标和高度，接着遍历到边界`[index:3,H:4]`，发现`curHeight=4=height`于是跳过；接着遍历到边界`[index:4,H:0]`，发现`curHeight=0`，根据步骤3中的逻辑可知一片相邻的建筑到此结束了，因此轮廓线`start:2,height:4`的`end=4`。

示例代码：

```java
package top.zhenganwen.lintcode;

import java.util.*;

public class T131_The_SkylineProblem {

    public class Border implements Comparable<Border> {
        public int index;
        public int height;
        public boolean isLeft;

        public Border(int index, int height, boolean isLeft) {
            this.index = index;
            this.height = height;
            this.isLeft = isLeft;
        }

        @Override
        public int compareTo(Border border) {
            if (this.index != border.index) {
                return this.index - border.index;
            }
            if (this.isLeft != border.isLeft) {
                return this.isLeft ? -1 : 1;
            }
            return 0;
        }
    }

    /**
     * @param buildings: A list of lists of integers
     * @return: Find the outline of those buildings
     */
    public List<List<Integer>> buildingOutline(int[][] buildings) {
        //1、split one building to two borders and sort by border's index
        Border[] borders = new Border[buildings.length * 2];
        for (int i = 0; i < buildings.length; i++) {
            int[] oneBuilding = buildings[i];
            borders[i * 2] = new Border(oneBuilding[0], oneBuilding[2], true);
            borders[i * 2 + 1] = new Border(oneBuilding[1], oneBuilding[2], false);
        }
        Arrays.sort(borders);

        //2、traversal borders and record the max height of each index

        //key->height   value->the count of the height
        TreeMap<Integer, Integer> countOfH = new TreeMap<>();
        //key->index    value->the max height of the index
        TreeMap<Integer, Integer> maxHOfPos = new TreeMap<>();
        for (int i = 0; i < borders.length; i++) {
            int height = borders[i].height;
            if (!countOfH.containsKey(height)) {
                countOfH.put(height, 1);
            }else {
                int count = countOfH.get(height);
                if (borders[i].isLeft) {
                    countOfH.put(height, count + 1);
                } else {
                    countOfH.put(height, count - 1);
                    if (countOfH.get(height) == 0) {
                        countOfH.remove(height);
                    }
                }
            }

            if (countOfH.isEmpty()) {
                maxHOfPos.put(borders[i].index, 0);
            } else {
                //lastKey() return the maxHeight in countOfH RedBlackTree->log(2,N)
                maxHOfPos.put(borders[i].index, countOfH.lastKey());
            }
        }

        //3、draw the buildings outline according to the maxHOfPos
        int start = 0;
        int height = 0;
        List<List<Integer>> res = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : maxHOfPos.entrySet()) {
            int curPosition = entry.getKey();
            int curMaxHeight = entry.getValue();
            if (height != curMaxHeight) {
                //if the height don't be reset to 0，the curPosition is the end
                if (height != 0) {
                    List<Integer> record = new ArrayList<>();
                    record.add(start);
                    record.add(curPosition);//end
                    record.add(height);

                    res.add(record);
                }
                //reset the height and start
                height = curMaxHeight;
                start = curPosition;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        int[][] buildings = {
                {1, 3, 3},
                {2, 4, 4},
                {5, 6, 1}
        };
        System.out.println(new T131_The_SkylineProblem().buildingOutline(buildings));

    }
}
```

## 跳表

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list.png) 

跳表有着和红黑树、SBT树相同的功能，都能实现在`O(log(2,N))`内实现对数据的增删改查操作。但跳表不是以二叉树为原型的，其设计细节如下：

记该结构为`SkipList`，该结构中可以包含有很多结点（`SkipListNode`），每个结点代表一个被添加到该结构的数据项。当实例化`SkipList`时，该对象就会自带一个`SkipListNode`（不代表任何数据项的头结点）。

### 添加数据

当你向其中添加数据之前，首先会抛硬币，将第一次出现正面朝上时硬币被抛出的次数作为该数据的层数（`level`，**最小为1**），接着将数据和其层数封装成一个`SkipListNode`添加到`SkipList`中。结构初始化时，其头结点的层数为0，但每次添加数据后都会更新头结点的层数为所添数据中层数最大的。比如实例化一个`SkipList`后向其中添加一条层数为`3`的数据`7`：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list1.png) 

这时如果再添加一条层数为`2`的数据`5`呢？首先游标`curNode`会从`head`的最高层出发往右走，走到数据项为7的结点，发现`7>5`，于是又退回来走向下一层：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list2.png) 

接着再尝试往右走，还是发现`7>5`，于是还是准备走向下一层，但此时发现`curNode`所在层数`2`是数据项`5`的最高层，于是先建出数据项`5`的第二层，`curNode`再走向下一层：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list3.png) 

同样的，`curNode`尝试往右走，但发现`7>5`，`curNode`所在层为1，但数据`5`的第一层还没建，于是建出，`curNode`再往下走。当`curNode`走到`null`时，建出数据`5`根部的`null`：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list4.png) 

至此层数为2的数据项`5`的添加操作完毕。

那如果添加一个层数较高的数据项该如何处理呢？以添加层数为4的数据`10`为例：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list5.png) 

添加操作对应的代码示例：

```java
import java.util.ArrayList;

/**
 * A stored structure.Its add,delete,update,find operation are log(2,N)
 *s
 */
public class SkipList {
    private SkipListNode head;
    private int maxLevel;
    private int size;
    public static final double PROBABILITY = 0.5;

    public SkipList() {
        this.head = new SkipListNode(Integer.MIN_VALUE);
        /**
         * the 0th level of each SkipListNode is null
         */
        this.head.nextNodes.add(null);
        this.maxLevel = 0;
        this.size = 0;
    }

    private class SkipListNode {
        int value;
        /**
         * nextNodes represent the all levels of a SkipListNode the element on
         * one index represent the successor SkipListNode on the indexth level
         */
        ArrayList<SkipListNode> nextNodes;

        public SkipListNode(int newValue) {
            this.value = newValue;
            this.nextNodes = new ArrayList<SkipListNode>();
        }
    }

    /**
     * put a new data into the structure->log(2,N)
     *
     * @param newValue
     */
    public void add(int newValue) {
        if (!contains(newValue)) {

            // generate the level
            int level = 1;
            while (Math.random() < PROBABILITY) {
                level++;
            }
            // update max level
            if (level > maxLevel) {
                int increment = level - maxLevel;
                while (increment-- > 0) {
                    this.head.nextNodes.add(null);
                }
                maxLevel = level;
            }
            // encapsulate value
            SkipListNode newNode = new SkipListNode(newValue);
            // build all the levels of new node
            SkipListNode cur = findInsertionOfTopLevel(newValue, level);
            while (level > 0) {
                if (cur.nextNodes.get(level) != null) {
                    newNode.nextNodes.add(0, cur.nextNodes.get(level));
                } else {
                    newNode.nextNodes.add(0, null);
                }
                cur.nextNodes.set(level, newNode);
                level--;
                cur = findNextInsertion(cur, newValue, level);
            }
            newNode.nextNodes.add(0, null);
            size++;
        }
    }

    /**
     * find the insertion point of the newNode's top level from head's maxLevel
     * by going right or down
     *
     * @param newValue newNode's value
     * @param level    newNode's top level
     * @return
     */
    private SkipListNode findInsertionOfTopLevel(int newValue, int level) {
        int curLevel = this.maxLevel;
        SkipListNode cur = head;
        while (curLevel >= level) {
            if (cur.nextNodes.get(curLevel) != null
                    && cur.nextNodes.get(curLevel).value < newValue) {
                // go right
                cur = cur.nextNodes.get(curLevel);
            } else {
                // go down
                curLevel--;
            }
        }
        return cur;
    }

    /**
     * find the next insertion from cur node by going right on the level
     *
     * @param cur
     * @param newValue
     * @param level
     * @return
     */
    private SkipListNode findNextInsertion(SkipListNode cur, int newValue,
                                           int level) {
        while (cur.nextNodes.get(level) != null
                && cur.nextNodes.get(level).value < newValue) {
            cur = cur.nextNodes.get(level);
        }
        return cur;
    }

    /**
     * check whether a value exists->log(2,N)
     *
     * @param value
     * @return
     */
    public boolean contains(int value) {
        if (this.size == 0) {
            return false;
        }
        SkipListNode cur = head;
        int curLevel = maxLevel;
        while (curLevel > 0) {
            if (cur.nextNodes.get(curLevel) != null) {
                if (cur.nextNodes.get(curLevel).value == value) {
                    return true;
                } else if (cur.nextNodes.get(curLevel).value < value) {
                    cur = cur.nextNodes.get(curLevel);
                } else {
                    curLevel--;
                }
            } else {
                curLevel--;
            }
        }

        return false;
    }

    public static void main(String[] args) {
        SkipList skipList = new SkipList();
        skipList.add(1);
        skipList.add(2);
        skipList.add(3);
        skipList.add(4);
        skipList.add(5);
        //mark a break point here to check the memory structure of skipList
        System.out.println(skipList);
    }

}
```

### 查找数据

查找数据项的操作和添加数据项的步骤类似，也是游标`curNode`从`head`的最高层出发，每次先尝试向右走来到`nextNode`，如果`nextNode`封装的数据大于查找的目标`target`或`nextNode`为空，那么`curNode`回退并向下走；如果`nextNode`封装的数据小于`target`，那么`curNode`继续向右走，直到`curNode`走到的结点数据与`target`相同表示找到了，否则`curNode`走到了某一结点的根部`null`，那么说明结构中不存在该数据。`->contains()`

### 删除数据

了解添加数据的过程之后，删除数据其实就是将逻辑倒过来：解除该数据结点的前后引用关系。下图是我在写好上述`add()`方法后，向其中放入`1、2、3、4、5`后形成的结构：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list6.png) 

如果此时删除数据`3`：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list7.png) 

首先应该从`head`的最高层出发，通过向右或向下找到数据3的最高层（如图`2->3->5->6->7`），将该层移除整体结构并处理好该层上，其前后结点的关系。同样的逻辑，将数据`3`剩下的层移除。

示例代码：

```java
/**
     * delete skipListNode by the value
     *
     * @param value
     */
public void delete(int value) {
    //if exists
    if (contains(value)) {
        //find the node and its level
        SkipListNode deletedNode = head;
        int deletedLevels = maxLevel;
        //because exists,so must can find
        while (deletedLevels > 0) {
            if (deletedNode.nextNodes.get(deletedLevels) != null) {
                if (deletedNode.nextNodes.get(deletedLevels).value == value) {
                    deletedNode = deletedNode.nextNodes.get(deletedLevels);
                    break;
                } else if (deletedNode.nextNodes.get(deletedLevels).value < value) {
                    deletedNode = deletedNode.nextNodes.get(deletedLevels);
                } else {
                    deletedLevels--;
                }
            } else {
                deletedLevels--;
            }
        }
        //release the node and adjust the reference
        while (deletedLevels > 0) {
            SkipListNode pre = findInsertionOfTopLevel(value, deletedLevels);
            if (deletedNode.nextNodes.get(deletedLevels) != null) {
                pre.nextNodes.set(deletedLevels, deletedNode.nextNodes.get(deletedLevels));
            } else {
                pre.nextNodes.set(deletedLevels, null);
            }
            deletedLevels--;
        }

        size--;
    }
}

public static void main(String[] args) {
    SkipList skipList = new SkipList();
    skipList.add(1);
    skipList.add(2);
    skipList.add(3);
    skipList.add(4);
    skipList.add(5);
    //mark a break point here to check the memory structure of skipList
    skipList.delete(3);
    System.out.println(skipList);
}
```

### 遍历数据

需要遍历跳表中的数据时，我们可以根据每个数据的层数至少为1的特点（每个结点的第一层引用的是比该结点数据大的结点中数据最小的结点）。

示例代码：

```java
class SkipListIterator implements Iterator<Integer> {
    private SkipListNode cur;
    public SkipListIterator(SkipList skipList) {
        this.cur = skipList.head;
    }

    @Override
    public boolean hasNext() {
        return cur.nextNodes.get(1) != null;
    }

    @Override
    public Integer next() {
        int value = cur.nextNodes.get(1).value;
        cur = cur.nextNodes.get(1);
        return value;
    }
}

@Override
public String toString() {
    SkipListIterator iterator = new SkipListIterator(this);
    String res = "[ ";
    while (iterator.hasNext()) {
        res += iterator.next()+" ";
    }
    res += "]";
    System.out.println();
    return res;
}

public static void main(String[] args) {
    SkipList skipList = new SkipList();
    skipList.add(1);
    skipList.add(2);
    skipList.add(3);
    skipList.add(4);
    skipList.add(5);
    System.out.println(skipList);
    skipList.delete(3);
    System.out.println(skipList);
}
```