---
title: 左神算法班笔记-时间复杂度和空间复杂度
date: 2020-03-10 21:31:29
category:
- 左神算法
- 时间和空间复杂度
---

# 时间复杂度

时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为`O(n)`），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于**常数**时间内的操作（对应时间复杂度`O(1)`）。

在化简某算法时间复杂度表达式时需遵循以下规则：

- 对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如`O(n^2)+O(n)`可化简为`O(n^2)`，`O(n)+O(1)`可化简为`O(n)`
- 可省去样本量前的常量系数，如`O(2n)`可化简为`O(n)`，`O(8)`可化简为`O(1)`
- 对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如`O(logm)+O(n^2)`不能化简为`O(n^2)`或`O(logm)`。而要视m、n两者之间的差距来化简，比如m>>n时可以化简为`O(logm)`，因为表达式增量是由样本量决定的。

# 额外空间复杂度

算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量`temp`，那么该算法的额外空间复杂度为`O(1)`。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为`O(n)`。

# 经典例题——举一反三

## 找出B中不属于A的数

> 找出数组B中不属于A的数，数组A有序而数组B无序。假设数组A有n个数，数组B有m个数，写出算法并分析时间复杂度。

### 方法一：遍历

首先遍历B，将B中的每个数拿到到A中找，若找到则打印。对应算法如下：

```java
int A[] = {1, 2, 3, 4, 5};
int B[] = {1, 4, 2, 6, 5, 7};

for (int i = 0; i < 6; ++i) {
  int temp = B[i];
  bool flag = false;
  for (int j = 0; j < 5; ++j) {
    if (A[j] == temp) {
      flag = true;    //找到了
      break;
    }
  }
  if (!flag) {    //没找到
    printf("%d", temp);
  }
}
```

不难看出上述算法的时间复杂度为`O(m*n)`，因为将两个数组都遍历了一遍

### 方法二：二分查找

由于数组A是有序的，**在一个有序序列中查找一个元素可以使用二分法（也称折半法）**。原理就是将查找的元素与序列的中位数进行比较，如果小于则去掉中位数及其之后的序列，如果大于则去掉中位数及其之前的序列，如果等于则找到了。如果不等于那么再将其与剩下的序列继续比较直到找到或剩下的序列为空为止。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/binarySearch.png)

利用二分法对应题解的代码如下：

```java
for (int i = 0; i < 6; ++i) {		//B的长度为6
  int temp = B[i];
  //二分法查找
  int left = 0,right = 5-1;			//A的长度为5
  int mid = (left + right) / 2;
  while (left < right && A[mid] != temp) {
    if (A[mid] > temp) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
    mid = (left + right) / 2;
  }
  if (A[mid] != temp) {
    printf("%d", temp);
  }
}
```

for`循环`m`次，`while`循环`logn`次（如果没有特别说明，log均以2为底），此算法的时间复杂度为`O(mlogn)

### 方法三：排序+外排

第三种方法就是将数组B也排序，然后使用**逐次比对**的方式来查找A数组中是否含有B数组中的某元素。引入a、b两个指针分别指向数组A、B的首元素，比较指针指向的元素值，当`a时，向后移动a指针查找该元素；当`a=b`时，说明A中存在该元素，跳过该元素查找，向后移动b；当`a>b`时说明A中不存在该元素，打印该元素并跳过该元素的查找，向后移动b。直到a或b有一个到达数组末尾为止（若a先到达末尾，那么b和b之后的数都不属于A）

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/sorting.png)

对应题解的代码如下：

```c++
void fun3(int A[],int a_length,int B[],int b_length){
    quickSort(B, 0, b_length - 1);	//使用快速排序法对数组B排序->O(mlogm)
    int* a = A,*b=B;
    while (a <= A + a_length - 1 || b <= B + b_length - 1) {
        if (*a == *b) {
            b++;
            continue;
        }
        if (*a > *b) {
            printf("%d", *b);
            b++;
        } else {
            a++;
        }
    }

    if (a == A + a_length) {	//a先到头
        while (b < B + b_length) {
            printf("%d", *b);
            b++;
        }
    }
}
```

快速排序的代码如下：

```c++
#include <stdlib.h>
#include <time.h>
//交换两个int变量的值
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

//产生一个low~high之间的随机数
int randomInRange(int low, int high){
    srand((int) time(0));
    return (rand() % (high - low))+low;
}

//快速排序的核心算法，随机选择一个数，将比该数小的移至数组左边，比该数大的移至
//数组右边，最后返回该数的下标（移动完之后该数的下标可能与移动之前不一样）
int partition(int arr[],int start,int end){
    if (arr == NULL || start < 0 || end <= 0 || start > end) {
        return -1;
    }

    int index = randomInRange(start, end);//随机选择一个数
    swap(arr[index], arr[end]);//将该数暂时放至末尾

    int small = start - 1;
    //遍历前n-1个数与该数比较并以该数为界限将前n-1个数
    //分为两组，small指向小于该数的那一组的最后一个元素
    for (index = start; index < end; index++) {
        if (arr[index] < arr[end]) {
            small++;
            if (small != index) {
                swap(arr[small], arr[index]);
            }
        }
    }

    //最后将该数放至数值较小的那一个组的中间
    ++small;
    swap(arr[small], arr[end]);
    return small;
}

void quickSort(int arr[],int start,int end) {
    if (start == end) {
        return;
    }
    int index = partition(arr, start, end);
    if (index > start) {
        quickSort(arr,start, index - 1);
    }
    if (index < end) {
        quickSort(arr, index + 1, end);
    }
}
```

此种方法的时间复杂度为：`O(mlogm)`（先对B排序）+`O(m+n)`（最坏的情况是指针a和b都到头）。

### 三种方法的比较

1. `O(m*n)`
2. `O(mlogn)`（以2为底）
3. `O(mlogm)+O(m+n)`（以2为底）

易知算法2比1更优，因为增长率`logn < n`。而2和3的比较取决于样本量m和n之间的差距，若`m>>n`那么2更优，不难理解：数组B元素较多，那么对B的排序肯定要花费较长时间，而这一步并不是题解所必需的，不如采用二分法；相反地，若`m<<n`，那么3更优。

## 荷兰国旗问题

给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。

> 要求额外空间复杂度O(1)，时间复杂度O(N)

思路：利用两个指针`L`、`R`，将`L`指向首元素之前，将`R`指向尾元素之后。从头遍历序列，将当前遍历元素与`num`比较，若`num`，则将其与`L`的右一个元素交换位置并遍历下一个元素、右移`L`；若`=num`则直接遍历下一个元素；若`>num`则将其和`R`的左一个元素交换位置，并重新判断当前位置元素与`num`的关系。直到遍历的元素下标到为`R-1`为止。

```java
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}
void partition(int arr[],int startIndex,int endIndex,int num){
    int L = startIndex - 1, R = endIndex + 1, i = startIndex;
    while (i <= R - 1) {
        if (arr[i] < num) {
            swap(arr[i++], arr[++L]);
        } else if (arr[i] > num) {
            swap(arr[i], arr[--R]);
        } else {
            i++;
        }
    }
}

int main(){
    int arr[] = {1,2, 1, 5, 4, 7, 2, 3, 9,1};
    travles(arr, 8);
    partition(arr, 0, 7, 2);
    travles(arr, 8);
    return 0;
}
```

`L`代表小于`num`的数的右界，`R`代表大于`num`的左界，`partition`的过程就是遍历元素、不断壮大`L、R`范围的过程。这里比较难理解的地方可能是为什么`arr[i]时要右移`L`而`arr[i]>num`时却不左移`R`，这是因为对于当前元素`arr[i]`，如果`arr[i]进行`swap(arr[i],arr[L+1])`之后对于当前下标的数据状况是知晓的（一定有`arr[i]=arr[L+1]`），因为是从头遍历到`i`的，而`L+1<=i`。但是如果`arr[i]>num`进行`swap(arr[i],arr[R-1])`之后对于当前元素的数据状况是不清楚的，因为`R-1>=i`，`arr[R-1]`还没遍历到。

## 矩阵打印问题

### 转圈打印方块矩阵

给定一个4阶矩阵如下：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/circlePrint.png)

打印结果如下（要求额外空间复杂度为`O(1)`）：

```java
1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10
```

> 思路：这类问题需要将思维打开，从宏观的层面去找出问题存在的共性从而求解。如果你的思维局限在1是如何变到2的、4是怎么变到8的、11之后为什么时10、它们之间有什么关联，那么你就陷入死胡同了。
>
> 从宏观的层面找共性，其实转圈打印的过程就是不断顺时针打印外围元素的过程，只要给你一个左上角的点（如`(0,0)`）和右下角的点（如`(3,3)`），你就能够打印出`1 2 3 4 8 12 16 15 14 13 9 5`；同样，给你`(1,1)`和`(2,2)`，你就能打印出`6 7 11 10`。这个根据两点打印正方形上元素的过程可以抽取出来，整个问题也就迎刃而解了。

打印一个矩阵某个正方形上的点的逻辑如下：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/circlePrint1.png)

```c++
#include <stdio.h>
#define FACTORIAL 4

void printSquare(int leftUp[], int rigthDown[],int matrix[][FACTORIAL]){
    int i = leftUp[0], j = leftUp[1];
    while (j < rigthDown[1]) {
        printf("%d ", matrix[i][j++]);
    }
    while (i < rigthDown[0]) {
        printf("%d ", matrix[i++][j]);
    }
    while (j > leftUp[1]) {
        printf("%d ", matrix[i][j--]);
    }
    while (i > leftUp[0]) {
        printf("%d ", matrix[i--][j]);
    }
}

void printMatrixCircled(int matrix[][FACTORIAL]){
    int leftUp[] = {0, 0}, rightDown[] = {FACTORIAL-1,FACTORIAL-1};
    while (leftUp[0] < rightDown[0] && leftUp[1] < rightDown[1]) {
        printSquare(leftUp, rightDown, matrix);
        ++leftUp[0];
        ++leftUp[1];
        --rightDown[0];
        --rightDown[1];
    }
}

int main(){
    int matrix[4][4] = {
            {1,  2,  3,  4},
            {5,  6,  7,  8},
            {9,  10, 11, 12},
            {13, 14, 15, 16}
    };
    printMatrixCircled(matrix);//1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10
}
```

### 旋转方块矩阵

给定一个方块矩阵，请把该矩阵调整成顺时针旋转90°之后的样子，要求额外空间复杂度为`O(1)`。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rotatePrint.png)

> 思路：拿上图举例，首先选取矩阵四个角上的点`1,3,9,7`，按顺时针的方向`1`到`3`的位置（`1->3`）、`3->9`、`9->7`、`7->1`，这样对于旋转后的矩阵而言，这四个点已经调整好了。接下来只需调整`2,6,8,4`的位置，调整方法是一样的。只需对矩阵第一行的前n-1个点采用同样的方法进行调整、对矩阵第二行的前前n-3个点……，那么调整n阶矩阵就容易了。
>
> 这也是在宏观上观察数据变动的一般规律，找到以不变应万变的通解（给定一个点，确定矩阵上以该点为角的正方形，将该正方形旋转90°），整个问题就不攻自破了。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rotatePrint1.png)

```c++
#include <stdio.h>
#define FACTORIAL 4

void circleSquare(int leftUp[],int rightDown[],int matrix[][FACTORIAL]){
    int p1[] = {leftUp[0], leftUp[1]};
    int p2[] = {leftUp[0], rightDown[1]};
    int p3[] = {rightDown[0], rightDown[1]};
    int p4[] = {rightDown[0],leftUp[1]};
    while (p1[1] < rightDown[1]) {
        //swap
        int tmp = matrix[p4[0]][p4[1]];
        matrix[p4[0]][p4[1]] = matrix[p3[0]][p3[1]];
        matrix[p3[0]][p3[1]] = matrix[p2[0]][p2[1]];
        matrix[p2[0]][p2[1]] = matrix[p1[0]][p1[1]];
        matrix[p1[0]][p1[1]] = tmp;

        p1[1]++;
        p2[0]++;
        p3[1]--;
        p4[0]--;
    }
}

void circleMatrix(int matrix[][FACTORIAL]){
    int leftUp[] = {0, 0}, rightDown[] = {FACTORIAL - 1, FACTORIAL - 1};
    while (leftUp[0] < rightDown[0] && leftUp[1] < rightDown[1]) {
        circleSquare(leftUp, rightDown, matrix);
        leftUp[0]++;
        leftUp[1]++;
        --rightDown[0];
        --rightDown[1];
    }
}

void printMatrix(int matrix[][FACTORIAL]){
    for (int i = 0; i < FACTORIAL; ++i) {
        for (int j = 0; j < FACTORIAL; ++j) {
            printf("%2d ", matrix[i][j]);
        }
        printf("\n");
    }
}

int main(){
    int matrix[FACTORIAL][FACTORIAL] = {
            {1,  2,  3,  4},
            {5,  6,  7,  8},
            {9,  10, 11, 12},
            {13, 14, 15, 16}
    };
    printMatrix(matrix);
    circleMatrix(matrix);
    printMatrix(matrix);
}
```

### 之字形打印矩阵

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/zigzagPrint.png)

对如上矩阵的打印结果如下（要求额外空间复杂度为`O(1)`）：

```java
1 2 7 13 8 3 4 9 14 15 10 5 6 11 16 17 12 18
```

> 此题也是需要从宏观上找出一个共性：给你两个，你能否将该两点连成的45°斜线上的点按给定的打印方向打印出来。拿上图举例，给出`(2,0)`、`(0,2)`和`turnUp=true`，应该打印出`13,8,3`。那么整个问题就变成了两点的走向问题了，开始时两点均为`(0,0)`，然后一个点往下走，另一个点往右走（如`1->7`，`1->2`）；当往下走的点是边界点时就往右走（如`13->14`），当往右走的点到边界时就往下走（如`6->12`）。每次两点走一步，并打印两点连线上的点。

```c++
#include <stdio.h>

const int rows = 3;
const int cols = 6;

void printLine(int leftDown[],int rightUp[], bool turnUp,int matrix[rows][cols]){
    int i,j;
    if (turnUp) {
        i = leftDown[0], j = leftDown[1];
        while (j <= rightUp[1]) {
            printf("%d ", matrix[i--][j++]);
        }
    } else {
        i = rightUp[0], j = rightUp[1];
        while (i <= leftDown[0]) {
            printf("%d ", matrix[i++][j--]);
        }
    }
}

void zigZagPrintMatrix(int matrix[rows][cols]){
    if (matrix==NULL)
        return;
    int leftDown[] = {0, 0}, rightUp[] = {0, 0};
    bool turnUp = true;
    while (leftDown[1] <= cols - 1) {
        printLine(leftDown, rightUp, turnUp, matrix);
        turnUp = !turnUp;
        if (leftDown[0] < rows - 1) {
            leftDown[0]++;
        } else {
            leftDown[1]++;
        }
        if (rightUp[1] < cols - 1) {
            ++rightUp[1];
        } else {
            ++rightUp[0];
        }
    }
}

int main(){
    int matrix[rows][cols] = {
            {1,  2,  3,  4,  5,  6},
            {7,  8,  9,  10, 11, 12},
            {13, 14, 15, 16, 17, 18}
    };
    zigZagPrintMatrix(matrix);//1 2 7 13 8 3 4 9 14 15 10 5 6 11 16 17 12 18
    return 0;
}
```

### 在行和列都排好序的矩阵上找数

如图：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/findNumInSortedMatrix.png)

任何一列或一行上的数是有序的，实现一个函数，判断某个数是否存在于矩阵中。要求时间复杂度为`O(M+N)`，额外空间复杂度为`O(1)`。

> 从矩阵右上角的点开始取点与该数比较，如果大于该数，那么说明这个点所在的列都不存在该数，将这个点左移；如果这个点上的数小于该数，那么说明这个点所在的行不存在该数，将这个点下移。直到找到与该数相等的点为止。最坏的情况是，该数只有一个且在矩阵左下角上，那么时间复杂度为`O(M-1+N-1)=O(M+N)`

```c++
#include <stdio.h>
const int rows = 4;
const int cols = 4;

bool findNumInSortedMatrix(int num,int matrix[rows][cols]){
    int i = 0, j = cols - 1;
    while (i <= rows - 1 && j <= cols - 1) {
        if (matrix[i][j] > num) {
            --j;
        } else if (matrix[i][j] < num) {
            ++i;
        } else {
            return true;
        }
    }
    return false;
}

int main(){
    int matrix[rows][cols] = {
            {1, 2, 3, 4},
            {2, 4, 5, 8},
            {3, 6, 7, 9},
            {4, 8, 9, 10}
    };
    if (findNumInSortedMatrix(7, matrix)) {
        printf("find!");
    } else {
        printf("not exist!");
    }
    return 0;
}
```

## 岛问题

一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？

比如矩阵：

| 1    | 0    | 1    |
| :--- | :--- | :--- |
| 0    | 1    | 0    |
| 1    | 1    | 1    |

就有3个岛。

> 分析：我们可以遍历矩阵中的每个位置，如果遇到1就将与其相连的一片1都感染成2，并自增岛数量。

```java
public class IslandNum {
	
	public static int getIslandNums(int matrix[][]){
		int res = 0 ;
		for(int i = 0 ; i < matrix.length ; i++){
			for(int j = 0 ; j < matrix[i].length ; j++){
				if(matrix[i][j] == 1){
					res++;
					infect(matrix , i , j);
				}
			}
		}
		return res;
	}

	public static void infect(int matrix[][], int i ,int j){
		if(i < 0 || i >= matrix.length || j < 0 || j >= matrix[i].length || matrix[i][j] != 1){
			return;
		}
		matrix[i][j] = 2;
		infect(matrix , i-1 , j);
		infect(matrix , i+1 , j);
		infect(matrix , i , j-1);
		infect(matrix , i , j+1);
	}

	public static void main(String[] args){
		int matrix[][] = {
			{1,0,0,1,0,1},
			{0,1,1,0,0,0},
			{1,0,0,0,1,1},
			{1,1,1,1,1,1}
		};
		System.out.println(getIslandNums(matrix));
	}
}
```
