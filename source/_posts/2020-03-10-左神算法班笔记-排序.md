---
title: 左神算法班笔记-排序
date: 2020-03-10 21:50:01
category:
- 左神算法
- 排序
---

## 数组

### 冒泡排序

冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置，接下来只需对剩下的（n-1）个元素，重复上述操作即可。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/bubbleSort.png)

```c++
void swap(int *a, int *b){
  int temp = *a;
  *a = *b;
  *b = temp;
}

void bubbleSort(int arr[], int length) {
  if(arr==NULL || length<=1){
    return;
  }
  for (int i = length-1; i > 0; i--) {	//只需比较(length-1)轮
    for (int j = 0; j < i; ++j) {
      if (arr[j] > arr[j + 1]) {
        swap(&arr[j], &arr[j + 1]);
      }
    }
  }
}
```

该算法的时间复杂度为`n+(n-1)+...+1`，很明显是一个等差数列，由（首项+末项）*项数/2求其和为`(n+1)n/2`，可知时间复杂度为`O(n^2)`

### 选择排序

以升序排序为例：找到最小数的下标`minIndex`，将其与第一个数交换，接着对子序列（1-n）重复该操作，直到子序列只含一个元素为止。(即选出最小的数放到第一个位置，该数安排好了，再对剩下的数选出最小的放到第二个位置，以此类推）

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/selectSort.png)

```c++
void selectionSort(int arr[], int length) {
  for (int i = 0; i < length-1; ++i) {    //要进行n-1次选择，选出n-1个数分别放在前n-1个位置上
    if(arr==NULL || length<=1){
      return;
    }
    int minIndex = i;	//记录较小数的下标
    for (int j = i+1; j < length; ++j) {
      if (arr[minIndex] > arr[j]) {
        minIndex = j;
      }
    }
    if (minIndex != i) {
      swap(&arr[minIndex],&arr[i]);
    }
  }
}
```

同样，不难得出该算法的时间复杂度（big o）为`O(n^2)`（n-1+n-2+n-3+…+1）

### 插入排序

插入排序的过程可以联想到打扑克时揭一张牌然后将其到手中有序纸牌的合适位置上。比如我现在手上的牌是7、8、9、J、Q、K，这时揭了一张10，我需要将其依次与K、Q、J、9、8、7比较，当比到9时发现大于9，于是将其插入到9之后。对于一个无序序列，可以将其当做一摞待揭的牌，首先将首元素揭起来，因为揭之前手上无牌，因此此次揭牌无需比较，此后每揭一次牌都需要进行上述的插牌过程，当揭完之后，手上的握牌顺序就对应着该序列的有序形式。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/insertSort.png)

```c++
void swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}
void insertionSort(int arr[], int length){
    if(arr==NULL || length<=1){
        return;
    }
    for (int i = 1; i < length; ++i) {		//第一张牌无需插入，直接入手，后续揭牌需比较然后插入，因此从第二个元素开始遍历（插牌）
      	//将新揭的牌与手上的逐次比较，若小于则交换，否则停止，比较完了还没遇到更小的也停止
        for (int j = i - 1; j >= 0 || arr[j] <= arr[j + 1]; j--) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
            }
        }
    }
}
```

插入排序的big o该如何计算？可以发现如果序列有序，那么该算法的big o为`O(n)`，因为只是遍历了一次序列（这时最好情况）；如果序列降序排列，那么该算法的big o为`O(n^2)`（每次插入前的比较交换加起来要：1+2+…+n-1）（最坏情况）。**一般应用场景中都是按算法的最坏情况来考量算法的效率的，因为你做出来的应用要能够承受最坏情况。**即该算法的big o为`O(n^2)`

### 归并排序

归并排序的核心思想是先让序列的左半部分有序、再让序列的右半部分有序，最后从两个子序列（左右两半）从头开始逐次比较，往辅助序列中填较小的数。

以序列`{2,1,4,3}`为例，归并排序的过程大致如下：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mergeSort.png)

```c++
void merge(int arr[],int helpArr[], int startIndex, int midIndex,int endIndex) {
    int L = startIndex, R = midIndex + 1, i = startIndex;
    while (L <= midIndex && R <= endIndex) { //只要没有指针没越界就逐次比较
        helpArr[i++] = arr[L] < arr[R] ? arr[L++] : arr[R++];
    }
    while (L != midIndex + 1) {
        helpArr[i++] = arr[L++];
    }
    while (R != endIndex + 1) {
        helpArr[i++] = arr[R++];
    }
    for (i = startIndex; i <= endIndex; i++) {
        arr[i] = helpArr[i];
    }
}

void mergeSort(int arr[],int helpArr[], int startIndex, int endIndex) {
    int midIndex;
    if (startIndex < endIndex) {  //当子序列只含一个元素时，不再进行此子过程
      	//(endIndex+startIndex)/2可能会导致int溢出，下面求中位数的做法更安全
        midIndex = startIndex + ((endIndex - startIndex) >> 1);
        mergeSort(arr, helpArr, startIndex, midIndex);        //对左半部分排序
        mergeSort(arr, helpArr, midIndex + 1, endIndex);      //对右半部分排序
        merge(arr, helpArr, startIndex, midIndex, endIndex);  //使整体有序
    }
}

int main(){
    int arr[] = {9, 1, 3, 4, 7, 6, 5};
    travels(arr, 7);//遍历打印
    int helpArr[7];
    mergeSort(arr, helpArr, 0, 7);
    travels(arr, 7);

    return 0;
}
```

此算法的核心就是第`24、25、26`这三行。第`26`行应该不难理解，就是使用两个指针`L、R`外加一个辅助数组，将两个序列有序地**并入**辅助数组。但为什么`24、25`行执行过后数组左右两半部分就分别有序了呢？这就又牵扯到了归并排序的核心思想：先让一个序列左右两半部分有序，然后再并入使整体有序。因此`24、25`是对左右两半部分分别递归执行归并排序，直到某次递归时左右两半部分均为一个元素时递归终止。当一个序列只含两个元素时，调用`mergeSort`会发现`24、25`行是无效操作，直接执行`merge`。就像上图所示，两行递归完毕后，左右两半部分都会变得有序。

> 当一个递归过程比较复杂时（不像递归求阶乘那样一幕了然），我们可以列举简短样本进行分析。
>
> 对于这样复杂的递归行为，千万不要想着追溯整个递归过程，只需分析第一步要做的事（比如此例中第一步要做的是就是`mergeSort`函数所呈现出来的那样：对左半部分排序、对右半部分排序、最后并入，你先不管是怎么排序的，不要被24、25行的`mergeSort`给带进去了）和递归终止的条件（比如此例中是``startIndex>=endIndex`，即要排序的序列只有一个元素时）。

归并排序的时间复杂度是`O(nlogn)`，额外空间复杂度是`O(n)`。

根据**Master公式**（本文 **小技巧**一节中有讲到）可得`T(n)=2T(n/2)+O(n)`，第一个2的含义是子过程（对子序列进行归并排序）要执行两次，第二个2的含义是子过程样本量占一半（因为分成了左右两半部分），最后`O(n)`表示左右有序之后进行的并入操作为`O(n+n)=O(n)`(L、R指针移动次数总和为n，将辅助数组覆盖源数组为n)，符合`T(n)=aT(n/b)+O(n^d)`，经计算该算法的时间复杂度为`O(nlogn)`

#### 小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。例如：

```java
对于数组[1,3,4,2,5]
1左边比1小的数，没有；
3左边比3小的数，1；
4左边比4小的数，1、3；
2左边比2小的数，1；
5左边比5小的数，1、3、4、2；
所以小和为1+1+3+1+1+3+4+2=16
```

简单的做法就是遍历一遍数组，将当前遍历的数与该数之前数比较并记录小于该数的数。易知其时间复杂度为`O(n^2)`（0+1+2+……+n-1）。

更优化的做法是利用归并排序的**并入逻辑**：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/min_sum.png)

对应代码：

```c++
int merge(int arr[],int helpArr[], int startIndex, int midIndex,int endIndex) {
    int L = startIndex, R = midIndex + 1, i = startIndex;
    int res=0;
    while (L <= midIndex && R <= endIndex ) { //只要没有指针没越界就逐次比较
        res += arr[L] < arr[R] ? arr[L] * (endIndex - R + 1) : 0;
        helpArr[i++] = arr[L] < arr[R] ? arr[L++] : arr[R++];
    }
    while (L != midIndex + 1) {
        helpArr[i++] = arr[L++];
    }
    while (R != endIndex + 1) {
        helpArr[i++] = arr[R++];
    }
    for (i = startIndex; i <= endIndex; i++) {
        arr[i] = helpArr[i];
    }
    return res;
}

int mergeSort(int arr[],int helpArr[], int startIndex, int endIndex) {
    int midIndex;
    if (startIndex < endIndex) {  //当子序列只含一个元素时，不再进行此子过程
        midIndex = startIndex + ((endIndex - startIndex) >> 1);
        return mergeSort(arr, helpArr, startIndex, midIndex) +        //对左半部分排序
               mergeSort(arr, helpArr, midIndex + 1, endIndex) +     //对右半部分排序
               merge(arr, helpArr, startIndex, midIndex, endIndex);  //使整体有序
    }
    return 0;	//一个元素时不存在小和
}

int main(){
    int arr[] = {1,3,4,2,5};
    int helpArr[5];
    printf("small_sum:%d\n",mergeSort(arr, helpArr, 0, 4)) ;
    return 0;
}
```

该算法在归并排序的基础上做了略微改动，即`merge`中添加了变量`res`记录每次**并入**操作应该累加的小和、`mergeSort`则将每次并入应该累加的小和汇总。此种做法的复杂度与归并排序的相同，优于遍历的做法。可以理解，依次求每个数的小和过程中有很多比较是重复的，而利用归并排序求小和时利用了并入的两个序列分别有序的特性省去了不必要的比较，如`134并入25`时，`2>1`直接推出`2`后面的数都`>1`，因此直接`1*(endIndex-indexOf(2)+1)`即可。这在样本量不大的情况下看不出来优化的效果，试想一下如果样本量为`2^32`，那么依照前者求小和`O(n^2)`可知时间复杂度为`O(21亿的平方)`，而归并排序求小和则只需`O(21亿*32)`，足以见得`O(n^2)`和`O(nlogn)`的优劣。

#### 逆序对问题

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

> 这题的思路也可以利用归并排序来解决，在并入操作时记录`arr[L]>arr[R]`的情况即可。

### 快速排序

#### 经典快排

经典快排就是将序列中比尾元素小的移动到序列左边，比尾元素大的移动到序列右边，对以该元素为界的左右两个子序列（均不包括该元素）重复此操作。

首先我们要考虑的是对给定的一个数，如何将序列中比该数小的移动到左边，比该数大的移动到右边。

> 思路：利用一个辅助指针`small`，代表较小数的右边界（初始指向首元素前一个位置），遍历序列每次遇到比该数小的数就将其与`arr[small+1]`交换并右移`small`，最后将该数与`arr[small+1]`交换即达到目的。对应算法如下：

```c++
void partition(int arr[], int startIndex, int endIndex){
    int small = startIndex - 1;
    for (int i = startIndex; i < endIndex; ++i) {
        if(arr[i] < arr[endIndex]) {
            if (small + 1 != i) {
                swap(arr[++small], arr[i]);
            } else {
                //如果small、i相邻则不用交换
                small++;
            }
        }
    }
    swap(arr[++small], arr[endIndex]);
}
int main(){
    int arr[] = {1, 2, 3, 4, 6, 7, 8, 5};
    travles(arr, 8);//1 2 3 4 6 7 8 5
    partition(arr, 0, 7);
    travles(arr, 8);//1 2 3 4 5 7 8 6
    return 0;
}
```

接着就是快排的递归逻辑：对`1 2 3 4 6 7 8 5`序列`partition`之后，去除之前的比较参数`5`，对剩下的子序列`1234`和`786`继续`partition`，直到子序列为一个元素为止：

```c++
int partition(int arr[], int startIndex, int endIndex){
    int small = startIndex - 1;
    for (int i = startIndex; i < endIndex; ++i) {
        if(arr[i] < arr[endIndex]) {
            if (small + 1 != i) {
                swap(arr[++small], arr[i]);
            } else {
                //如果small、i相邻则不用交换
                small++;
            }
        }
    }
    swap(arr[++small], arr[endIndex]);
    return small;
}

void quickSort(int arr[], int startIndex, int endIndex) {
    if (startIndex > endIndex) {
        return;
    }
    int index = partition(arr, startIndex, endIndex);
    quickSort(arr, startIndex, index - 1);
    quickSort(arr, index + 1, endIndex);
}
int main(){
    int arr[] = {1, 5, 6, 2, 7, 3, 8, 0};
    travles(arr, 8);	//1 5 6 2 7 3 8 0
    quickSort(arr, 0,7);
    travles(arr, 8);	//0 1 2 3 5 6 7 8
    return 0;
}
```

经典排序的时间复杂度与数据状况有关，如果**每一次**`partition`时，尾元素都是序列中最大或最小的，那么去除该元素序列并未如我们划分为样本量相同的左右两个子序列，而是只安排好了一个元素（就是去掉的那个元素），这样的话时间复杂度就是`O(n-1+n-2+……+1)=O(n^2)`；但如果每一次`partition`时，都将序列分成了两个样本量相差无几的左右两个子序列，那么时间复杂度就是`O(nlogn)`（使用Master公式求解）。

#### 由荷兰国旗问题引发对经典快排的改进

可以发现这里`partition`的过程与荷兰国旗问题中的`partition`十分相似，能否以后者的`partition`实现经典快排呢？我们来试一下：

```c++
int* partition(int arr[], int startIndex, int endIndex){ ;
    int small = startIndex - 1, great = endIndex + 1, i = startIndex;
    while (i <= great - 1) {
        if (arr[i] < arr[endIndex]) {
            swap(arr[++small], arr[i++]);
        } else if (arr[i] > arr[endIndex]){
            swap(arr[--great], arr[i]);
        } else {
            i++;
        }
    }
    int range[] = {small, great};
    return range;
}

void quickSort(int arr[], int startIndex, int endIndex) {
    if (startIndex > endIndex) {
        return;
    }
    int* range = partition(arr, startIndex, endIndex);
    quickSort(arr, startIndex, range[0]);
    quickSort(arr, range[1], endIndex);
}

int main(){
    int arr[] = {1, 5, 6, 2, 7, 3, 8, 0};
    travles(arr, 8);	//1 5 6 2 7 3 8 0
    quickSort(arr, 0,7);
    travles(arr, 8);	//0 1 2 3 5 6 7 8
    return 0;
}
```

比较一下经典排序和使用荷兰国旗问题改进后的经典排序，不难发现，后者一次`partition`能去除一个以上的元素（等于`arr[endIndex]`的区域），而前者每次`partition`只能去除一个元素，这里的去除相当于安排（排序）好了对应元素的位置。因此后者比经典排序更优，但是优化不大，只是常数时间内的优化，实质上的效率还是要看数据状况（最后的情况为`O(nlogn)`，最坏的情况为`O(n^2)`）。

#### 随机快排——O(nlogn)

上面谈到了快排的短板是依赖数据状况，那么我们有没有办法消除这个依赖，让他成为真正的`O(nlogn)`呢？

> 事实上，为了让算法中的操作不依托于数据状况（如快排中每一次`partition`取尾元素作为比较，这就没有规避样本的数据状况，如果尾元素是最大或最小值就成了最坏情况）常常有两种做法：
>
> 1、使用随机取数
>
> 2、将样本数据哈希打乱

随机快排就是采用上了上述第一种解决方案，在每一轮的`partition`中随机选择序列中的一个数作为要比较的数：

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

//产生[startIndex,endIndex]之间的随机整数
int randomInRange(int startIndex,int endIndex){
    return rand() % (endIndex - startIndex + 1) + startIndex;
}

int* partition(int arr[], int startIndex, int endIndex){ ;
    int small = startIndex - 1, great = endIndex + 1, i = startIndex;
    int randomNum = arr[randomInRange(startIndex, endIndex)];
    while (i <= great - 1) {
        if (arr[i] < randomNum) {
            swap(arr[++small], arr[i++]);
        } else if (arr[i] > randomNum){
            swap(arr[--great], arr[i]);
        } else {
            i++;
        }
    }
    int range[] = {small, great};
    return range;
}

void quickSort(int arr[], int startIndex, int endIndex) {
    if (startIndex > endIndex) {
        return;
    }
    int* range = partition(arr, startIndex, endIndex);
    quickSort(arr, startIndex, range[0]);
    quickSort(arr, range[1], endIndex);
}

void travles(int dataArr[], int length){
    for (int i = 0; i < length; ++i) {
        printf("%d ", dataArr[i]);
    }
    printf("\n");
}

int main(){
    srand(time(NULL));//此后调用rand()时将以调用时的时间为随机数种子
    int arr[] = {9,7,1,3,2,6,8,4,5};
    travles(arr, 9);
    quickSort(arr, 0,8);
    travles(arr, 9);
    return 0;
}
```

观察比较代码可以发现随机快排只不过是在`partition`时随机选出一个下标上的数作为比较对象，从而避免了每一轮选择尾元素会受数据状况的影响的问题。

> 那么随机快排的时间复杂度又为多少呢？

经数学论证，由于每一轮`partition`选出的作为比较对象的数是随机的，即序列中的每个数都有`1/n`的概率被选上，那么该算法时间复杂度为概率事件，经数学论证该算法的**数学期望**为`O(nlogn)`。虽然说是数学期望，但在实际工程中，常常就把随机快排的时间复杂度当做`O(nlog)`。

### 堆排序

#### 什么是堆

堆结构就是将一颗**完全二叉树**映射到数组中的一种存储方式：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/heap.png)

#### 大根堆和小根堆

当堆的每一颗子树（包括树本身）的最大值就是其根结点时称为大根堆；相反，当堆的每一颗子树的最小值就是其根结点时称为小根堆。其中大根堆的应用较为广泛，是一种很重要的数据结构。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/heap1.png)

#### heapInsert和heapify

大根堆最重要的两个操作就是`heapInsert`和`heapify`，前者是当一个元素加入到大根堆时应该自底向上与其父结点比较，若大于父结点则交换；后者是当堆中某个结点的数值发生变化时，应不断向下与其孩子结点中的最大值比较，若小于则交换。下面是对应的代码：

#### 建立大根堆

```c++
void buildBigRootHeap(int arr[],int length){
    if (arr == NULL || length <= 1) {
        return;
    }
    for (int i = 0; i < length; ++i) {
        heapInsert(arr, i);
    }
}
```

#### 利用heapify排序

前面做了那么多铺垫都是为了建立大根堆，那么如何利用它来排序呢？

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/heapify.png)

对应代码实现如下：

```c++
void heapSort(int arr[],int length){
    if (arr == NULL || length <= 1) {
        return;
    }
  	//先建立大根堆
    for (int i = 0; i < length; ++i) {
        heapInsert(arr, i);
    }
 	  //循环弹出堆顶元素并heapify
    int heapSize = length;
    swap(arr[0], arr[--heapSize]);//相当于弹出堆顶元素
    while (heapSize > 0) {
        heapify(arr, heapSize, 0);
        swap(arr[0], arr[--heapSize]);
    }
}

int main(){
    int arr[] = {9,7,1,3,6,8,4,2,5};
    heapSort(arr, 9);
    travles(arr, 9);
    return 0;
}
```

堆排序的优势在于无论是入堆一个元素`heapInsert`还是出堆一个元素之后的`heapify`都不是将整个样本遍历一遍（`O(n)`级别的操作），而是树层次上的遍历（`O(logn)`级别的操作）。

这样的话堆排序过程中，建立堆的时间复杂度为`O(nlogn)`，循环弹出堆顶元素并`heapify`的时间复杂度为`O(nlogn)`，整个堆排序的时间复杂度为`O(nlogn)`，额外空间复杂度为`O(1)`

> 优先级队列结构（比如Java中的`PriorityQueue`）就是堆结构。

### 排序算法的稳定性

排序算法的稳定性指的是排序前后是否维持值相同的元素在序列中的相对次序。如序列`271532`，在排序过程中如果能维持第一次出现的`2`在第二次出现的`2`的前面，那么该排序算法能够保证稳定性。首先我们来分析一下前面所讲排序算法的稳定性，再来谈谈稳定性的意义。

- **冒泡排序**。可以保证稳定性，只需在比较相邻两个数时只在后一个数比前一个数大的情况下才交换位置即可。
- **选择排序**。无法保证稳定性，比如序列`926532`，在第一轮`maxIndex`的选择出来之后（`maxIndex=0`），第二次出现的`2`（尾元素）将与`9`交换位置，那么两个`2`的相对次序就发生了变化，而这个交换是否会影响稳定性在我们`coding`的时候是不可预测的。
- **插入排序**。可以保证稳定性，每次插入一个数到有序序列中时，遇到比它大的就替换，否则不替换。这样的话，值相同的元素，后面插入的就总在前面插入的后面了。
- **归并排序**。可以保证稳定性，在左右两半子序列排好序后的`merge`过程中，比较大小时如果相等，那么优先插入左子序列中的数。
- **快排**。不能保证稳定性，因为`partition`的过程会将比`num`小的与`small`区域的右一个数交换位置，将比`num`大的与`great`区域的左一个数交换位置，而`small`、`great`分居序列两侧，很容易打乱值相同元素的相对次序。
- **堆排序**。不能保证稳定性。二叉树如果交换位置的结点是相邻层次的可以保证稳定性，但堆排序中弹出堆顶元素后的`heapify`交换的是第一层的结点和最后一层的结点。

维持稳定性一般是为了满足业务需求。假设下面是一张不同厂商下同一款产品的价格和销售情况表：

| 品牌 | 价格 | 销量 |
| :--- | :--- | :--- |
| 三星 | 1603 | 92   |
| 小米 | 1603 | 74   |
| vivo | 1604 | 92   |

要求先按价格排序，再按销量排序。如果保证稳定性，那么排序后应该是这样的：

| 品牌 | 价格 | 销量 |
| :--- | :--- | :--- |
| 三星 | 1603 | 92   |
| vivo | 1604 | 92   |
| 小米 | 1603 | 74   |

即按销量排序后，销量相同的两条记录会保持之前的按价格排序的状态，这样先前的价格排序这个工作就没白做。

### 有关排序问题的补充

1. **归并排序**可以做到额外空间复杂度为`O(1)`，但是比较难，感兴趣的可以搜 **归并排序 内部缓存法**
2. **快速排序**可以做到保证稳定性，但是很难，可以搜`01 stable sort`（论文）
3. 有一道题是：是奇数放到数组左边，是偶数放到数组右边，还要求奇数和奇数之间、偶数和偶数之间的原始相对次序不变。这道题和归并排序如出一辙，只不过归并排序是将`arr[length-1]`或`arr[randomIndex]`作为比较的标准，而这道题是将是否能整除2作为比较的标准，这类问题都同称为`o1 sort`，要使这类问题做到稳定性，要看`01 stable sort`这篇论文。

### 工程中的综合排序算法

实际工程中的排序算法一般会将 **归并排序**、**插入排序**、**快速排序**综合起来，集大家之所长来应对不同的场景要求：

- 当要排序的元素为基本数据类型且元素个数较少时，直接使用 **插入排序**。因为在样本规模较小时（比如60），`O(NlogN)`的优势并不明显甚至不及`O(N^2)`，而在`O(N^2)`的算法中，插入排序的常数时间操作最少。
- 当要排序的元素为对象数据类型（包含若干字段），为保证稳定性将采用 **归并排序**。
- 当要排序的元素为基本数据类型且样本规模较大时，将采用 **快速排序**。

### 桶排序

上一节中所讲的都是基于比较的排序，也即通过比较确定每个元素所处的位置。那么能不能不比较而实现排序呢？这就涉及到了 **桶排序** 这个方法论：准备一些桶，将序列中的元素按某些规则放入翻入对应的桶中，最后根据既定的规则依次倒出桶中的元素。

> 非基于比较的排序，与被排序的样本的实际数据状况有很大关系，所以在实际中并不常用。

### 计数排序

计数排序是 **桶排序** 方法论的一种实现，即准备一个与序列中元素的数据范围大小相同的数组，然后遍历序列，将遇到的元素作为数组的下标并将该位置上的数加1。例如某序列元素值在0~100之间，请设计一个算法对其排序，要求时间复杂度为`O(N)`。

```c++
#include <stdio.h>

void countSort(int arr[],int length){
    int bucketArr[101];
    int i;
    for(i = 0 ; i <= 100 ; i++){
        bucketArr[i]=0;	//init buckets
    }
    for(i = 0 ; i < length ; i++){
        bucketArr[arr[i]]++;	//put into buckets
    }
    int count, j=0;
    for(i = 0 ; i <= 100 ; i++) {
        if (bucketArr[i] != 0) { //pour out
            count = bucketArr[i];
            while (count-- > 0) {
                arr[j++] = i;
            }
        }
    }
}

void travels(int arr[], int length){
    for (int i = 0; i < length; ++i) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[] = {9, 2, 1, 4, 5, 2, 1, 6, 3, 8, 1, 2};
    travels(arr, 12);//9 2 1 4 5 2 1 6 3 8 1 2
    countSort(arr, 12);
    travels(arr, 12);//1 1 1 2 2 2 3 4 5 6 8 9
    return 0;
}
```

>  如果下次面试官问你有没有事件复杂度比`O(N)`更优的排序算法时，不要忘了计数排序哦！！！

### 补充问题

1. 给定一个数组，求如果排序后，相邻两数的最大值，要求时间复杂度为`O(N)`，且要求不能用非基于比较的排序。

这道题的思路比较巧妙：首先为这N个数准备N+1个桶，然后以其中的最小值和最大值为边界将数值范围均分成N等分，然后遍历数组将对应范围类的数放入对应的桶中，下图以数组长度为9举例

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/barrel.png) 

这里比较难理解的是：

- 题目问的是求**如果排序后，相邻两数的最大差值**。该算法巧妙的借助一个空桶（N个数进N+1个桶，必然有一个是空桶），将问题转向了求**两个相邻非空桶**
    （其中可能隔着若干个空桶）之间前桶的最大值和后桶最小值的差值，而无需在意每个桶中进了哪些数（**只需记录每个桶入数的最大值和最小值以及是否有数**）

对应代码如下：

```c++
#include <stdio.h>

//根据要入桶的数和最大最小值得到对应桶编号
int getBucketId(int num,int bucketsNum,int min,int max){
    return (num - min) * bucketsNum / (max - min);
}

int max(int a, int b){
    return a > b ? a : b;
}

int min(int a, int b){
    return a < b ? a : b;
}

int getMaxGap(int arr[], int length) {
    if (arr == NULL || length < 2) {
        return -1;
    }
    int maxValue = -999999, minValue = 999999;
    int i;
    //找出最大最小值
    for (i = 0; i < length; ++i) {
        maxValue = max(maxValue, arr[i]);
        minValue = min(minValue, arr[i]);
    }
    //记录每个桶的最大最小值以及是否有数，初始时每个桶都没数
    int maxs[length + 1], mins[length + 1];
    bool hasNum[length + 1];
    for (i = 0; i < length + 1; i++) {	
        hasNum[i] = false;
    }
    //put maxValue into the last bucket
    mins[length] = maxs[length] = maxValue;
    hasNum[length] = true;

    //iterate the arr
    int bid; //bucket id
    for (i = 0; i < length; i++) {
        if (arr[i] != maxValue) {
            bid = getBucketId(arr[i], length + 1, minValue, maxValue);
          	//如果桶里没数，则该数入桶后，最大最小值都是它，否则更新最大最小值
            mins[bid] = !hasNum[bid] ? arr[i] : arr[i] < mins[bid] ? arr[i] : mins[bid];
            maxs[bid] = !hasNum[bid] ? arr[i] : arr[i] > maxs[bid] ? arr[i] : maxs[bid];
            hasNum[bid] = true;
        }
    }

    //find the max gap between two nonEmpty buckets
    int res = 0, j = 0;
    for (i = 0; i < length; ++i) {
        j = i + 1;//the next nonEmtpy bucket id
        while (!hasNum[j]) {//the last bucket must has number
            j++;
        }
        res = max(res, (mins[j] - maxs[i]));
    }

    return res;
}

int main(){
    int arr[] = {13, 41, 67, 26, 55, 99, 2, 82, 39, 100};
    printf("%d", getMaxGap(arr, 9));	//17
    return 0;
}
```
