---
title: 左神算法班笔记-递归和动态规划
date: 2020-03-10 21:59:57
category:
- 左神算法
- 递归和动态规划
---

# 递归和动态规划

## 递归的实质和Master公式

### 递归的实质

递归的实质就是系统在帮我们压栈。首先让我们来看一个递归求阶乘的例子：

```java
int fun(int n){
	if(n==0){
    return 1;
	}
  return n*fun(n-1);
}
```

课上老师一般告诉我们递归就是函数自己调用自己。但这听起来很玄学。事实上，在函数执行过程中如果调用了其他函数，那么当前函数的执行状态（执行到了第几行，有几个变量，各个变量的值是什么等等）会被保存起来压进栈（先进后出的存储结构，一般称为函数调用栈）中，转而执行子过程（调用的其他函数，当然也可以是当前函数）。若子过程中又调用了函数，那么调用前子过程的执行状态也会被保存起来压进栈中，转而执行子过程的子过程……以此类推，直到有一个子过程没有调用函数、能顺序执行完毕时会从函数调用栈依次弹出栈顶被保存起来的未执行完的函数（恢复现场）继续执行，直到函数调用栈中的函数都执行完毕，整个递归过程结束。

例如，在`main`中执行`fun(3)`，其递归过程如下：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/factorial.png) 

很多时候我们分析递归时都喜欢在心中模拟代码执行，去追溯、还原整个递归调用过程。但事实上没有必要这样做，因为每相邻的两个步骤执行的逻辑都是相同的，因此我们只需要分析第一步到第二步是如何执行的以及递归的终点在哪里就可以了。

> 一切的递归算法都可以转化为非递归，因为我们完全可以自己压栈。只是说递归的写法更加简洁。在实际工程中，递归的使用是极少的，因为递归创建子函数的开销很大并且存在安全问题（stack overflow）。

### Master公式

包含递归的算法的时间复杂度有时很难通过算法表面分析出来， 比如 **归并排序**。这时Master公式就粉墨登场了，当某递归算法的时间复杂度符合`T(n)=aT(n/b)+O(n^d)`形式时可以直接求出该算法的直接复杂度：

- 当（以b为底a的对数）`log(b,a) > d`时，时间复杂度为`O(n^log(b,a))`
- 当`log(b,a) = d`时，时间复杂度为`O(n^d * logn)`
- 当`log(b,a) < d`时，时间复杂度为`O(n^d)`

> 其中，`n`为样本规模，`n/b`为子过程的样本规模（暗含子过程的样本规模必须相同，且相加之和等于总样本规模），`a`为子过程的执行次数，`O(n^d)`为除子过程之后的操作的时间复杂度。
>
> 以归并排序为例，函数本体先对左右两半部分进行归并排序，样本规模被分为了左右各`n/2`即`b=2`，左右各归并排序了一次，子过程执行次数为`2`即`a=2`，并入操作的时间复杂度为`O(n+n)=O(n)`即`d=1`，因此`T(n)=2T(n/2)+O(n)`，符合`log(b,a)=d=1`，因此**归并排序的时间复杂度**为`O(n^1*logn)=O(nlogn)`

**暴力递归**：

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

**动态规划**：

1. 从暴力递归中来
2. 将每一个子问题的解记录下来，**避免重复计算**
3. 把暴力递归的过程，抽象成了状态表达
4. 并且存在化简状态表达，使其更加简洁的可能

**P和NP**

P指的是我明确地知道怎么算，计算的流程很清楚；而NP问题指的是我不知道怎么算，但我知道怎么尝试（暴力递归）。

## 暴力递归

### n!问题

我们知道`n!`的定义，可以根据定义直接求解：

```java
int getFactorial_1(int n){
  int res=1;
  for(int i = 1 ; i <= n ; n++){
    res*=i;
  }
  return res;
}
```

但我们可以这样想，如果知道`(n-1)!`，那通过`(n-1)! * n`不就得出`n!`了吗？于是我们就有了如下的尝试：

```java
int getFactorial_2(int n){
  if(n=1)
    return 1;
  return getFactorial_2(n-1) * n;
}
```

n!`的状态依赖`(n-1)!`，`(n-1)!`依赖`(n-2)!`，就这样依赖下去，直到`n=1`这个突破口，然后回溯，你会发现整个过程就回到了`1 * 2 * 3 * …… * (n-1) * n`的计算过程。

### 汉诺塔问题

该问题最基础的一个模型就是，一个竹竿上放了2个圆盘，需要先将最上面的那个移到辅助竹竿上，然后将最底下的圆盘移到目标竹竿，最后把辅助竹竿上的圆盘移回目标竹竿。

```java
public class Hanoi {

    public static void process(String source,String target,String auxiliary,int n){
        if (n == 1) {
            System.out.println("move 1 disk from " + source + " to " + target);
            return;
        }
      	//尝试把前n-1个圆盘暂时放到辅助竹竿->子问题
        process(source, auxiliary, target, n - 1);
      	//将底下最大的圆盘移到目标竹竿
        System.out.println("move 1 disk from "+source+" to "+target);
      	//再尝试将辅助竹竿上的圆盘移回到目标竹竿->子问题
        process(auxiliary,target,source,n-1);
    }

    public static void main(String[] args) {
        process("Left", "Right", "Help", 3);
    }
}
```

根据Master公式计算得`T(N) = T(N-1)+1+T(N-1)`，时间复杂度为`O(2^N)`

### 打印一个字符串的所有子序列

> 字符串的子序列和子串有着不同的定义。子串指串中相邻的任意个字符组成的串，而子序列可以是串中任意个不同字符组成的串。

尝试：开始时，令子序列为空串，扔给递归方法。首先来到字符串的第一个字符上，这时会有两个决策：将这个字符加到子序列和不加到子序列。这两个决策会产生两个不同的子序列，将这两个子序列作为这一级收集的信息扔给子过程，子过程来到字符串的第二个字符上，对上级传来的子序列又有两个决策，……这样最终能将所有子序列组合穷举出来：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/allSubSequences.png)

```java
/**
	 * 打印字符串的所有子序列-递归方式
	 * @param str	目标字符串
	 * @param index	当前子过程来到了哪个字符的决策上（要还是不要）
	 * @param res	上级扔给本级的子序列
	 */
public static void printAllSubSequences(String str,int index,String res) {
  //base case ： 当本级子过程来到的位置到达串末尾，则直接打印
  if(index == str.length()) {
    System.out.println(res);
    return;
  }
  //决策是否要index位置上的字符
  printAllSubSequences(str, index+1, res+str.charAt(index));
  printAllSubSequences(str, index+1, res);
}

public static void main(String[] args) {
  printAllSubSequences("abc", 0, "");
}
```

### 打印一个字符串的所有全排列结果

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/allPermutations.png)

```java
/**
	 * 本级任务：将index之后（包括index）位置上的字符和index上的字符交换，将产生的所有结果扔给下一级
	 * @param str
	 * @param index	
	 */
public static void printAllPermutations(char[] chs,int index) {
  //base case
  if(index == chs.length-1) {
    System.out.println(chs);
    return;
  }
  for (int j = index; j < chs.length; j++) {
    swap(chs,index,j);
    printAllPermutations(chs, index+1);
  }
}

public static void swap(char[] chs,int i,int j) {
  char temp = chs[i];
  chs[i] = chs[j];
  chs[j] = temp;
}

public static void main(String[] args) {
  printAllPermutations("abc".toCharArray(), 0);
}
```

### 母牛生牛问题

母牛每年生一只母牛，新出生的母牛成长三年后也能每年生一只母牛，假设不会死。求N年后，母牛的数量。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/cow_problem.png) 

那么求第n年母牛的数量，按照此公式顺序计算即可，但这是`O(N)`的时间复杂度，存在`O(logN)`的算法（放到进阶篇中讨论）。

## 暴力递归改为动态规划

为什么要改动态规划？有什么意义？

动态规划由暴力递归而来，是对暴力递归中的重复计算的一个优化，策略是空间换时间。

### 最小路径和

给你一个二维数组，二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向右或者向下。沿途经过的数字要累加起来。返回最小的路径和。

```java
/**
	 * 从矩阵matrix的(i,j)位置走到右下角元素，返回最小沿途元素和。每个位置只能向右或向下
	 * 
	 * @param matrix
	 * @param i
	 * @param j
	 * @return 最小路径和
	 */
public static int minPathSum(int matrix[][], int i, int j) {
  // 如果(i,j)就是右下角的元素
  if (i == matrix.length - 1 && j == matrix[0].length - 1) {
    return matrix[i][j];
  }
  // 如果(i,j)在右边界上，只能向下走
  if (j == matrix[0].length - 1) {
    return matrix[i][j] + minPathSum(matrix, i + 1, j);
  }
  // 如果(i,j)在下边界上，只能向右走
  if (i == matrix.length - 1) {
    return matrix[i][j] + minPathSum(matrix, i, j + 1);
  }
  // 不是上述三种情况，那么(i,j)就有向下和向右两种决策，取决策结果最小的那个
  int left = minPathSum(matrix, i, j + 1);
  int down = minPathSum(matrix, i + 1, j);
  return matrix[i][j] + Math.min(left,down );
}

public static void main(String[] args) {
  int matrix[][] = { 
    { 9, 1, 0, 1 }, 
    { 4, 8, 1, 0 }, 
    { 1, 4, 2, 3 } 
  };
  System.out.println(minPathSum(matrix, 0, 0)); //14
}
```

#### 根据尝试版本改动态规划

上述暴力递归的缺陷在于有些子过程是重复的。比如`minPathSum(matrix,0,1)`和`minPathSum(matrix,1,0)`都会依赖子过程`minPathSum(matrix,1,1)`的状态（执行结果），那么在计算`minPathSum(matrix,0,0)`时势必会导致`minPathSum(matrix,1,1)`的重复计算。那我们能否通过对子过程计算结果进行缓存，在再次需要时直接使用，从而实现对整个过程的一个优化呢。

由暴力递归改动态规划的核心就是将每个子过程的计算结果进行一个记录，从而达到空间换时间的目的。那么`minPath(int matrix[][],int i,int j)`中变量`i`和`j`的不同取值将导致`i*j`种结果，我们将这些结果保存在一个`i*j`的表中，不就达到动态规划的目的了吗？

观察上述代码可知，右下角、右边界、下边界这些位置上的元素是不需要尝试的（只有一种走法，不存在决策问题），因此我们可以直接将这些位置上的结果先算出来：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mini_path.png) 

而其它位置上的元素的走法则依赖右方相邻位置（i，j+1）走到右下角的最小路径和和下方相邻位置（i+1，j）走到右下角的最小路径和的大小比较，基于此来做一个向右走还是向左走的决策。但由于右边界、下边界位置上的结果我们已经计算出来了，因此对于其它位置上的结果也就不难确定了：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mini_path1.png) 

我们从`base case`开始，倒着推出了所有子过程的计算结果，并且没有重复计算。最后`minPathSum(matrix,0,0)`也迎刃而解了。

> 这就是动态规划，它不是凭空想出来的。首先我们尝试着解决这个问题，写出了暴力递归。再由暴力递归中的变量的变化范围建立一张对应的结果记录表，以`base case`作为突破口确定能够直接确定的结果，最后解决普遍情况对应的结果。

### 一个数是否是数组中任意个数的和

给你一个数组arr，和一个整数aim。如果可以任意选择arr中的数字，能不能累加得到aim，返回true或者false。

> 此题的思路跟求解一个字符串的所有子序列的思路一致，穷举出数组中所有任意个数相加的不同结果。

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/is_sum.png) 

#### 暴力递归版本

```java
/**
     * 选择任意个arr中的元素相加是否能得到aim
     *
     * @param arr
     * @param aim
     * @param sum 上级扔给我的结果
     * @param i   决策来到了下标为i的元素上
     * @return
     */
public static boolean isSum(int arr[], int aim, int sum,int i) {
  //决策完毕
  if (i == arr.length) {
    return sum == aim;
  }
  //决策来到了arr[i]：加上arr[i]或不加上。将结果扔给下一级
  return isSum(arr, aim, sum + arr[i], i + 1) || isSum(arr, aim, sum, i + 1);
}

public static void main(String[] args) {
  int arr[] = {1, 2, 3};
  System.out.println(isSum(arr, 5, 0, 0));
  System.out.println(isSum(arr, 6, 0, 0));
  System.out.println(isSum(arr, 7, 0, 0));
}
```

#### 暴力递归改动态规划（高度套路）

1. 首先看递归函数的参数，找出变量。这里`arr`和`aim`是固定不变的，可变的只有`sum`和`i`。
2. 对应变量的变化范围建立一张表保存不同子过程的结果，这里`i`的变化范围是`0~arr.length-1`即`0~2`，而`sum`的变化范围是`0~数组元素总和`，即`0~6`。因此需要建一张`3*7`的表。
3. 从`base case`入手，计算可直接计算的子过程，以`isSum(5,0,0)`的计算为例，其子过程中“是否+3”的决策之后的结果是可以确定的：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/is_sum1.png) 

4. 按照递归函数中`base case`下的尝试过程，推出其它子过程的计算结果，这里以`i=1,sum=1`的推导为例：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/is_sum2.png) 

### 哪些暴力递归能改为动态规划

看过上述例题之后你会发现只要你能够写出尝试版本，那么改动态规划是高度套路的。但是不是所有的暴力递归都能够改动态规划呢？不是的，比如汉诺塔问题和N皇后问题，他们的每一步递归都是必须的，没有多余。这就涉及到了递归的有后效性和无后效性。

#### 有后效性和无后效性

无后效性是指对于递归中的某个子过程，其上级的决策对该级的后续决策没有任何影响。比如最小路径和问题中以下面的矩阵为例：

![](https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mini_path2.png) 

对于（1，1）位置上的8，无论是通过`9->1->8`还是`9->4->8`来到这个`8`上的，这个`8`到右下角的最小路径和的计算过程不会改变。这就是无后效性。

> 只有无后效性的暴力递归才能改动态规划。
