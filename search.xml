<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何从0到1设计一个类Dubbo的RPC框架</title>
    <url>/2020/03/24/%E5%A6%82%E4%BD%95%E4%BB%8E0%E5%88%B01%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BBDubbo%E7%9A%84RPC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="RPC和RPC框架"><a href="#RPC和RPC框架" class="headerlink" title="RPC和RPC框架"></a><strong>RPC和RPC框架</strong></h2><p><strong>1.RPC(Remote Procedure Call)</strong></p><p>即远程过程调用, 主要解决远程通信间的问题，不需要了解底层网络的通信机制。</p><p><strong>2.RPC框架</strong></p><p>RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式、以及通信细节。</p><p>实际使用中，并不需要关心底层通信细节和调用过程，让业务端专注于业务代码的实现。</p><a id="more"></a>




<p>国内大家熟知的PRC框架，阿里的HSF和<strong>Dubbo(开源)</strong></p>
<h2 id="Dubbo的发展由来"><a href="#Dubbo的发展由来" class="headerlink" title="Dubbo的发展由来"></a><strong>Dubbo的发展由来</strong></h2><p><strong>1. 业务规模小</strong></p>
<p>比如早期一个应用Java War包，将所有功能都打包，部署在一个单机服务器，调用接口也比较方便，不涉及到任何分布式场景。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/rpc.png" alt></p>
<p><strong>2.业务规模变大</strong></p>
<p>随着业务的快速发展，业务越来越多、子系统也越来越多时。比如：淘宝的交易系统、商品系统、用户系统、评价系统…上百个系统的出现。</p>
<p>系统变得越来越复杂，业务代码依然耦合在一起。</p>
<p>比如最早期的淘宝denali工程，包含所有业务系统的代码，就仅打包部署都需要很长的时间。</p>
<p>并且，随着每个业务线的快速发展，业务代码耦合在一起，上线后出现问题急需要回滚代码，拉分支、大量的代码merge工作，这个过程极其痛苦。</p>
<p>这个时候，你会发现技术已经成了业务的瓶颈，急需把业务单独抽离出来，各自单独部署。</p>
<p><strong>3.Dubbo和HSF的出现</strong></p>
<p>应用系统一旦涉及到拆分部署，问题就来了，急需一种高效的应用程序间的通讯手段来完成这种需求，这就会涉及到<strong>分布式远程调用</strong>。</p>
<p>于是，淘宝就把denali按照业务为单位拆分成了类似这样的系统：UM(UserManger)、SM(ShopManager)..等等几十个工程代码。</p>
<p>再按照业务为单位，把所有调用相关的接口以业务为单元进行拆分：UIC(用户中心服务)、SIC(店铺中心服务)…等等以业务为单位集群部署，按照业务提供服务。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/rpc1.png" alt></p>
<p>所以，RPC的框架来了，阿里内部使用HSF，以及开源的RPC 框架：Dubbo。</p>
<h2 id="如何设计一个RPC框架"><a href="#如何设计一个RPC框架" class="headerlink" title="如何设计一个RPC框架"></a>如何设计一个RPC框架</h2><p>前面mikechen提到了RPC的核心目标：主要是解决分布式系统中服务之间的调用问题。</p>
<p>其实，走到这一步涉及的知识体系非常的多：要求对通信、远程调用、消息机制等有深入的理解和掌握，要求的都是从理论、硬件级、操作系统级以及所采用的语言的实现都有清楚的理解。</p>
<p><strong>1.RPC框架三个核心角色</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/rpc2.png" alt></p>
<p><strong>1)服务提供者（Server）</strong></p>
<p>对外提供后台服务，将自己的服务信息，注册到注册中心。</p>
<p><strong>2)注册中心（Registry）</strong></p>
<p>用于服务端注册远程服务以及客户端发现服务。</p>
<p>目前主要的注册中心可以借由 zookeeper，eureka，consul，etcd 等开源框架实现。</p>
<p>比如：阿里的Dubbo就是采用zookeeper实现注册中心。</p>
<p><strong>3)服务消费者（Client）</strong></p>
<p>从注册中心获取远程服务的注册信息，然后进行远程过程调用。</p>
<p><strong>2.RPC远程调用过程</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/rpc3.png" alt></p>
<p>1）服务调用方（client）调用以本地调用方式调用服务；</p>
<p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；在Java里就是序列化的过程</p>
<p>3）client stub找到服务地址，并将消息通过网络发送到服务端；</p>
<p>4）server stub收到消息后进行解码,在Java里就是反序列化的过程；</p>
<p>5）server stub根据解码结果调用本地的服务；</p>
<p>6）本地服务执行处理逻辑；</p>
<p>7）本地服务将结果返回给server stub；</p>
<p>8）server stub将返回结果打包成消息，Java里的序列化；</p>
<p>9）server stub将打包后的消息通过网络并发送至消费方</p>
<p>10）client stub接收到消息，并进行解码, Java里的反序列化；</p>
<p>11）服务调用方（client）得到最终结果。</p>
<p><strong>RPC框架的目标就是要2~10这些步骤都封装起来。</strong></p>
<h2 id="RPC框架涉及技术"><a href="#RPC框架涉及技术" class="headerlink" title="RPC框架涉及技术"></a>RPC框架涉及技术</h2><p><strong>1.建立通信</strong></p>
<p>首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。</p>
<p><strong>2.服务寻址</strong></p>
<p><strong>1）服务注册</strong></p>
<p>首先需要把服务注册到服务中心。其实就是在注册中心进行一个登记，注册中心存储了该服务的IP、端口、调用方式(协议、序列化方式)等。</p>
<p>比如：在zookeeper中，进行服务注册，实际上就是在zookeeper中创建了一个znode节点，该节点存储了上面所说的服务信息。</p>
<p><strong>2）服务发现</strong></p>
<p>服务消费者在第一次调用服务时，会通过注册中心找到相应的服务的IP地址列表，并缓存到本地，以供后续使用。当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从IP列表中取一个服务提供者的服务器调用服务。</p>
<p><strong>3）注册服务</strong></p>
<p>可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以zookeeper来实现注册服务等等。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/rpc4.png" alt></p>
<p><strong>3.网络传输</strong></p>
<p>数据传输采用什么协议，数据该如何序列化和反序列化</p>
<p><strong>4.NIO通信</strong></p>
<p>当前很多RPC框架都直接基于netty这一IO通信框架，比如阿里巴巴的HSF、dubbo，Hadoop Avro，推荐使用Netty 作为底层通信框架。</p>
<p>5.<strong>服务调用</strong></p>
<p>比如：B机器进行本地调用（通过代理Proxy）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作。</p>
<p>总之，要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架，后续将剖析Dubbo，看看Dubbo是如何来解决。</p>
]]></content>
      <categories>
        <category>Rpc</category>
      </categories>
  </entry>
  <entry>
    <title>Java-线程进阶</title>
    <url>/2020/03/24/Java-%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><h3 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h3><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><a id="more"></a>

<h3 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p><strong>synchronized关键字最主要的三种使用方式：</strong></p>
<ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>
<li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p>
<p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="讲一下-synchronized-关键字的底层原理"><a href="#讲一下-synchronized-关键字的底层原理" class="headerlink" title="讲一下 synchronized 关键字的底层原理"></a>讲一下 synchronized 关键字的底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p>
<p><strong>① synchronized 同步语句块的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"synchronized 代码块"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/synchronized_basic.png" alt></p>
<p>从上面我们可以看出：</p>
<p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>② synchronized 修饰方法的的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/synchronized_basic1.png" alt></p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h3 id="说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗"><a href="#说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗" class="headerlink" title="说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗"></a>说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h3><h4 id="JDK1-6-之后的底层优化"><a href="#JDK1-6-之后的底层优化" class="headerlink" title="JDK1.6 之后的底层优化"></a>JDK1.6 之后的底层优化</h4><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/synchronized_all.png" alt></p>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p><strong>①偏向锁</strong></p>
<p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p>
<p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p>
<p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
<p><strong>② 轻量级锁</strong></p>
<p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong> 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p>
<p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p>
<p><strong>③ 自旋锁和自适应自旋</strong></p>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p>
<p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</p>
<p>百度百科对自旋锁的解释：</p>
<blockquote>
<p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p>
</blockquote>
<p>自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改</strong>。</p>
<p>另外,<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p>
<p><strong>④ 锁消除</strong></p>
<p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>
<p><strong>⑤ 锁粗化</strong></p>
<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p>
<h3 id="谈谈synchronized-和-ReenTrantLock-的对比"><a href="#谈谈synchronized-和-ReenTrantLock-的对比" class="headerlink" title="谈谈synchronized 和 ReenTrantLock 的对比"></a>谈谈synchronized 和 ReenTrantLock 的对比</h3><p><strong>① 两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ul>
<p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p>
<p><strong>④ 性能已不是选择标准</strong></p>
<p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="讲一下Java内存模型"><a href="#讲一下Java内存模型" class="headerlink" title="讲一下Java内存模型"></a>讲一下Java内存模型</h3><p>在 JDK1.2 之前，Java的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_jms.png" alt></p>
<p>要解决这个问题，就需要把变量声明为<strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</p>
<p>说白了， <strong>volatile</strong> 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_jms1.png" alt></p>
<h3 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><p>synchronized关键字和volatile关键字比较</p>
<ul>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>
<li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li>
<li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li>
<li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子：</p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。</p>
<h3 id="ThreadLocal示例"><a href="#ThreadLocal示例" class="headerlink" title="ThreadLocal示例"></a>ThreadLocal示例</h3><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread Name= <span class="number">0</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">0</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">1</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">2</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">1</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">3</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">2</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">4</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">3</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">4</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">5</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">5</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">6</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">6</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">7</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">7</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">8</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">9</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">8</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">9</span> formatter = yy-M-d ah:mm</span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法<code>withInitial()</code>，将Supplier功能接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>从 <code>Thread</code>类源代码入手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key ，Object 对象为 value的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/threadLocal1.png" alt></p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/threadLocal.png" alt></p>
<h3 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">      <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">      Object value;</span><br><span class="line"></span><br><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">          <span class="keyword">super</span>(k);</span><br><span class="line">          value = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><blockquote>
<p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="实现Runnable接口和Callable接口的区别"><a href="#实现Runnable接口和Callable接口的区别" class="headerlink" title="实现Runnable接口和Callable接口的区别"></a>实现Runnable接口和Callable接口的区别</h3><p><code>Runnable</code>自Java 1.0以来一直存在，但<code>Callable</code>仅在Java 1.5中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是<strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Callable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h3><ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<p>我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看<code>execute()</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>
</ul>
</blockquote>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/threadPoolExecutor.png" alt></p>
<p><strong>方式二：通过Executor 框架的工具类Executors来实现</strong> 我们可以创建三种类型的ThreadPoolExecutor：</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/threadPoolExecutor1.png" alt></p>
<h3 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p>
<h4 id="ThreadPoolExecutor构造函数重要参数分析"><a href="#ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="ThreadPoolExecutor构造函数重要参数分析"></a><code>ThreadPoolExecutor</code>构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<h4 id="ThreadPoolExecutor-饱和策略"><a href="#ThreadPoolExecutor-饱和策略" class="headerlink" title="ThreadPoolExecutor 饱和策略"></a><code>ThreadPoolExecutor</code> 饱和策略</h4><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>
<h3 id="一个简单的线程池Demo-Runnable-ThreadPoolExecutor"><a href="#一个简单的线程池Demo-Runnable-ThreadPoolExecutor" class="headerlink" title="一个简单的线程池Demo:Runnable+ThreadPoolExecutor"></a>一个简单的线程池Demo:<code>Runnable</code>+<code>ThreadPoolExecutor</code></h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>
<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">MyRunnable</span>.</span></span>java</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * @author shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">class</span> MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">MyRunnable(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        this.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> <span class="constructor">Date()</span>);</span><br><span class="line">        process<span class="constructor">Command()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> <span class="constructor">Date()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void process<span class="constructor">Command()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="keyword">to</span><span class="constructor">String()</span> &#123;</span><br><span class="line">        return this.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutorDemo.java</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">""</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们上面的代码指定了：</p>
<ol>
<li><code>corePoolSize</code>: 核心线程数为 5。</li>
<li><code>maximumPoolSize</code> ：最大线程数 10</li>
<li><code>keepAliveTime</code> : 等待时间为 1L。</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>
<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>
</ol>
<p><strong>Output：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h3><p>承接 4.6 节，我们通过代码输出结果可以看出：<strong>线程池每次会同时执行 5 个任务，这 5 个任务执行完之后，剩余的 5 个任务才会被执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p>
<p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p>
<p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong>在 4.6 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">        <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">        <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">        <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/threadPoolExecutor2.png" alt></p>
<p>现在，让我们在回到 4.6 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？</p>
<p>没搞懂的话，也没关系，可以看看我的分析：</p>
<blockquote>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务之行完成后，才会之行剩下的 5 个任务。</p>
</blockquote>
<h2 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h2><h3 id="介绍一下Atomic-原子类"><a href="#介绍一下Atomic-原子类" class="headerlink" title="介绍一下Atomic 原子类"></a>介绍一下Atomic 原子类</h3><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/JUC_atomic.png" alt></p>
<h3 id="JUC-包中的原子类是哪4类"><a href="#JUC-包中的原子类是哪4类" class="headerlink" title="JUC 包中的原子类是哪4类?"></a>JUC 包中的原子类是哪4类?</h3><p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整形原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新引用类型里的字段原子类</li>
<li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<h3 id="讲讲-AtomicInteger-的使用"><a href="#讲讲-AtomicInteger-的使用" class="headerlink" title="讲讲 AtomicInteger 的使用"></a>讲讲 AtomicInteger 的使用</h3><p><strong>AtomicInteger 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>

<p><strong>AtomicInteger 类的使用示例</strong></p>
<p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">      <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="能不能给我简单介绍一下-AtomicInteger-类的原理"><a href="#能不能给我简单介绍一下-AtomicInteger-类的原理" class="headerlink" title="能不能给我简单介绍一下 AtomicInteger 类的原理"></a>能不能给我简单介绍一下 AtomicInteger 类的原理</h3><p>AtomicInteger 线程安全原理简单分析</p>
<p>AtomicInteger 类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<p>关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：<a href="https://mp.weixin.qq.com/s/joa-yOiTrYF67bElj8xqvg" target="_blank" rel="noopener">JUC 中的 Atomic 原子类总结</a></p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h3><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="AQS-原理分析"><a href="#AQS-原理分析" class="headerlink" title="AQS 原理分析"></a>AQS 原理分析</h3><p>AQS 原理这部分参考了部分博客，在5.2节末尾放了链接。</p>
<blockquote>
<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>
</blockquote>
<p>下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>
<h4 id="AQS-原理概览"><a href="#AQS-原理概览" class="headerlink" title="AQS 原理概览"></a>AQS 原理概览</h4><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>看个AQS(AbstractQueuedSynchronizer)原理图：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/AQS.png" alt></p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><p><strong>AQS定义两种资源共享方式</strong></p>
<ul>
<li><p>Exclusive</p>
<p>  （独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><p><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>
</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<h4 id="AQS底层使用了模板方法模式"><a href="#AQS底层使用了模板方法模式" class="headerlink" title="AQS底层使用了模板方法模式"></a>AQS底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h3 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h3><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>ThreadAdvance</category>
      </categories>
  </entry>
  <entry>
    <title>Java-线程基本</title>
    <url>/2020/03/24/Java-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h3><a id="more"></a>

<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>] Attach Listener <span class="comment">//添加事件</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理给 JVM 信号的线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">//调用对象 finalize 方法的线程</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">//清除 reference 线程</span></span><br><span class="line">[<span class="number">1</span>] main <span class="comment">//main 线程,程序入口</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<h2 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h2><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p>
<h3 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/JVM_mem.png" alt></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)\</strong>资源，但是每个线程有自己的*<em>程序计数器*</em>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p>
<p>下面是该知识点的扩展内容！</p>
<p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h2 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h2><ul>
<li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h2 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</p>
<h2 id="6-说说线程的生命周期和状态"><a href="#6-说说线程的生命周期和状态" class="headerlink" title="6. 说说线程的生命周期和状态?"></a>6. 说说线程的生命周期和状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/Java_thread.png" alt></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/Java_thread1.png" alt></p>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/Java_thread2.png" alt></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/dead_lock.png" alt></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>
<p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h3><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏互斥条件</strong></p>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<p><strong>破坏请求与保持条件</strong></p>
<p>一次性申请所有的资源。</p>
<p><strong>破坏不剥夺条件</strong></p>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">               <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">"线程 2"</span>).start();</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul>
<li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Thread</category>
      </categories>
  </entry>
  <entry>
    <title>如何从0到1设计一个MQ消息队列</title>
    <url>/2020/03/24/%E5%A6%82%E4%BD%95%E4%BB%8E0%E5%88%B01%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="消息队列整体设计思路"><a href="#消息队列整体设计思路" class="headerlink" title="消息队列整体设计思路"></a>消息队列整体设计思路</h2><p>主要是设计一个整体的消息被消费的数据流。</p><p>这里会涉及到：消息生产Producer、Broker(消息服务端)、消息消费者Consumer。</p><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/mq.png" alt></p><ol>
<li><p>Producer(消息生产者)：发送消息到Broker。</p>
</li>
<li><p>Broker(服务端)：Broker这个概念主要来自于Apache的ActiveMQ，特指消息队列的服务端。</p>
</li>
</ol><a id="more"></a>



<p>主要功能就是：把消息从发送端传送到接收端，这里会涉及到消息的存储、消息通讯机制等。</p>
<ol start="3">
<li>Consumer(消息消费者)：从消息队列接收消息，consumer回复消费确认。</li>
</ol>
<h2 id="Broker-消息队列服务端-设计重点"><a href="#Broker-消息队列服务端-设计重点" class="headerlink" title="Broker(消息队列服务端)设计重点"></a>Broker(消息队列服务端)设计重点</h2><p>1）消息的转储：在更合适的时间点投递，或者通过一系列手段辅助消息最终能送达消费机。</p>
<p>2）规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求。</p>
<p>3）其实简单理解就是一个消息转发器，把一次RPC做成两次RPC，发送者把消息投递到broker，broker再将消息转发一手到接收端。</p>
<p>总结起来就是两次RPC加一次转储，如果要做消费确认，则是三次RPC。</p>
<p><strong>为了实现上述消息队列的基础功能：</strong></p>
<p>1）消息的传输</p>
<p>2）存储</p>
<p>3）消费</p>
<p><strong>就需要涉及到如下三个方面的设计：</strong></p>
<p>1）通信协议</p>
<p>2）存储选择</p>
<p>3）消费关系维护 </p>
<h2 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h2><p>消息Message:既是信息的载体，消息发送者需要知道如何构造消息，消息接收者需要知道如何解析消息，它们需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。</p>
<p>传统的通信协议标准有XMPP和AMQP协议等，现在更多的消息队列从性能的角度出发使用自己设计实现的通信协议。 </p>
<p><strong>1.JMS</strong></p>
<p>JMS（Java MessageService）实际上是指JMS API。JMS是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括创建消息、发送消息、接收消息等。</p>
<p>JMS通常包含如下一些角色：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/mq2.png" alt></p>
<p>JMS提供了两种消息模型：</p>
<p>1）点对点</p>
<p>2）以及publish-subscribe（发布订阅）模型。</p>
<p>当采用点对点模型时，消息将发送到一个队列，该队列的消息只能被一个消费者消费。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/mq3.png" alt></p>
<p>而采用发布订阅模型时，消息可以被多个消费者消费。</p>
<p>在发布订阅模型中，生产者和消费者完全独立，不需要感知对方的存在。</p>
<p><strong>2.AMQP</strong></p>
<p>AMQP是 Advanced Message Queuing Protocol，即高级消息队列协议。</p>
<p>AMQP不是一个具体的消息队列实现，而 是一个标准化的消息中间件协议。</p>
<p>目标是让不同语言，不同系统的应用互相通信，并提供一个简单统一的模型和编程接口。 目前主流的ActiveMQ和RabbitMQ都支持AMQP协议。</p>
<p>AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>
<p><strong>JMS和AMQP比较:</strong></p>
<p>JMS: 只允许基于JAVA实现的消息平台的之间进行通信</p>
<p>AMQP: AMQP允许多种技术同时进行协议通信</p>
<p><strong>3.Kafka的通信协议</strong></p>
<p>Kafka的Producer、Broker和Consumer之间采用的是一套自行设计的基于TCP层的协议。Kafka的这套协议完全是为了Kafka自身的业务需求而定制的。</p>
<h2 id="存储选型"><a href="#存储选型" class="headerlink" title="存储选型"></a>存储选型</h2><p>对于分布式系统，存储的选择有以下几种</p>
<p>1.内存</p>
<p>2.本地文件系统</p>
<p>3.分布式文件系统</p>
<p>4.nosql</p>
<p>5.DB</p>
<p>从速度上内存显然是最快的，对于允许消息丢失，消息堆积能力要求不高的场景(例如日志)，内存会是比较好的选择。</p>
<p>DB则是最简单的实现可靠存储的方案，很适合用在可靠性要求很高，最终一致性的场景(例如交易消息)，对于不需要100%保证数据完整性的场景，要求性能和消息堆积的场景，hbase也是一个很好的选择。</p>
<p>理论上，从速度来看，文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库，而可靠性却截然相反。</p>
<p>还是要从支持的业务场景出发作出最合理的选择，如果你们的消息队列是用来支持支付/交易等对可靠性要求非常高，但对性能和量的要求没有这么高，而且没有时间精力专门做文件存储系统的研究，DB是最好的选择。</p>
<p>对于不需要100%保证数据完整性的场景，要求性能和消息堆积的场景，hbase也是一个很好的选择，典型的比如 kafka的消息落地可以使用hadoop。 </p>
<h2 id="消费关系处理"><a href="#消费关系处理" class="headerlink" title="消费关系处理"></a>消费关系处理</h2><p>现在我们的消息队列初步具备了转储消息的能力。</p>
<p>下面一个重要的事情就是解析发送接收关系，进行正确的消息投递了。</p>
<p>市面上的消息队列定义了一堆让人晕头转向的名词，如JMS 规范中的Topic/Queue，Kafka里面的Topic/Partition/ConsumerGroup，RabbitMQ里面的Exchange等等。</p>
<p>抛开现象看本质，无外乎是单播与广播的区别。</p>
<p>所谓单播，就是点到点；而广播，是一点对多点。</p>
<p>为了实现广播功能，我们必须要维护消费关系，通常消息队列本身不维护消费订阅关系，可以利用zookeeper等成熟的系统维护消费关系，在消费关系发生变化时下发通知。</p>
<h2 id="消息队列需要支持高级特性"><a href="#消息队列需要支持高级特性" class="headerlink" title="消息队列需要支持高级特性"></a>消息队列需要支持高级特性</h2><ul>
<li>消息的顺序</li>
<li>投递可靠性保证</li>
<li>消息持久化</li>
<li>支持不同消息模型</li>
<li>多实例集群功能</li>
<li>事务特性等</li>
</ul>
<p>除了上述的消息队列基本功能以外，消息队列在某些特殊的场景还需要支持事务，消息重试等功能。</p>
]]></content>
      <categories>
        <category>Mq</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-Reactor模式</title>
    <url>/2020/03/24/Netty-Reactor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>在学习Reactor模式之前，我们需要对“I/O的四种模型”以及“什么是I/O多路复用”进行简单的介绍，因为Reactor是一个使用了同步非阻塞的I/O多路复用机制的模式。</p>
</blockquote><h3 id="I-O的四种模型"><a href="#I-O的四种模型" class="headerlink" title="I/O的四种模型"></a>I/O的四种模型</h3><p>I/0 操作 主要分成两部分<br>① 数据准备，将数据加载到内核缓存<br>② 将内核缓存中的数据加载到用户缓存</p><p><strong>Synchronous blocking I/O</strong></p><a id="more"></a>


<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io.png" alt></p>
<p><strong>Synchronous non-blocking I/0</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io1.png" alt></p>
<p><strong>Asynchronous blocking I/0</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io2.png" alt></p>
<p><strong>Asynchronous non-blocking I/0</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io3.png" alt></p>
<p>堵塞、非堵塞的区别是在于第一阶段，即数据准备阶段。无论是堵塞还是非堵塞，都是用应用主动找内核要数据，而read数据的过程是‘堵塞’的，直到数据读取完。<br> 同步、异步的区别在于第二阶段，若由请求者主动的去获取数据，则为同步操作，需要说明的是：read/write操作也是‘堵塞’的，直到数据读取完。<br> 若数据的read都由kernel内核完成了(在内核read数据的过程中，应用进程依旧可以执行其他的任务)，这就是异步操作。</p>
<p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。<br> NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。<br> NIO是一种同步非阻塞的I/O模型，也是I/O多路复用的基础。</p>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>I/O多路复用是指使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如使用线程池)。</p>
<p>一般情况下，I/O 复用机制需要事件分发器。 事件分发器的作用，将那些读写事件源分发给各读写事件的处理者。<br> 涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。本文主要介绍的就是 Reactor模式相关的知识。</p>
<h3 id="经典的I-O服务设计-————-BIO模式"><a href="#经典的I-O服务设计-————-BIO模式" class="headerlink" title="经典的I/O服务设计 ———— BIO模式"></a>经典的I/O服务设计 ———— BIO模式</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io4.png" alt></p>
<p>这就是经典的每连接对应一个线程的同步阻塞I/O模式。</p>
<ul>
<li>流程：<br> ① 服务器端的Server是一个线程，线程中执行一个死循环来阻塞的监听客户端的连接请求和通信。<br> ② 当客户端向服务器端发送一个连接请求后，服务器端的Server会接受客户端的请求，ServerSocket.accept()从阻塞中返回，得到一个与客户端连接相对于的Socket。<br> ③ 构建一个handler，将Socket传入该handler。创建一个线程并启动该线程，在线程中执行handler，这样与客户端的所有的通信以及数据处理都在该线程中执行。当该客户端和服务器端完成通信关闭连接后，线程就会被销毁。<br> ④ 然后Server继续执行accept()操作等待新的连接请求。</li>
<li>优点：<br> ① 使用简单，容易编程<br> ② 在多核系统下，能够充分利用了多核CPU的资源。即，当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</li>
<li>缺点：<br> 该模式的本质问题在于严重依赖线程，但线程Java虚拟机非常宝贵的资源。随着客户端并发访问量的急剧增加，线程数量的不断膨胀将服务器端的性能将急剧下降。<br> ① 线程生命周期的开销非常高。线程的创建与销毁并不是没有代价的。在Linux这样的操作系统中，线程本质上就是一个进程，创建和销毁都是重量级的系统函数。<br> ② 资源消耗。内存：大量空闲的线程会占用许多内存，给垃圾回收器带来压力。；CPU：如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更过的线程反而会降低性能。<br> ③ 稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受多个因素制约：a)JVM的启动参数、b)Threa的构造函数中请求的栈大小、c)底层操作系统对线程的限制 等。如果破坏了这些限制，那么很可能抛出OutOfMemoryError异常。<br> ④ 线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，不仅会带来许多无用的上下文切换，还可能导致执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统负载偏高、CPU sy(系统CPU)使用率特别高，导致系统几乎陷入不可用的状态。<br> ⑤ 容易造成锯齿状的系统负载。一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。<br> ⑥ 若是长连接的情况下并且客户端与服务器端交互并不频繁的，那么客户端和服务器端的连接会一直保留着，对应的线程也就一直存在在，但因为不频繁的通信，导致大量线程在大量时间内都处于空置状态。</li>
<li>适用场景：如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。</li>
</ul>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>Reactor模式(反应器模式)是一种处理一个或多个客户端并发交付服务请求的事件设计模式。当请求抵达后，服务处理程序使用I/O多路复用策略，然后同步地派发这些请求至相关的请求处理程序。</p>
<h4 id="Reactor结构"><a href="#Reactor结构" class="headerlink" title="Reactor结构"></a>Reactor结构</h4><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io5.png" alt></p>
<p>Reactor模式的角色构成(Reactor模式一共有5中角色构成)：</p>
<ul>
<li>Handle(句柄或描述符，在Windows下称为句柄，在Linux下称为描述符)：本质上表示一种资源(比如说文件描述符，或是针对网络编程中的socket描述符)，是由操作系统提供的；该资源用于表示一个个的事件，事件既可以来自于外部，也可以来自于内部；外部事件比如说客户端的连接请求，客户端发送过来的数据等；内部事件比如说操作系统产生的定时事件等。它本质上就是一个文件描述符，Handle是事件产生的发源地。</li>
<li>Synchronous Event Demultiplexer(同步事件分离器)：它本身是一个系统调用，用于等待事件的发生(事件可能是一个，也可能是多个)。调用方在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I/O多路复用机制，比如说select、poll、epoll等。在Java NIO领域中，同步事件分离器对应的组件就是Selector；对应的阻塞方法就是select方法。</li>
<li>Event Handler(事件处理器)：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。在Java NIO领域中并没有提供事件处理器机制让我们调用或去进行回调，是由我们自己编写代码完成的。Netty相比于Java NIO来说，在事件处理器这个角色上进行了一个升级，它为我们开发者提供了大量的回调方法，供我们在特定事件产生时实现相应的回调方法进行业务逻辑的处理，即，ChannelHandler。ChannelHandler中的方法对应的都是一个个事件的回调。</li>
<li>Concrete Event Handler(具体事件处理器)：是事件处理器的实现。它本身实现了事件处理器所提供的各种回调方法，从而实现了特定于业务的逻辑。它本质上就是我们所编写的一个个的处理器实现。</li>
<li>Initiation Dispatcher(初始分发器)：实际上就是Reactor角色。它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册、删除等设施。它本身是整个事件处理器的核心所在，Initiation Dispatcher会通过Synchronous Event Demultiplexer来等待事件的发生。一旦事件发生，Initiation Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。Netty中ChannelHandler里的一个个回调方法都是由bossGroup或workGroup中的某个EventLoop来调用的。</li>
</ul>
<h4 id="Reactor模式流程"><a href="#Reactor模式流程" class="headerlink" title="Reactor模式流程"></a>Reactor模式流程</h4><p>① 初始化Initiation Dispatcher，然后将若干个Concrete Event Handler注册到Initiation Dispatcher中。当应用向Initiation Dispatcher注册Concrete Event Handler时，会在注册的同时指定感兴趣的事件，即，应用会标识出该事件处理器希望Initiation Dispatcher在某些事件发生时向其发出通知，事件通过Handle来标识，而Concrete Event Handler又持有该Handle。这样，事件 ————&gt; Handle ————&gt; Concrete Event Handler 就关联起来了。<br> ② Initiation Dispatcher 会要求每个事件处理器向其传递内部的Handle。该Handle向操作系统标识了事件处理器。<br> ③ 当所有的Concrete Event Handler都注册完毕后，应用会调用handle_events方法来启动Initiation Dispatcher的事件循环。这是，Initiation Dispatcher会将每个注册的Concrete Event Handler的Handle合并起来，并使用Synchronous Event Demultiplexer(同步事件分离器)同步阻塞的等待事件的发生。比如说，TCP协议层会使用select同步事件分离器操作来等待客户端发送的数据到达连接的socket handler上。<br> 比如，在Java中通过Selector的select()方法来实现这个同步阻塞等待事件发生的操作。在Linux操作系统下，select()的实现中 a)会将已经注册到Initiation Dispatcher的事件调用epollCtl(epfd, opcode, fd, events)注册到linux系统中，这里fd表示Handle，events表示我们所感兴趣的Handle的事件；b)通过调用epollWait方法同步阻塞的等待已经注册的事件的发生。不同事件源上的事件可能同时发生，一旦有事件被触发了，epollWait方法就会返回；c)最后通过发生的事件找到相关联的SelectorKeyImpl对象，并设置其发生的事件为就绪状态，然后将SelectorKeyImpl放入selectedSet中。这样一来我们就可以通过Selector.selectedKeys()方法得到事件就绪的SelectorKeyImpl集合了。<br> ④ 当与某个事件源对应的Handle变为ready状态时(比如说，TCP socket变为等待读状态时)，Synchronous Event Demultiplexer就会通知Initiation Dispatcher。<br> ⑤ Initiation Dispatcher会触发事件处理器的回调方法，从而响应这个处于ready状态的Handle。当事件发生时，Initiation Dispatcher会将被事件源激活的Handle作为『key』来寻找并分发恰当的事件处理器回调方法。<br> ⑥ Initiation Dispatcher会回调事件处理器的handle_event(type)回调方法来执行特定于应用的功能(开发者自己所编写的功能)，从而相应这个事件。所发生的事件类型可以作为该方法参数并被该方法内部使用来执行额外的特定于服务的分离与分发。</p>
<h4 id="Reactor模式的实现方式"><a href="#Reactor模式的实现方式" class="headerlink" title="Reactor模式的实现方式"></a>Reactor模式的实现方式</h4><h5 id="单线程Reactor模式"><a href="#单线程Reactor模式" class="headerlink" title="单线程Reactor模式"></a>单线程Reactor模式</h5><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io6.png" alt></p>
<p>流程：<br> ① 服务器端的Reactor是一个线程对象，该线程会启动事件循环，并使用Selector来实现IO的多路复用。注册一个Acceptor事件处理器到Reactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样Reactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。<br> ② 客户端向服务器端发起一个连接请求，Reactor监听到了该ACCEPT事件的发生并将该ACCEPT事件派发给相应的Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的READ事件以及对应的READ事件处理器注册到Reactor中，这样一来Reactor就会监听该连接的READ事件了。或者当你需要向客户端发送数据时，就向Reactor注册该连接的WRITE事件和其处理器。<br> ③ 当Reactor监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过SocketChannel的read()方法读取数据，此时read()操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。<br> ④ 每当处理完所有就绪的感兴趣的I/O事件后，Reactor线程会再次执行select()阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</p>
<p>注意，Reactor的单线程模式的单线程主要是针对于I/O操作而言，也就是所以的I/O的accept()、read()、write()以及connect()操作都在一个线程上完成的。</p>
<p>但在目前的单线程Reactor模式中，不仅I/O操作在该Reactor线程上，连非I/O的业务操作也在该线程上进行处理了，这可能会大大延迟I/O请求的响应。所以我们应该将非I/O的业务逻辑操作从Reactor线程上卸载，以此来加速Reactor线程对I/O请求的响应。</p>
<h6 id="改进：使用工作者线程池"><a href="#改进：使用工作者线程池" class="headerlink" title="改进：使用工作者线程池"></a>改进：使用工作者线程池</h6><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io7.png" alt></p>
<p>与单线程Reactor模式不同的是，添加了一个工作者线程池，并将非I/O操作从Reactor线程中移出转交给工作者线程池来执行。这样能够提高Reactor线程的I/O响应，不至于因为一些耗时的业务逻辑而延迟对后面I/O请求的处理。</p>
<p>使用线程池的优势：<br> ① 通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程产生的巨大开销。<br> ② 另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。<br> ③ 通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态。同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p>
<p>注意，在上图的改进的版本中，所以的I/O操作依旧由一个Reactor来完成，包括I/O的accept()、read()、write()以及connect()操作。<br> 对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下：<br> ① 一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的读取和发送；<br> ② 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p>
<h5 id="多Reactor线程模式"><a href="#多Reactor线程模式" class="headerlink" title="多Reactor线程模式"></a>多Reactor线程模式</h5><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty_io8.png" alt></p>
<p>Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的事件循环逻辑。<br> mainReactor可以只有一个，但subReactor一般会有多个。mainReactor线程主要负责接收客户端的连接请求，然后将接收到的SocketChannel传递给subReactor，由subReactor来完成和客户端的通信。</p>
<p>流程：<br> ① 注册一个Acceptor事件处理器到mainReactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样mainReactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。启动mainReactor的事件循环。<br> ② 客户端向服务器端发起一个连接请求，mainReactor监听到了该ACCEPT事件并将该ACCEPT事件派发给Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将这个SocketChannel传递给subReactor线程池。<br> ③ subReactor线程池分配一个subReactor线程给这个SocketChannel，即，将SocketChannel关注的READ事件以及对应的READ事件处理器注册到subReactor线程中。当然你也注册WRITE事件以及WRITE事件处理器到subReactor线程中以完成I/O写操作。Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的循环逻辑。<br> ④ 当有I/O事件就绪时，相关的subReactor就将事件派发给响应的处理器处理。注意，这里subReactor线程只负责完成I/O的read()操作，在读取到数据后将业务逻辑的处理放入到线程池中完成，若完成业务逻辑后需要返回数据给客户端，则相关的I/O的write操作还是会被提交回subReactor线程来完成。</p>
<p>注意，所以的I/O操作(包括，I/O的accept()、read()、write()以及connect()操作)依旧还是在Reactor线程(mainReactor线程 或 subReactor线程)中完成的。Thread Pool(线程池)仅用来处理非I/O操作的逻辑。</p>
<p>多Reactor线程模式将“接受客户端的连接请求”和“与该客户端的通信”分在了两个Reactor线程来完成。mainReactor完成接收客户端连接请求的操作，它不负责与客户端的通信，而是将建立好的连接转交给subReactor线程来完成与客户端的通信，这样一来就不会因为read()数据量太大而导致后面的客户端连接请求得不到即时处理的情况。并且多Reactor线程模式在海量的客户端并发请求的情况下，还可以通过实现subReactor线程池来将海量的连接分发给多个subReactor线程，在多核的操作系统中这能大大提升应用的负载和吞吐量。</p>
<h3 id="Netty-与-Reactor模式"><a href="#Netty-与-Reactor模式" class="headerlink" title="Netty 与 Reactor模式"></a>Netty 与 Reactor模式</h3><p>Netty的线程模式就是一个实现了Reactor模式的经典模式。</p>
<ul>
<li>结构对应：<br> NioEventLoop ———— Initiation Dispatcher<br> Synchronous EventDemultiplexer ———— Selector<br> Evnet Handler ———— ChannelHandler<br> ConcreteEventHandler ———— 具体的ChannelHandler的实现</li>
<li>模式对应：<br> Netty服务端使用了“多Reactor线程模式”<br> mainReactor ———— bossGroup(NioEventLoopGroup) 中的某个NioEventLoop<br> subReactor ———— workerGroup(NioEventLoopGroup) 中的某个NioEventLoop<br> acceptor ———— ServerBootstrapAcceptor<br> ThreadPool ———— 用户自定义线程池</li>
<li>流程：<br> ① 当服务器程序启动时，会配置ChannelPipeline，ChannelPipeline中是一个ChannelHandler链，所有的事件发生时都会触发Channelhandler中的某个方法，这个事件会在ChannelPipeline中的ChannelHandler链里传播。然后，从bossGroup事件循环池中获取一个NioEventLoop来现实服务端程序绑定本地端口的操作，将对应的ServerSocketChannel注册到该NioEventLoop中的Selector上，并注册ACCEPT事件为ServerSocketChannel所感兴趣的事件。<br> ② NioEventLoop事件循环启动，此时开始监听客户端的连接请求。<br> ③ 当有客户端向服务器端发起连接请求时，NioEventLoop的事件循环监听到该ACCEPT事件，Netty底层会接收这个连接，通过accept()方法得到与这个客户端的连接(SocketChannel)，然后触发ChannelRead事件(即，ChannelHandler中的channelRead方法会得到回调)，该事件会在ChannelPipeline中的ChannelHandler链中执行、传播。<br> ④ ServerBootstrapAcceptor的readChannel方法会该SocketChannel(客户端的连接)注册到workerGroup(NioEventLoopGroup) 中的某个NioEventLoop的Selector上，并注册READ事件为SocketChannel所感兴趣的事件。启动SocketChannel所在NioEventLoop的事件循环，接下来就可以开始客户端和服务器端的通信了。</li>
</ul>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 分布式协调服务介绍</title>
    <url>/2020/03/19/Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Zookeeper是什么"><a href="#Zookeeper是什么" class="headerlink" title="Zookeeper是什么"></a>Zookeeper是什么</h2><p>Zookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p><p>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储， Zookeeper 作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而达到基于数据的集群管理。</p><a id="more"></a>

<p>简单的说，zookeeper=文件系统+通知机制。</p>
<h2 id="选择Zookeeper"><a href="#选择Zookeeper" class="headerlink" title="选择Zookeeper"></a>选择Zookeeper</h2><p>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、master选举、分布式锁和分布式队列等功能。</p>
<p>Zookeeper致力于提供一个高性能、高可用，具有严格的顺序访问控制能力的分布式协调服务；其主要的设计目标是简单的数据模型、可以构建集群、顺序访问、高性能，用于分布式协调。</p>
<p>Zookeeper可以保证如下<strong>分布式一致性特性</strong>：</p>
<ul>
<li>顺序一致性：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去</li>
<li>原子性：所有事务请求的处理结果在整个集群中所有的机器上的应用情况是一致的</li>
<li>单一视图：无论客户端连接的是哪个Zookeeper服务器，其看到的服务器数据模型都是一致的</li>
<li>可靠性：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更</li>
<li>实时性：在一定的时间内，客户端最终一定能够从服务端上读取到最新的数据状态</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/zkservice.png" alt></p>
<h2 id="Zookeeper-基本概念"><a href="#Zookeeper-基本概念" class="headerlink" title="Zookeeper 基本概念"></a>Zookeeper 基本概念</h2><ul>
<li>集群角色<ul>
<li>Leader：客户端提供读和写服务</li>
<li>Follower：提供读服务，所有写服务都需要转交给Leader角色，参与选举</li>
<li>Observer：提供读服务，不参与选举过程，一般是为了增强Zookeeper集群的读请求并发能力</li>
</ul>
</li>
<li>会话 (session)<ul>
<li>Zk的客户端与zk的服务端之间的连接</li>
<li>通过心跳检测保持客户端连接的存活</li>
<li>接收来自服务端的watch事件通知</li>
<li>可以设置超时时间</li>
</ul>
</li>
</ul>
<h4 id="ZNode-节点"><a href="#ZNode-节点" class="headerlink" title="ZNode 节点"></a>ZNode 节点</h4><p>ZNode 是Zookeeper中数据的最小单元，每个ZNode上可以保存数据(byte[]类型)，同时可以挂在子节点，因此构成了一个层次化的命名空间，我们称之为树</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/znode.png" alt></p>
<ul>
<li>节点是有生命周期的，生命周期由<strong>节点类型</strong>决定：<ul>
<li>持久节点(PERSISTENT)：节点创建后就一直存在于Zookeeper服务器上，直到有删除操作主动将其删除</li>
<li>持久顺序节点(PERSISTENT_SEQUENTIAL)：基本特性与持久节点一致，额外的特性在于Zookeeper会记录其子节点创建的先后顺序</li>
<li>临时节点(EPHEMERAL)：声明周期与客户端的会话绑定，客户端会话失效时节点将被自动清除</li>
<li>临时顺序节点(EPHEMERAL_SEQUENTIAL)：基本特性与临时节点一致，但添加了顺序的特性</li>
</ul>
</li>
<li>权限控制ACL (Access Control Lists)<ul>
<li>CREATE：创建子节点的权限</li>
<li>READ：获取节点数据和子节点列表的权限</li>
<li>WRITE：更新节点数据的权限</li>
<li>DELETE：删除子节点的权限</li>
<li>ADMIN：设置节点ACL的权限</li>
</ul>
</li>
</ul>
<h4 id="watcher机制"><a href="#watcher机制" class="headerlink" title="watcher机制"></a>watcher机制</h4><p>Zookeeper 引入watcher机制来实现发布/订阅功能，能够让多个订阅者同时监听某一个节点对象，当这个节点对象状态发生变化时，会通知所有订阅者。</p>
<p>Zookeeper的watcher机制主要包括客户端线程、客户端WatchManager、Zookeeper服务器三个部分。其工作流程简单来说：客户端在向Zookeeper服务器注册Watcher的同时，会将Watcher对象存储在客户端的WatchManager中；当Zookeeper服务器端触发Watcher事件后，会向客户端发送通知，客户端线程从WatchManager中取出对应的Watcher对象来执行回调逻辑</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/zk_watch.png" alt></p>
<p>可以设置的两种 Watcher</p>
<ul>
<li>NodeCache<ul>
<li>监听数据节点的内容变更</li>
<li>监听节点的创建，即如果指定的节点不存在，则节点创建后，会触发这个监听</li>
</ul>
</li>
<li>PathChildrenCache<ul>
<li>监听指定节点的子节点变化情况</li>
<li>包括新增子节点、子节点数据变更和子节点删除</li>
</ul>
</li>
</ul>
<p><strong>Zookeeper机制的特点：</strong></p>
<ol>
<li>一次性触发数据发生改变时，一个watcher event会被发送到client，但是client<strong><em>只会收到一次这样的信息\</em></strong>。</li>
<li>watcher event异步发送watcher的通知事件从server发送到client是<strong><em>异步\</em></strong>的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于<strong><em>网络延迟或其他因素导致客户端在不通的时刻监听到事件\</em></strong>，由于Zookeeper本身提供了<strong><em>ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化\</em></strong>。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper<strong><em>只能保证最终的一致性，而无法保证强一致性\</em></strong>。</li>
<li>数据监视Zookeeper有数据监视和子数据监视getdata() and exists()设置数据监视，getchildren()设置了子节点监视。</li>
<li>注册watcher <strong><em>getData、exists、getChildren\</em></strong></li>
<li>触发watcher <strong><em>create、delete、setData\</em></strong></li>
<li><strong><em>setData()\</em></strong>会触发znode上设置的data watch（如果set成功的话）。一个成功的<strong><em>create()\</em></strong> 操作会触发被创建的znode上的数据watch，以及其父节点上的child watch。而一个成功的<strong><em>delete()\</em></strong>操作将会同时触发一个znode的data watch和child watch（因为这样就没有子节点了），同时也会触发其父节点的child watch。</li>
<li>当一个客户端<strong><em>连接到一个新的服务器上\</em></strong>时，watch将会被以任意会话事件触发。当<strong><em>与一个服务器失去连接\</em></strong>的时候，是无法接收到watch的。而当client<strong><em>重新连接\</em></strong>时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，<strong><em>watch可能会丢失\</em></strong>：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。</li>
<li>Watch是轻量级的，其实就是本地JVM的<strong><em>Callback\</em></strong>，服务器端只是存了是否有设置了Watcher的布尔类型</li>
</ol>
<h2 id="Zookeeper-的典型应用场景"><a href="#Zookeeper-的典型应用场景" class="headerlink" title="Zookeeper 的典型应用场景"></a>Zookeeper 的典型应用场景</h2><p>Zookeeper 是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。</p>
<p>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：</p>
<ol>
<li><p>数据发布/订阅</p>
<p>数据发布/订阅系统，即配置中心。需要发布者将数据发布到Zookeeper的节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，<strong>实现配置信息的集中式管理和数据的动态更新（可以把我们知道RPC的注册中心看成是此场景的应用）</strong>。</p>
<p>若将配置信息存放到Zookeeper上进行集中管理，在通常情况下，<strong>应用在启动时会主动到Zookeeper服务端上进行一次配置信息的获取，同时，在指定节点上注册一个Watcher监听</strong>，这样在配置信息发生变更，服务端都会实时通知所有订阅的客户端，从而达到实时获取最新配置的目的。</p>
<p>在平时的开发中，经常会碰到这样的需求：系统中需要使用一些通用的配置信息，例如：机器列表信息，数据库的配置信息（比如：要实现数据库的切换的应用场景），运行时的开关配置等。这些全局配置信息通常有3个特性：数据量通常比较小；数据内容在运行时会发生动态变化；集群中各机器共享、配置一致。假设，我们的集群规模很大，且配置信息经常变更，所以通过存储本地配置文件或内存变量的形式实现都很困难，所以我们使用zk来做一个全局配置信息的管理。</p>
</li>
<li><p>负载均衡</p>
<p>zk实现负载均衡就是通过watcher机制和临时节点判断哪些节点宕机来获得可用的节点实现的：</p>
<p>ZooKeeper会维护一个树形的数据结构，类似于Windows资源管理器目录，其中EPHEMERAL类型的节点会随着创建它的客户端断开而被删除，利用这个特性很容易实现软负载均衡。</p>
<p>基本原理是，每个应用的Server启动时创建一个EPHEMERAL节点，应用客户端通过读取节点列表获得可用服务器列表，并订阅节点事件，有Server宕机断开时触发事件，客户端监测到后把该Server从可用列表中删除。</p>
</li>
<li><p>命名服务</p>
<p>命名服务是分步实现系统中较为常见的一类场景，分布式系统中，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象等，通过命名服务，客户端可以根据指定名字来获取资源的实体、服务地址和提供者的信息，最常见的就是RPC 框架的服务地址列表的命名。</p>
<p>在分布式环境中，上层应用仅仅需要一个全局唯一的名字。Zookeeper可以实现一套分布式全局唯一ID的分配机制。（用UUID的方式的问题在于生成的字符串过长，浪费存储空间且字符串无规律不利于开发调试）<br>通过调用Zookeeper节点创建的API接口就可以创建一个顺序节点，并且在API返回值中会返回这个节点的完整名字，利用此特性，可以生成全局ID，其步骤如下</p>
<p>  　　1. 客户端根据任务类型，在指定类型的任务下通过调用接口创建一个顺序节点，如”job-“。<br>  　　2. 创建完成后，会返回一个完整的节点名，如”job-00000001”。<br>  　　3. 客户端拼接type类型和返回值后，就可以作为全局唯一ID了，如”type2-job-00000001”。</p>
<p>分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表。在Dubbo实现中：</p>
<p>服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</p>
<p>服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址，并向/dubbo/${serviceName}/consumers目录下写入自己的URL地址。<br><strong>注意</strong>，所有向ZK上注册的地址都是<strong>临时节点</strong>，这样就能够保证服务提供者和消费者能够自动感应资源的变化。另外，Dubbo还有针对服务粒度的监控，方法是订阅/dubbo/${serviceName}目录下所有提供者和消费者的信息。</p>
</li>
<li><p>分布式协调/通知</p>
<p>Zookeeper中特有的Watcher注册于异步通知机制，能够很好地实现分布式环境下不同机器，甚至不同系统之间的协调与通知，从而实现对数据变更的实时处理。通常的做法是不同的客户端都对Zookeeper上的同一个数据节点进行Watcher注册，监听数据节点的变化（包括节点本身和子节点），若数据节点发生变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并作出相应处理。<br>在绝大多数分布式系统中，系统机器间的通信无外乎心跳检测、工作进度汇报和系统调度。这三种类型的机器通信方式都可以使用zookeeper来实现：</p>
<p>① 心跳检测，不同机器间需要检测到彼此是否在正常运行，可以使用Zookeeper实现机器间的心跳检测，基于其临时节点特性（临时节点的生存周期是客户端会话，客户端若当即后，其临时节点自然不再存在），可以让不同机器都在Zookeeper的一个指定节点下创建临时子节点，不同的机器之间可以根据这个临时子节点来判断对应的客户端机器是否存活。通过Zookeeper可以大大减少系统耦合。</p>
<p>② 工作进度汇报，通常任务被分发到不同机器后，需要实时地将自己的任务执行进度汇报给分发系统，可以在Zookeeper上选择一个节点，每个任务客户端都在这个节点下面创建临时子节点，这样不仅可以判断机器是否存活，同时各个机器可以将自己的任务执行进度写到该临时节点中去，以便中心系统能够实时获取任务的执行进度。</p>
<p>③ 系统调度，Zookeeper能够实现如下系统调度模式：分布式系统由控制台和一些客户端系统两部分构成，控制台的职责就是需要将一些指令信息发送给所有的客户端，以控制他们进行相应的业务逻辑，后台管理人员在控制台上做一些操作，实际上就是修改Zookeeper上某些节点的数据，Zookeeper可以把数据变更以时间通知的形式发送给订阅客户端。</p>
</li>
<li><p>集群管理</p>
<p>Zookeeper的两大特性（节点特性和watcher机制）：</p>
<p>　　· 客户端如果对Zookeeper的数据节点注册Watcher监听，那么当该数据及诶单内容或是其子节点列表发生变更时，Zookeeper服务器就会向订阅的客户端发送变更通知。</p>
<p>　　· 对在Zookeeper上创建的临时节点，一旦客户端与服务器之间的会话失效，那么临时节点也会被自动删除。</p>
<p>机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。这种做法可行，但是存在两个比较明显的问题：</p>
<ol>
<li><p>集群中机器有变动的时候，牵连修改的东西比较多。</p>
</li>
<li><p>有一定的延时。</p>
</li>
</ol>
<p>利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统。可以实现集群机器存活监控系统，若监控系统在/clusterServers节点上注册一个Watcher监听，那么但凡进行动态添加机器的操作，就会在/clusterServers节点下创建一个临时节点：/clusterServers/[Hostname]，这样，监控系统就能够实时监测机器的变动情况。<br>下面通过分布式日志收集系统的典型应用来学习Zookeeper如何实现集群管理。</p>
<p>　　分布式日志收集系统的核心工作就是收集分布在不同机器上的系统日志，在典型的日志系统架构设计中，整个日志系统会把所有需要收集的日志机器分为多个组别，每个组别对应一个收集器，这个收集器其实就是一个后台机器，用于收集日志，对于大规模的分布式日志收集系统场景，通常需要解决两个问题：</p>
<p>　　· 变化的日志源机器</p>
<p>　　· 变化的收集器机器</p>
<p>　　无论是日志源机器还是收集器机器的变更，最终都可以归结为如何快速、合理、动态地为每个收集器分配对应的日志源机器。<br>① 注册收集器机器，在Zookeeper上创建一个节点作为收集器的根节点，例如/logs/collector的收集器节点，每个收集器机器启动时都会在收集器节点下创建自己的节点，如/logs/collector/[Hostname]</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/zk_group.png" alt></p>
<p>② 任务分发，所有收集器机器都创建完对应节点后，系统根据收集器节点下子节点的个数，将所有日志源机器分成对应的若干组，然后将分组后的机器列表分别写到这些收集器机器创建的子节点，如/logs/collector/host1（持久节点）上去。这样，收集器机器就能够根据自己对应的收集器节点上获取日志源机器列表，进而开始进行日志收集工作。</p>
<p>③ 状态汇报，完成任务分发后，机器随时会宕机，所以需要有一个收集器的状态汇报机制，每个收集器机器上创建完节点后，还需要再对应子节点上创建一个状态子节点，如/logs/collector/host/status（临时节点），每个收集器机器都需要定期向该结点写入自己的状态信息，这可看做是心跳检测机制，通常收集器机器都会写入日志收集状态信息，日志系统通过判断状态子节点最后的更新时间来确定收集器机器是否存活。</p>
<p>④ 动态分配，若收集器机器宕机，则需要动态进行收集任务的分配，收集系统运行过程中关注/logs/collector节点下所有子节点的变更，一旦有机器停止汇报或有新机器加入，就开始进行任务的重新分配，此时通常由两种做法：</p>
<ul>
<li><p>全局动态分配，当收集器机器宕机或有新的机器加入，系统根据新的收集器机器列表，立即对所有的日志源机器重新进行一次分组，然后将其分配给剩下的收集器机器。</p>
</li>
<li><p>局部动态分配，每个收集器机器在汇报自己日志收集状态的同时，也会把自己的负载汇报上去，如果一个机器宕机了，那么日志系统就会把之前分配给这个机器的任务重新分配到那些负载较低的机器，同样，如果有新机器加入，会从那些负载高的机器上转移一部分任务给新机器。</p>
</li>
</ul>
</li>
<li><p>Master 选举</p>
<p>在分布式系统中，Master往往用来协调集群中其他系统单元，具有对分布式系统状态变更的决定权，如在读写分离的应用场景中，客户端的写请求往往是由Master来处理，或者其常常处理一些复杂的逻辑并将处理结果同步给其他系统单元。利用Zookeeper的一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即Zookeeper将会保证客户端无法重复创建一个已经存在的数据节点（由其分布式数据的一致性保证）。</p>
<p>首先创建/master_election/2016-11-12节点，客户端集群每天会定时往该节点下创建临时节点，如/master_election/2016-11-12/binding，这个过程中，只有一个客户端能够成功创建，此时其变成master，其他节点都会在节点/master_election/2016-11-12上注册一个子节点变更的Watcher，用于监控当前的Master机器是否存活，一旦发现当前Master挂了，其余客户端将会重新进行Master选举。<br><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/zk_master.png" alt></p>
<p>另外，这种场景演化一下，就是动态Master选举。这就要用到?EPHEMERAL_SEQUENTIAL类型节点的特性了。</p>
<p>上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终在ZK上创建结果的一种可能情况是这样：/currentMaster/{sessionId}-1 ,?/currentMaster/{sessionId}-2,?/currentMaster/{sessionId}-3 ….. 每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上小时，那么之后最小的那个机器就是Master了。</p>
<p>其在实际中应用有：</p>
<ul>
<li><p>在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的Master来进行全量索引的生成，然后同步到集群中其它机器。另外，Master选举的容灾措施是，可以随时进行手动指定master，就是说应用在zk在无法获取master信息时，可以通过比如http方式，向一个地方获取master。</p>
</li>
<li><p>在Hbase中，也是使用ZooKeeper来实现动态HMaster的选举。在Hbase实现中，会在ZK上存储一些ROOT表的地址和 HMaster的地址，HRegionServer也会把自己以临时节点（Ephemeral）的方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的存活状态，同时，一旦HMaster出现问题，会重新选举出一个HMaster来运行，从而避免了 HMaster的单点问题。</p>
</li>
</ul>
</li>
<li><p>分布式锁</p>
<p>分布式锁用于控制分布式系统之间同步访问共享资源的一种方式，可以保证不同系统访问一个或一组资源时的一致性，主要分为排它锁和共享锁。排它锁又称为写锁或独占锁，若事务T1对数据对象O1加上了排它锁，那么在整个加锁期间，只允许事务T1对O1进行读取和更新操作，其他任何事务都不能再对这个数据对象进行任何类型的操作，直到T1释放了排它锁。</p>
<p>① 获取锁，在需要获取排它锁时，所有客户端通过调用接口，在/exclusive_lock节点下创建临时子节点/exclusive_lock/lock。Zookeeper可以保证只有一个客户端能够创建成功，没有成功的客户端需要注册/exclusive_lock节点监听。</p>
<p>② 释放锁，当获取锁的客户端宕机或者正常完成业务逻辑都会导致临时节点的删除，此时，所有在/exclusive_lock节点上注册监听的客户端都会收到通知，可以重新发起分布式锁获取。</p>
<p>共享锁又称为读锁，若事务T1对数据对象O1加上共享锁，那么当前事务只能对O1进行读取操作，其他事务也只能对这个数据对象加共享锁，直到该数据对象上的所有共享锁都被释放。（控制时序）<br><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/zk_lock11.png" alt></p>
<p>① 获取锁，在需要获取共享锁时，所有客户端都会到/shared_lock下面创建一个临时顺序节点，如果是读请求，那么就创建例如/shared_lock/host1-R-00000001的节点，如果是写请求，那么就创建例如/shared_lock/host2-W-00000002的节点。</p>
<p>② 判断读写顺序，不同事务可以同时对一个数据对象进行读写操作，而更新操作必须在当前没有任何事务进行读写情况下进行，通过Zookeeper来确定分布式读写顺序，大致分为四步。</p>
<p>   　　　　1. 创建完节点后，获取/shared_lock节点下所有子节点，并对该节点变更注册监听。<br>   　　　　2. 确定自己的节点序号在所有子节点中的顺序。<br>   　　　　3. 对于读请求：若没有比自己序号小的子节点或所有比自己序号小的子节点都是读请求，那么表明自己已经成功获取到共享锁，同时开始执行读取逻辑，若有写请求，则需要等待。对于写请求：若自己不是序号最小的子节点，那么需要等待。<br>   　　　　4. 接收到Watcher通知后，重复步骤1。</p>
<p>③ 释放锁，其释放锁的流程与独占锁一致。</p>
<p>上述共享锁的实现方案，可以满足一般分布式集群竞争锁的需求，但是如果机器规模扩大会出现一些问题，下面着重分析判断读写顺序的步骤3。<br>针对如上图所示的情况进行分析</p>
<p>　　1. host1首先进行读操作，完成后将节点/shared_lock/host1-R-00000001删除。</p>
<p>　　2. 余下4台机器均收到这个节点移除的通知，然后重新从/shared_lock节点上获取一份新的子节点列表。</p>
<p>　　3. 每台机器判断自己的读写顺序，其中host2检测到自己序号最小，于是进行写操作，余下的机器则继续等待。</p>
<p>　　4. 继续…</p>
<p>　　可以看到，host1客户端在移除自己的共享锁后，Zookeeper发送了子节点更变Watcher通知给所有机器，然而除了给host2产生影响外，对其他机器没有任何作用。大量的Watcher通知和子节点列表获取两个操作会重复运行，这样会造成系能鞥影响和网络开销，更为严重的是，如果同一时间有多个节点对应的客户端完成事务或事务中断引起节点小时，Zookeeper服务器就会在短时间内向其他所有客户端发送大量的事件通知，这就是所谓的羊群效应。</p>
<p>　可以有如下改动来避免羊群效应。</p>
<p>　　1. 客户端调用create接口常见类似于/shared_lock/[Hostname]-请求类型-序号的临时顺序节点。</p>
<p>　　2. 客户端调用getChildren接口获取所有已经创建的子节点列表（不注册任何Watcher）。</p>
<p>　　3. 如果无法获取共享锁，就调用exist接口来对比自己小的节点注册Watcher。对于读请求：向比自己序号小的最后一个写请求节点注册Watcher监听。对于写请求：向比自己序号小的最后一个节点注册Watcher监听。</p>
<p>　　4. 等待Watcher通知，继续进入步骤2。</p>
<p>　　此方案改动主要在于：每个锁竞争者，只需要关注/shared_lock节点下序号比自己小的那个节点是否存在即可。</p>
</li>
<li><p>分布式队列</p>
</li>
</ol>
<p>分布式队列可以简单分为先入先出队列模型和等待队列元素聚集后统一安排处理执行的Barrier模型。</p>
<p>① FIFO先入先出，先进入队列的请求操作先完成后，才会开始处理后面的请求。FIFO队列就类似于全写的共享模型，所有客户端都会到/queue_fifo这个节点下创建一个临时节点，如/queue_fifo/host1-00000001。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/zk_queue.png" alt></p>
<p>创建完节点后，按照如下步骤执行。</p>
<p>　　1. 通过调用getChildren接口来获取/queue_fifo节点的所有子节点，即获取队列中所有的元素。</p>
<p>　　2. 确定自己的节点序号在所有子节点中的顺序。</p>
<p>　　3. 如果自己的序号不是最小，那么需要等待，同时向比自己序号小的最后一个节点注册Watcher监听。</p>
<p>　　4. 接收到Watcher通知后，重复步骤1。</p>
<p>② Barrier分布式屏障，最终的合并计算需要基于很多并行计算的子结果来进行，开始时，/queue_barrier节点已经默认存在，并且将结点数据内容赋值为数字n来代表Barrier值，之后，所有客户端都会到/queue_barrier节点下创建一个临时节点，例如/queue_barrier/host1。<br>　创建完节点后，按照如下步骤执行。</p>
<p>　　1. 通过调用getData接口获取/queue_barrier节点的数据内容，如10。</p>
<p>　　2. 通过调用getChildren接口获取/queue_barrier节点下的所有子节点，同时注册对子节点变更的Watcher监听。</p>
<p>　　3. 统计子节点的个数。</p>
<p>　　4. 如果子节点个数还不足10个，那么需要等待。</p>
<p>  　　5. 接受到Wacher通知后，重复步骤3</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>分布式锁用Redis or Zookeeper?</title>
    <url>/2020/03/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8Redis-or-Zookeeper/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="为什么用分布式锁？"><a href="#为什么用分布式锁？" class="headerlink" title="为什么用分布式锁？"></a>为什么用分布式锁？</h2><p>系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。</p><p>由于系统有一定的并发，所以会预先将商品的库存保存在 Redis 中，用户下单的时候会更新 Redis 的库存。</p><p>此时系统架构如下：</p><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock.png" alt></p><p>但是这样一来会产生一个问题：假如某个时刻，Redis 里面的某个商品库存为 1。</p><a id="more"></a>




<p>此时两个请求同时到来，其中一个请求执行到上图的第 3 步，更新数据库的库存为 0，但是第 4 步还没有执行。</p>
<p>而另外一个请求执行到了第 2 步，发现库存还是 1，就继续执行第 3 步。这样的结果，是导致卖出了 2 个商品，然而其实库存只有 1 个。</p>
<p>很明显不对啊！这就是典型的库存超卖问题。此时，我们很容易想到解决方案：用锁把 2、3、4 步锁住，让他们执行完之后，另一个线程才能进来执行第 2 步。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock1.png" alt></p>
<p>按照上面的图，在执行第 2 步时，使用 Java 提供的 Synchronized 或者 ReentrantLock 来锁住，然后在第 4 步执行完之后才释放锁。</p>
<p>这样一来，2、3、4 这 3 个步骤就被“锁”住了，多个线程之间只能串行化执行。</p>
<p>但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock2.png" alt></p>
<p>增加机器之后，系统变成上图所示，我的天！假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。</p>
<p>为什么呢？因为上图中的两个 A 系统，运行在两个不同的 JVM 里面，他们加的锁只对属于自己 JVM 里面的线程有效，对于其他 JVM 的线程是无效的。</p>
<p>因此，这里的问题是：Java 提供的原生锁机制在多机部署场景下失效了，这是因为两台机器加的锁不是同一个锁（两个锁在不同的 JVM 里面）。</p>
<p>那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁隆重登场了。</p>
<p>分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p>
<p>至于这个“东西”，可以是 Redis、Zookeeper，也可以是数据库。文字描述不太直观，我们来看下图：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock3.png" alt></p>
<p>通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用 Java 原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。</p>
<p>那么，如何实现分布式锁呢？接着往下看！</p>
<h2 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h2><p>上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。</p>
<p><strong>①常见的一种方案就是使用 Redis 做分布式锁</strong></p>
<p>使用 Redis 做分布式锁的思路大概是这样的：在 Redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 Key 删除。</p>
<p>具体代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="comment">// NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间</span></span><br><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span></span><br><span class="line"><span class="comment">// 释放锁：通过执行一段lua脚本</span></span><br><span class="line"><span class="comment">// 释放锁涉及到两条指令，这两条指令不是原子性的</span></span><br><span class="line"><span class="comment">// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>这种方式有几大要点：</strong></p>
<ul>
<li>一定要用 SET key value NX PX milliseconds 命令。如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(Key 永久存在)</li>
<li>Value 要具有唯一性。这个是为了在解锁的时候，需要验证 Value 是和加锁的一致才删除 Key。 这时避免了一种情况：假设 A 获取了锁，过期时间 30s，此时 35s 之后，锁已经自动释放了，A 去释放锁，但是此时可能 B 获取了锁。A 客户端就不能删除 B 的锁了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock4.png" alt></p>
<p>除了要考虑客户端要怎么实现分布式锁之外，还需要考虑 Redis 的部署问题。</p>
<p>Redis 有 3 种部署方式：</p>
<ul>
<li>单机模式</li>
<li>Master-Slave+Sentinel 选举模式</li>
<li>Redis Cluster 模式</li>
</ul>
<p>使用 Redis 做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要 Redis 故障了。加锁就不行了。</p>
<p>采用 Master-Slave 模式，加锁的时候只对一个节点加锁，即便通过 Sentinel 做了高可用，但是如果 Master 节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。</p>
<p>基于以上的考虑，Redis 的作者也考虑到这个问题，他提出了一个 RedLock 的算法。</p>
<p>这个算法的意思大概是这样的：假设 Redis 的部署模式是 Redis Cluster，总共有 5 个 Master 节点。</p>
<ul>
<li>获取当前时间戳，单位是毫秒。</li>
<li>轮流尝试在每个 Master 节点上创建锁，过期时间设置较短，一般就几十毫秒。</li>
<li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点（n / 2 +1）。</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了。</li>
<li>要是锁建立失败了，那么就依次删除这个锁。</li>
<li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</li>
</ul>
<p>但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock5.png" alt></p>
<p><strong>②另一种方式：Redisson</strong></p>
<p>此外，实现 Redis 的分布式锁，除了自己基于 Redis Client 原生 API 来实现之外，还可以使用开源框架：Redission。</p>
<p>Redisson 是一个企业级的开源 Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？</p>
<p>回想一下上面说的，如果自己写代码来通过 Redis 设置一个值，是通过下面这个命令设置的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure>

<p>这里设置的超时时间是 30s，假如我超过 30s 都还没有完成业务逻辑的情况下，Key 会过期，其他线程有可能会获取到锁。</p>
<p>这样一来的话，第一个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。</p>
<p>所以我们还需要额外的去维护这个过期时间，太麻烦了~我们来看看 Redisson 是怎么实现的？</p>
<p>先感受一下使用 Redission 的爽：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers()</span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7001"</span>)</span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7002"</span>)</span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7003"</span>)</span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7001"</span>)</span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7002"</span>)</span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7003"</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>就是这么简单，我们只需要通过它的 API 中的 Lock 和 Unlock 即可完成分布式锁，他帮我们考虑了很多细节：</p>
<ul>
<li>Redisson 所有指令都通过 Lua 脚本执行，Redis 支持 Lua 脚本原子性执行。</li>
<li>Redisson 设置一个 Key 的默认过期时间为 30s，如果某个客户端持有一个锁超过了 30s 怎么办？ Redisson 中有一个 Watchdog 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10s 帮你把 Key 的超时时间设为 30s。 这样的话，就算一直持有锁也不会出现 Key 过期了，其他线程获取到锁的问题了。</li>
<li>Redisson 的“看门狗”逻辑保证了没有死锁发生。(如果机器宕机了，看门狗也就没了。此时就不会延长 Key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock6.png" alt></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁逻辑</span></span><br><span class="line">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用一段lua脚本，设置一些key、过期时间</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> operationComplete(Future&lt;Long&gt; future) throws Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Long ttlRemaining = future.getNow();</span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 看门狗逻辑</span></span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                  <span class="string">"return nil; "</span> +</span><br><span class="line">              <span class="string">"end; "</span> +</span><br><span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                  <span class="string">"return nil; "</span> +</span><br><span class="line">              <span class="string">"end; "</span> +</span><br><span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                Collections.&lt;<span class="built_in">Object</span>&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 看门狗最终会调用了这里</span></span><br><span class="line">private <span class="keyword">void</span> scheduleExpirationRenewal(final long threadId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个任务会延迟10s执行</span></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> run(Timeout timeout) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个操作会将key的过期时间重新设置为30s</span></span><br><span class="line">            RFuture&lt;<span class="built_in">Boolean</span>&gt; future = renewExpirationAsync(threadId);</span><br><span class="line"></span><br><span class="line">            future.addListener(<span class="keyword">new</span> FutureListener&lt;<span class="built_in">Boolean</span>&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public <span class="keyword">void</span> operationComplete(Future&lt;<span class="built_in">Boolean</span>&gt; future) throws Exception &#123;</span><br><span class="line">                    expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                        log.error(<span class="string">"Can't update lock "</span> + getName() + <span class="string">" expiration"</span>, future.cause());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (future.getNow()) &#123;</span><br><span class="line">                        <span class="comment">// reschedule itself</span></span><br><span class="line">                        <span class="comment">// 通过递归调用本方法，无限循环延长过期时间</span></span><br><span class="line">                        scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), <span class="keyword">new</span> ExpirationEntry(threadId, task)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Redisson 还提供了对 Redlock 算法的支持，它的用法也很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br><span class="line">RLock lock1 = redisson.getFairLock(<span class="string">"lock1"</span>);</span><br><span class="line">RLock lock2 = redisson.getFairLock(<span class="string">"lock2"</span>);</span><br><span class="line">RLock lock3 = redisson.getFairLock(<span class="string">"lock3"</span>);</span><br><span class="line">RedissonRedLock multiLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">multiLock.lock();</span><br><span class="line">multiLock.unlock();</span><br></pre></td></tr></table></figure>

<p>小结：本节分析了使用 Redis 作为分布式锁的具体落地方案以及其一些局限性，然后介绍了一个 Redis 的客户端框架 Redisson，这也是我推荐大家使用的，比自己写代码实现会少 Care 很多细节。</p>
<h2 id="基于-Zookeeper-实现分布式锁"><a href="#基于-Zookeeper-实现分布式锁" class="headerlink" title="基于 Zookeeper 实现分布式锁"></a>基于 Zookeeper 实现分布式锁</h2><p>常见的分布式锁实现方案里面，除了使用 Redis 来实现之外，使用 Zookeeper 也可以实现分布式锁。</p>
<p>在介绍 Zookeeper(下文用 ZK 代替)实现分布式锁的机制之前，先粗略介绍一下 ZK 是什么东西：ZK 是一种提供配置管理、分布式协同以及命名的中心化服务。</p>
<p>ZK 的模型是这样的：ZK 包含一系列的节点，叫做 Znode，就好像文件系统一样，每个 Znode 表示一个目录。</p>
<p>然后 Znode 有一些特性：</p>
<ul>
<li>持久节点（PERSISTENT ）：节点创建后，一直存在，直到主动删除了该节点。</li>
<li>有序节点（SEQUENTIAL）：多个线程创建同一个顺序节点时候，每个线程会得到一个带有编号的节点，节点编号是递增不重复的。</li>
<li>临时节点（EPHEMERAL）：生命周期和客户端会话绑定，一旦客户端会话失效，这个节点就会自动删除。</li>
<li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，ZK 会通知客户端。</li>
</ul>
<p>当前 ZK 有如下四种事件：</p>
<ul>
<li>节点创建</li>
<li>节点删除</li>
<li>节点数据修改</li>
<li>子节点变更</li>
</ul>
<p>基于以上的一些 ZK 的特性，我们很容易得出使用 ZK 实现分布式锁的落地方案：</p>
<ul>
<li>创建临时顺序节点,比如/root/node，假设返回结果为nodeId。</li>
<li>获取/root下所有孩子节点，用自己创建的nodeId的序号与所有子节点比较，看看自己是不是编号最小的。如果是最小的则就相当于获取到了锁，如果自己不是最小的，则从所有子节点里面获取比自己次小的一个节点，然后设置监听该节点的事件，然后挂起当前线程。</li>
<li>当最小编号的线程获取锁，处理完业务后删除自己对应的nodeId，删除后会激活比自己大一号的节点的线程从阻塞变为运行态，被激活的线程应该就是当前node序列号最小的了，然后就会获取到锁。</li>
</ul>
<p>整个过程如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock7.png" alt></p>
<p>下面我们看看代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperDistributedLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Joiner j = Joiner.on(<span class="string">"|"</span>).useForNull(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//zk客户端</span></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="comment">//zk是一个目录结构，root为最外层目录</span></span><br><span class="line">    <span class="keyword">private</span> String root = <span class="string">"/locks"</span>;</span><br><span class="line">    <span class="comment">//锁的名称</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="comment">//当前线程创建的序列node</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; nodeId = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="comment">//用来同步等待zkclient链接到了服务端</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] data= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperDistributedLock</span><span class="params">(String config, String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(config, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 建立连接</span></span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">                        connectedSignal.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            connectedSignal.await();</span><br><span class="line">            Stat stat = zk.exists(root, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == stat) &#123;</span><br><span class="line">                <span class="comment">// 创建根节点</span></span><br><span class="line">                zk.create(root, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LockWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockWatcher</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (event.getType() == Event.EventType.NodeDeleted)</span><br><span class="line">                latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建临时子节点</span></span><br><span class="line">            String myNode = zk.create(root + <span class="string">"/"</span> + lockName , data, ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                    CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            System.out.println(j.join(Thread.currentThread().getName() + myNode, <span class="string">"created"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出所有子节点</span></span><br><span class="line">            List&lt;String&gt; subNodes = zk.getChildren(root, <span class="keyword">false</span>);</span><br><span class="line">            TreeSet&lt;String&gt; sortedNodes = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String node :subNodes) &#123;</span><br><span class="line">                sortedNodes.add(root +<span class="string">"/"</span> +node);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            String smallNode = sortedNodes.first();</span><br><span class="line">            String preNode = sortedNodes.lower(myNode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (myNode.equals( smallNode)) &#123;</span><br><span class="line">                <span class="comment">// 如果是最小的节点,则表示取得锁</span></span><br><span class="line">                System.out.println(j.join(Thread.currentThread().getName(), myNode, <span class="string">"get lock"</span>));</span><br><span class="line">                <span class="keyword">this</span>.nodeId.set(myNode);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            Stat stat = zk.exists(preNode, <span class="keyword">new</span> LockWatcher(latch));<span class="comment">// 同时注册监听。</span></span><br><span class="line">            <span class="comment">// 判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听</span></span><br><span class="line">            <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(j.join(Thread.currentThread().getName(), myNode,</span><br><span class="line">                        <span class="string">" waiting for "</span> + root + <span class="string">"/"</span> + preNode + <span class="string">" released lock"</span>));</span><br><span class="line"></span><br><span class="line">                latch.await();<span class="comment">// 等待，这里应该一直等待其他线程释放锁</span></span><br><span class="line">                nodeId.set(myNode);</span><br><span class="line">                latch = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(j.join(Thread.currentThread().getName(), nodeId.get(), <span class="string">"unlock "</span>));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != nodeId) &#123;</span><br><span class="line">                zk.delete(nodeId.get(), -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            nodeId.remove();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Curator 介绍</strong></p>
<p>Curator 是一个 ZK 的开源客户端，也提供了分布式锁的实现。它的使用方式也比较简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client,<span class="string">"/anyLock"</span>);</span><br><span class="line">interProcessMutex.acquire();</span><br><span class="line">interProcessMutex.release();</span><br></pre></td></tr></table></figure>

<p>其实现分布式锁的核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>  haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>  doDelete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) &#123;</span><br><span class="line">            <span class="comment">// 获取当前所有节点排序后的集合</span></span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren();</span><br><span class="line">            <span class="comment">// 获取当前节点的名称</span></span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash</span></span><br><span class="line">            <span class="comment">// 判断当前节点是否是最小的节点</span></span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            <span class="keyword">if</span> ( predicateResults.getsTheLock() ) &#123;</span><br><span class="line">                <span class="comment">// 获取到锁</span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没获取到锁，对当前节点的上一个节点注册一个监听器</span></span><br><span class="line">                String  previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch();</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                    Stat stat = client.checkExists().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                    <span class="keyword">if</span> ( stat != <span class="keyword">null</span> )&#123;</span><br><span class="line">                        <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )&#123;</span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                            startMillis = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                                doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            wait(millisToWait);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else it may have been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">        doDelete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( doDelete )&#123;</span><br><span class="line">            deleteOurPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haveTheLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 Curator 实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/distribute_lock8.png" alt></p>
<p>小结：本节介绍了 ZK 实现分布式锁的方案以及 ZK 的开源客户端的基本使用，简要的介绍了其实现原理。</p>
<h2 id="两种方案的优缺点比较"><a href="#两种方案的优缺点比较" class="headerlink" title="两种方案的优缺点比较"></a>两种方案的优缺点比较</h2><hr>
<p>学完了两种分布式锁的实现方案之后，本节需要讨论的是 Redis 和 ZK 的实现方案中各自的优缺点。</p>
<p>对于 Redis 的分布式锁而言，它有以下缺点：</p>
<ul>
<li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li>
<li>另外来说的话，Redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮。</li>
<li>即便使用 Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题，关于 Redlock 的讨论可以看 How to do distributed locking。</li>
<li>Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</li>
</ul>
<p>但是另一方面使用 Redis 实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”。</p>
<p>所以使用 Redis 作为分布式锁也不失为一种好的方案，最重要的一点是 Redis 的性能很高，可以支撑高并发的获取、释放锁操作。</p>
<p>对于 ZK 分布式锁而言:</p>
<ul>
<li>ZK 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li>
<li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li>
</ul>
<p>但是 ZK 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p>
<p><strong>小结</strong>：综上所述，Redis 和 ZK 都有其优缺点。我们在做技术选型的时候可以根据这些问题作为参考因素。</p>
]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
  </entry>
  <entry>
    <title>如何设计一个高并发系统</title>
    <url>/2020/03/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？</p><p>我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较 low，结果业务发展太快，有的时候系统扛不住压力就挂了。</p><a id="more"></a>

<p>当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒 5000/8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。</p>
<p>所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多 app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一之类的，每秒并发几万几十万都有可能。</p>
<p>那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：</p>
<p>可以分为以下 6 点：</p>
<ul>
<li>系统拆分</li>
<li>缓存</li>
<li>MQ</li>
<li>分库分表</li>
<li>读写分离</li>
<li>ElasticSearch</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/architect/high-concurrency-system-design.png" alt></p>
<h3 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h3><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p>
<h4 id="为什么要将系统进行拆分？"><a href="#为什么要将系统进行拆分？" class="headerlink" title="为什么要将系统进行拆分？"></a>为什么要将系统进行拆分？</h4><p>要是<strong>不拆分</strong>，一个大系统几十万行代码，20 个人维护一份代码，简直是悲剧啊。代码经常改着改着就冲突了，各种代码冲突和合并要处理，非常耗费时间；经常我改动了我的代码，你调用了我的，导致你的代码也得重新测试，麻烦的要死；然后每次发布都是几十万行代码的系统一起发布，大家得一起提心吊胆准备上线，几十万行代码的上线，可能每次上线都要做很多的检查，很多异常问题的处理，简直是又麻烦又痛苦；而且如果我现在打算把技术升级到最新的 spring 版本，还不行，因为这可能导致你的代码报错，我不敢随意乱改技术。</p>
<p>假设一个系统是 20 万行代码，其中 A 在里面改了 1000 行代码，但是此时发布的时候是这个 20 万行代码的大系统一块儿发布。就意味着 20 万上代码在线上就可能出现各种变化，20 个人，每个人都要紧张地等在电脑面前，上线之后，检查日志，看自己负责的那一块儿有没有什么问题。</p>
<p>A 就检查了自己负责的 1 万行代码对应的功能，确保 ok 就闪人了；结果不巧的是，A 上线的时候不小心修改了线上机器的某个配置，导致另外 B 和 C 负责的 2 万行代码对应的一些功能，出错了。</p>
<p>几十个人负责维护一个几十万行代码的单块应用，每次上线，准备几个礼拜，上线 -&gt; 部署 -&gt; 检查自己负责的功能。</p>
<p><strong>拆分了以后</strong>，整个世界清爽了，几十万行代码的系统，拆分成 20 个服务，平均每个服务就 1~2 万行代码，每个服务部署到单独的机器上。20 个工程，20 个 git 代码仓库，20 个开发人员，每个人维护自己的那个服务就可以了，是自己独立的代码，跟别人没关系。再也没有代码冲突了，爽。每次就测试我自己的代码就可以了，爽。每次就发布我自己的一个小服务就可以了，爽。技术上想怎么升级就怎么升级，保持接口不变就可以了，真爽。</p>
<p>所以简单来说，一句话总结，如果是那种代码量多达几十万行的中大型项目，团队里有几十个人，那么如果不拆分系统，<strong>开发效率极其低下</strong>，问题很多。但是拆分系统之后，每个人就负责自己的一小部分就好了，可以随便玩儿随便弄。分布式系统拆分之后，可以大幅度提升复杂系统大型团队的开发效率。</p>
<p>但是同时，也要<strong>提醒</strong>的一点是，系统拆分成分布式系统之后，大量的分布式系统面临的问题也是接踵而来，所以后面的问题都是在<strong>围绕分布式系统带来的复杂技术挑战</strong>在说。</p>
<h4 id="如何进行系统拆分？"><a href="#如何进行系统拆分？" class="headerlink" title="如何进行系统拆分？"></a>如何进行系统拆分？</h4><p>系统拆分为分布式系统，拆成多个服务，拆成微服务的架构，是需要拆很多轮的。并不是说上来一个架构师一次就给拆好了，而以后都不用拆。</p>
<p>第一轮；团队继续扩大，拆好的某个服务，刚开始是 1 个人维护 1 万行代码，后来业务系统越来越复杂，这个服务是 10 万行代码，5 个人；第二轮，1个服务 -&gt; 5个服务，每个服务 2 万行代码，每人负责一个服务。</p>
<p>如果是多人维护一个服务，最理想的情况下，几十个人，1 个人负责 1 个或 2~3 个服务；某个服务工作量变大了，代码量越来越多，某个同学，负责一个服务，代码量变成了 10 万行了，他自己不堪重负，他现在一个人拆开，5 个服务，1 个人顶着，负责 5 个人，接着招人，2 个人，给那个同学带着，3 个人负责 5 个服务，其中 2 个人每个人负责 2 个服务，1 个人负责 1 个服务。</p>
<p>个人建议，一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p>
<p>大部分的系统，是要进行<strong>多轮拆分</strong>的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成订单系统、商品系统、采购系统、仓储系统、用户系统，等等吧。</p>
<p>但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了供应商管理系统、采购单管理系统，订单系统又拆分成了购物车系统、价格系统、订单管理系统。</p>
<p><strong>核心意思就是根据情况，先拆分一轮，后面如果系统更复杂了，可以继续分拆</strong>。你根据自己负责系统的例子，来考虑一下就好了。</p>
<h3 id="拆分后不用-dubbo-可以吗？"><a href="#拆分后不用-dubbo-可以吗？" class="headerlink" title="拆分后不用 dubbo 可以吗？"></a>拆分后不用 dubbo 可以吗？</h3><p>当然可以了，大不了最次，就是各个系统之间，直接基于 spring mvc，就纯 http 接口互相通信呗，还能咋样。但是这个肯定是有问题的，因为 http 接口通信维护起来成本很高，你要考虑<strong>超时重试</strong>、<strong>负载均衡</strong>等等各种乱七八糟的问题，比如说你的订单系统调用商品系统，商品系统部署了 5 台机器，你怎么把请求均匀地甩给那 5 台机器？这不就是负载均衡？你要是都自己搞那是可以的，但是确实很痛苦。</p>
<p>所以 dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡、服务实例上下线自动感知、超时重试等等乱七八糟的问题。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，必须得用缓存。大部分的高并发场景，都是<strong>读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的<strong>读场景，怎么用缓存来抗高并发</strong>。</p>
<h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表<strong>拆分为多个表</strong>，每个表的数据量保持少一点，提高 sql 跑的性能。</p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，<strong>主库写</strong>入，<strong>从库读</strong>取，搞一个读写分离。<strong>读流量太多</strong>的时候，还可以<strong>加更多的从库</strong>。</p>
<h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p>
<p><a href="https://juejin.im/post/5e24f8a7f265da3e0b4340ee" target="_blank" rel="noopener">如何设计一个高可用系统</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>Es基本知识</title>
    <url>/2020/03/17/Es/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Es-的分布式架构原理"><a href="#Es-的分布式架构原理" class="headerlink" title="Es 的分布式架构原理"></a>Es 的分布式架构原理</h2><p>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。核心思想就是在多台机器上启动多个 es 进程实例，组成了一个 es 集群。</p><p>es 中存储数据的<strong>基本单位是索引</strong>，比如说你现在要在 es 中存储一些订单数据，你就应该在 es 中创建一个索引 <code>order_idx</code>，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。</p><a id="more"></a>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">index -&gt;<span class="built_in"> type </span>-&gt; mapping -&gt; document -&gt; field。</span><br></pre></td></tr></table></figure>

<p>这样吧，为了做个更直白的介绍，我在这里做个类比。但是切记，不要划等号，类比只是为了便于理解。</p>
<p>index 相当于 mysql 里的一张表。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。</p>
<p>所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</p>
<p>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（<strong>注意</strong>，<code>mapping types</code> 这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考<a href="https://github.com/elastic/elasticsearch/blob/6.5/docs/reference/mapping/removal_of_types.asciidoc" target="_blank" rel="noopener">官方文档</a>），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的<strong>表结构定义</strong>，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es.png" alt></p>
<p>你搞一个索引，这个索引可以拆分成多个 <code>shard</code>，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是<strong>支持横向扩展</strong>，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是<strong>提高性能</strong>，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p>
<p>接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 <code>primary shard</code>，负责写入数据，但是还有几个 <code>replica shard</code>。<code>primary shard</code> 写入数据之后，会将数据同步到其他几个 <code>replica shard</code> 上去。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es1.png" alt></p>
<p>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</p>
<p>es 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</p>
<p>如果是非 master节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p>
<p>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p>
<p>其实上述就是 ElasticSearch 作为分布式搜索引擎最基本的一个架构设计。</p>
<h3 id="底层-lucene"><a href="#底层-lucene" class="headerlink" title="底层 lucene"></a>底层 lucene</h3><p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p>
<p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><h4 id="倒排索引与正排索引"><a href="#倒排索引与正排索引" class="headerlink" title="倒排索引与正排索引"></a>倒排索引与正排索引</h4><p><strong>倒排索引（Inverted Index）</strong> 也常被称为反向索引，是搜索引擎中非常重要的数据结构，为什么说它重要呢，我们首先拿一本书《重构 改善既有代码的设计》举个例子：</p>
<p>如果一本书没有目录的话，理论上也是可以读的，只是合上书下次再次阅读的时候，就有些耗费时间了。</p>
<p>通过给一本书加目录页，可以快速了解这本书的大致内容分布以及每个章节的页码数，这样在查询内容的时候效率就会非常高了，所以书的目录就是书本内容的简单索引。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/index.png" alt></p>
<p>想象一下你要搜索 <code>case语句</code> 这个关键词在这本书的页码，你应该怎么办呢？有些技术类的书籍会在最后提供索引页，这本书的索引页如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_invert_index.png" alt></p>
<p>只需要从索引页中查找 <code>case语句</code>，就可以查找到关键词在书本中的页码位置了。</p>
<p>看完这个例子，让我们来把图书和搜索引擎做个简单的类比：</p>
<p>图书当中的<strong>目录页</strong>就相当<strong>正向索引（Forward Index）</strong>，<strong>索引页</strong>就相当于<strong>倒排索引</strong>的简单实现，在搜索引擎中，<strong>正向索引</strong>指的是<strong>文档 ID 到文档内容和单词的关联</strong>，<strong>倒排索引</strong>就是<strong>单词到文档 ID 的关系</strong>。</p>
<p>创建倒排索引，分为以下几步：</p>
<p>1）创建文档列表：</p>
<p>lucene首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_doc.png" alt></p>
<p>2）创建倒排索引列表</p>
<p>对文档中数据进行分词，得到词条。对词条进行编号，以词条创建索引。然后记录下包含该词条的所有文档编号（及其它信息）。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_doc_list.png" alt></p>
<p>搜索的过程：</p>
<p>当用户输入任意的词条时，首先对用户输入的数据进行分词，得到用户要搜索的所有词条，然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。然后根据这些编号去文档列表中找到文档</p>
<h4 id="倒排索引为什么快？"><a href="#倒排索引为什么快？" class="headerlink" title="倒排索引为什么快？"></a>倒排索引为什么快？</h4><p>​        Elasticsearch 是通过 Lucene 的倒排索引技术实现比关系型数据库更快的过滤。特别是它对多条件的过滤支持非常好，比如年龄在 18 和 30 之间，性别为女性这样的组合查询。倒排索引很多地方都有介绍，但是其比关系型数据库的 b-tree 索引快在哪里？到底为什么快呢？</p>
<p>​        笼统的来说，b-tree 索引是为写入优化的索引结构。当我们不需要支持快速的更新的时候，可以用预先排序等方式换取更小的存储空间，更快的检索速度等好处，其代价就是更新慢。要进一步深入的化，还是要看一下 Lucene 的倒排索引是怎么构成的。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_index_struct.png" alt></p>
<p>​        这里有好几个概念。我们来看一个实际的例子，假设有如下的数据：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_example.png" alt></p>
<p>​        这里每一行是一个 document。每个 document 都有一个 docid。那么给这些 document 建立的倒排索引就是：年龄、性别。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_example1.png" alt></p>
<p>​        可以看到，倒排索引是 per field 的，一个字段由一个自己的倒排索引。18,20 这些叫做 term，而 [1,3] 就是 posting list。Posting list 就是一个 int 的数组，存储了所有符合某个 term 的文档 id。那么什么是 term dictionary 和 term index？</p>
<p>​        假设我们有很多个 term，比如：</p>
<p>​        <strong>Carla,Sara,Elin,Ada,Patty,Kate,Selena</strong></p>
<p>​        如果按照这样的顺序排列，找出某个特定的 term 一定很慢，因为 term 没有排序，需要全部过滤一遍才能找出特定的 term。排序之后就变成了：</p>
<p>​        <strong>Ada,Carla,Elin,Kate,Patty,Sara,Selena</strong></p>
<p>​        这样我们可以用二分查找的方式，比全遍历更快地找出目标的 term。这个就是 term dictionary。有了 term dictionary 之后，可以用 logN 次磁盘查找得到目标。但是磁盘的随机读操作仍然是非常昂贵的（一次 random access 大概需要 10ms 的时间）。所以尽量少的读磁盘，有必要把一些数据缓存到内存里。但是整个 term dictionary 本身又太大了，无法完整地放到内存里。于是就有了 term index。term index 有点像一本字典的大的章节表。比如：</p>
<p>​        如果所有的 term 都是英文字符的话，可能这个 term index 就真的是 26 个英文字符表构成的了。但是实际的情况是，term 未必都是英文字符，term 可以是任意的 byte 数组。而且 26 个英文字符也未必是每一个字符都有均等的 term，比如 x 字符开头的 term 可能一个都没有，而 s 开头的 term 又特别多。实际的 term index 是一棵 trie 树：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/trie_tree.png" alt></p>
<p>​        例子是一个包含 “A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, 和 “inn” 的 trie 树。这棵树不会包含所有的 term，它包含的是 term 的一些前缀。通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。再加上一些压缩技术（搜索 Lucene Finite State Transducers） term index 的尺寸可以只有所有 term 的尺寸的几十分之一，使得用内存缓存整个 term index 变成可能。整体上来说就是这样的效果。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_index_structure1.png" alt></p>
<p>​        现在我们可以回答“为什么 Elasticsearch/Lucene 检索可以比 mysql 快了。Mysql 只有 term dictionary 这一层，是以 b-tree 排序的方式存储在磁盘上的。检索一个 term 需要若干次的 random access 的磁盘操作。而 Lucene 在 term dictionary 的基础上添加了 term index 来加速检索，term index 以树的形式缓存在内存中。从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access 次数。</p>
<p>​        额外值得一提的两点是：term index 在内存中是以 FST（finite state transducers）的形式保存的，其特点是非常节省内存。Term dictionary 在磁盘上是以分 block 的方式保存的，一个 block 内部利用公共前缀压缩，比如都是 Ab 开头的单词就可以把 Ab 省去。这样 term dictionary 可以比 b-tree 更节约磁盘空间。</p>
<h4 id="如何联合索引查询？"><a href="#如何联合索引查询？" class="headerlink" title="如何联合索引查询？"></a>如何联合索引查询？</h4><p>​        所以给定查询过滤条件 age=18 的过程就是先从 term index 找到 18 在 term dictionary 的大概位置，然后再从 term dictionary 里精确地找到 18 这个 term，然后得到一个 posting list 或者一个指向 posting list 位置的指针。然后再查询 gender= 女 的过程也是类似的。最后得出 age=18 AND gender= 女 就是把两个 posting list 做一个“与”的合并。</p>
<p>​        这个理论上的“与”合并的操作可不容易。对于 mysql 来说，如果你给 age 和 gender 两个字段都建立了索引，查询的时候只会选择其中最 selective 的来用，然后另外一个条件是在遍历行的过程中在内存中计算之后过滤掉。那么要如何才能联合使用两个索引呢？有两种办法：</p>
<ul>
<li>使用 skip list 数据结构。同时遍历 gender 和 age 的 posting list，互相 skip；</li>
<li>使用 bitset 数据结构，对 gender 和 age 两个 filter 分别求出 bitset，对两个 bitset 做 AND 操作。</li>
</ul>
<p>PostgreSQL 从 8.4 版本开始支持通过 bitmap 联合使用两个索引，就是利用了 bitset 数据结构来做到的。当然一些商业的关系型数据库也支持类似的联合索引的功能。Elasticsearch 支持以上两种的联合索引方式，如果查询的 filter 缓存到了内存中（以 bitset 的形式），那么合并就是两个 bitset 的 AND。如果查询的 filter 没有缓存，那么就用 skip list 的方式去遍历两个 on disk 的 posting list。</p>
<p><strong>利用 Skip List 合并</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/skip_list.png" alt></p>
<p>​        以上是三个 posting list。我们现在需要把它们用 AND 的关系合并，得出 posting list 的交集。首先选择最短的 posting list，然后从小到大遍历。遍历的过程可以跳过一些元素，比如我们遍历到绿色的 13 的时候，就可以跳过蓝色的 3 了，因为 3 比 13 要小。</p>
<p>​        整个过程如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Next -&gt; <span class="number">2</span></span><br><span class="line">Advance(<span class="number">2</span>) -&gt; <span class="number">13</span></span><br><span class="line">Advance(<span class="number">13</span>) -&gt; <span class="number">13</span></span><br><span class="line">Already on <span class="number">13</span></span><br><span class="line">Advance(<span class="number">13</span>) -&gt; <span class="number">13</span> MATCH!!!</span><br><span class="line">Next -&gt; <span class="number">17</span></span><br><span class="line">Advance(<span class="number">17</span>) -&gt; <span class="number">22</span></span><br><span class="line">Advance(<span class="number">22</span>) -&gt; <span class="number">98</span></span><br><span class="line">Advance(<span class="number">98</span>) -&gt; <span class="number">98</span></span><br><span class="line">Advance(<span class="number">98</span>) -&gt; <span class="number">98</span> MATCH!!!</span><br></pre></td></tr></table></figure>

<p>​        最后得出的交集是 [13,98]，所需的时间比完整遍历三个 posting list 要快得多。但是前提是每个 list 需要指出 Advance 这个操作，快速移动指向的位置。</p>
<p>​        从概念上来说，对于一个很长的 posting list，比如：</p>
<p>​        [1,3,13,101,105,108,255,256,257]</p>
<p>​        我们可以把这个 list 分成三个 block：</p>
<p>​        [1,3,13] [101,105,108] [255,256,257]</p>
<p>​        然后可以构建出 skip list 的第二层：</p>
<p>​        [1,101,255]</p>
<p>​        1,101,255 分别指向自己对应的 block。这样就可以很快地跨 block 的移动指向位置了。</p>
<p>​        Lucene 自然会对这个 block 再次进行压缩。其压缩方式叫做 Frame Of Reference 编码。示例如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/frame_of_reference.png" alt></p>
<p>​        考虑到频繁出现的 term（所谓 low cardinality 的值），比如 gender 里的男或者女。如果有 1 百万个文档，那么性别为男的 posting list 里就会有 50 万个 int 值。用 Frame of Reference 编码进行压缩可以极大减少磁盘占用。这个优化对于减少索引尺寸有非常重要的意义。当然 mysql b-tree 里也有一个类似的 posting list 的东西，是未经过这样压缩的。</p>
<p>​        因为这个 Frame of Reference 的编码是有解压缩成本的。利用 skip list，除了跳过了遍历的成本，也跳过了解压缩这些压缩过的 block 的过程，从而节省了 cpu。</p>
<p><strong>利用 bitset 合并</strong></p>
<p>Bitset 是一种很直观的数据结构，对应 posting list 如：</p>
<p>[1,3,4,7,10]</p>
<p>对应的 bitset 就是：</p>
<p>[1,0,1,1,0,0,1,0,0,1]</p>
<p>每个文档按照文档 id 排序对应其中的一个 bit。Bitset 自身就有压缩的特点，其用一个 byte 就可以代表 8 个文档。所以 100 万个文档只需要 12.5 万个 byte。但是考虑到文档可能有数十亿之多，在内存里保存 bitset 仍然是很奢侈的事情。而且对于个每一个 filter 都要消耗一个 bitset，比如 age=18 缓存起来的话是一个 bitset，18&lt;=age&lt;25 是另外一个 filter 缓存起来也要一个 bitset。</p>
<p>所以秘诀就在于需要有一个数据结构：</p>
<ul>
<li>可以很压缩地保存上亿个 bit 代表对应的文档是否匹配 filter；</li>
<li>这个压缩的 bitset 仍然可以很快地进行 AND 和 OR 的逻辑操作。</li>
</ul>
<p>Lucene 使用的这个数据结构叫做 Roaring Bitmap。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/roaring_bitmap.png" alt></p>
<p>其压缩的思路其实很简单。与其保存 100 个 0，占用 100 个 bit。还不如保存 0 一次，然后声明这个 0 重复了 100 遍。</p>
<p>这两种合并使用索引的方式都有其用途。Elasticsearch 对其性能有详细的对比（<a href="https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps" target="_blank" rel="noopener"> https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps </a>）。简单的结论是：因为 Frame of Reference 编码是如此高效，对于简单的相等条件的过滤缓存成纯内存的 bitset 还不如需要访问磁盘的 skip list 的方式要快。</p>
<h4 id="如何减少文档数？"><a href="#如何减少文档数？" class="headerlink" title="如何减少文档数？"></a>如何减少文档数？</h4><p>一种常见的压缩存储时间序列的方式是把多个数据点合并成一行。Opentsdb 支持海量数据的一个绝招就是定期把很多行数据合并成一行，这个过程叫 compaction。类似的 vivdcortext 使用 mysql 存储的时候，也把一分钟的很多数据点合并存储到 mysql 的一行里以减少行数。</p>
<p>这个过程可以示例如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_doc_compress.png" alt></p>
<p>可以看到，行变成了列了。每一列可以代表这一分钟内一秒的数据。</p>
<p>Elasticsearch有一个功能可以实现类似的优化效果，那就是Nested Document。我们可以把一段时间的很多个数据点打包存储到一个父文档里，变成其嵌套的子文档。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;timestamp:12:05:01, idc:sz, value1:10,value2:11&#125;</span><br><span class="line">&#123;timestamp:12:05:02, idc:sz, value1:9,value2:9&#125;</span><br><span class="line">&#123;timestamp:12:05:02, idc:sz, value1:18,value:17&#125;</span><br></pre></td></tr></table></figure>

<p>可以打包成：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    max_timestamp:12:05:02, min_timestamp: 1205:01, idc:sz,</span><br><span class="line">    records: [</span><br><span class="line">        &#123;timestamp:12:05:01, value1:10, value2:11&#125;</span><br><span class="line">    		&#123;timestamp:12:05:02, value1:9, value2:9&#125;</span><br><span class="line">    		&#123;timestamp:12:05:02, value1:18, value:17&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以把数据点公共的维度字段上移到父文档里，而不用在每个子文档里重复存储，从而减少索引的尺寸。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es_doc_compress1.png" alt></p>
<p>在存储的时候，无论父文档还是子文档，对于 Lucene 来说都是文档，都会有文档 Id。但是对于嵌套文档来说，可以保存起子文档和父文档的文档 id 是连续的，而且父文档总是最后一个。有这样一个排序性作为保障，那么有一个所有父文档的 posting list 就可以跟踪所有的父子关系。也可以很容易地在父子文档 id 之间做转换。把父子关系也理解为一个 filter，那么查询时检索的时候不过是又 AND 了另外一个 filter 而已。前面我们已经看到了 Elasticsearch 可以非常高效地处理多 filter 的情况，充分利用底层的索引。</p>
<p>使用了嵌套文档之后，对于 term 的 posting list 只需要保存父文档的 doc id 就可以了，可以比保存所有的数据点的 doc id 要少很多。如果我们可以在一个父文档里塞入 50 个嵌套文档，那么 posting list 可以变成之前的 1/50。</p>
<h3 id="es-写数据过程"><a href="#es-写数据过程" class="headerlink" title="es 写数据过程"></a>es 写数据过程</h3><ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li>
<li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code>。</li>
<li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es-write.png" alt></p>
<h3 id="es-读数据过程"><a href="#es-读数据过程" class="headerlink" title="es 读数据过程"></a>es 读数据过程</h3><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p>
<ul>
<li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 返回 document 给客户端。</li>
</ul>
<h3 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h3><p>es 最强大的是做全文检索，就是比如你有三条数据：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">java真好玩儿啊</span></span><br><span class="line"><span class="keyword">java好难学啊</span></span><br><span class="line"><span class="keyword">j2ee特别牛</span></span><br></pre></td></tr></table></figure>

<p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code>的 <code>document</code> 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</p>
<ul>
<li>客户端发送请求到一个 <code>coordinate node</code>。</li>
<li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>，都可以。</li>
<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li>
</ul>
<blockquote>
<p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>
</blockquote>
<h3 id="写数据底层原理"><a href="#写数据底层原理" class="headerlink" title="写数据底层原理"></a>写数据底层原理</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es-write-detail.png" alt></p>
<p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p>
<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 <code>refresh</code> 到一个新的 <code>segment file</code> 中，但是此时数据不是直接进入 <code>segment file</code> 磁盘文件，而是先进入 <code>os cache</code> 。这个过程就是 <code>refresh</code>。</p>
<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个<strong>新的</strong> <code>segment file</code>，每秒钟会产生一个<strong>新的磁盘文件</strong> <code>segment file</code>，这个 <code>segment file</code> 中就存储最近 1 秒内 buffer 中写入的数据。</p>
<p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>
<p>操作系统里面，磁盘文件其实都有一个东西，叫做 <code>os cache</code> <a href="http://lday.me/2019/09/09/0023_linux_page_cache_and_buffer_cache/" target="_blank" rel="noopener">又称page cache</a>，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 <code>os cache</code>，先进入操作系统级别的一个内存缓存中去。只要 <code>buffer</code> 中的数据被 refresh 操作刷入 <code>os cache</code>中，这个数据就可以被搜索到了。</p>
<p>为什么叫 es 是<strong>准实时</strong>的？ <code>NRT</code>，全称 <code>near real-time</code>。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 <code>restful api</code> 或者 <code>java api</code>，<strong>手动</strong>执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 <code>os cache</code>中，让数据立马就可以被搜索到。只要数据被输入 <code>os cache</code> 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p>
<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 <code>buffer</code> 数据写入一个又一个新的 <code>segment file</code> 中去，每次 <code>refresh</code> 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 <code>commit</code> 操作。</p>
<p>commit 操作发生第一步，就是将 buffer 中现有数据 <code>refresh</code> 到 <code>os cache</code> 中去，清空 buffer。然后，将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 <code>segment file</code>，同时强行将 <code>os cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘文件中去。最后<strong>清空</strong> 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>
<p>这个 commit 操作叫做 <code>flush</code>。默认 30 分钟自动执行一次 <code>flush</code>，但如果 translog 过大，也会触发 <code>flush</code>。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>
<p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 <code>translog</code> 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>
<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会<strong>丢失</strong> 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 <code>fsync</code> 到磁盘，但是性能会差很多。</p>
<p>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的<strong>数据丢失</strong>。</p>
<p><strong>总结一下</strong>，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p>
<blockquote>
<p>数据写入 segment file 之后，同时就建立好了倒排索引。</p>
</blockquote>
<h3 id="删除-更新数据底层原理"><a href="#删除-更新数据底层原理" class="headerlink" title="删除/更新数据底层原理"></a>删除/更新数据底层原理</h3><p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p>
<p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p>
<p>buffer 每 refresh 一次，就会产生一个 <code>segment file</code>，所以默认情况下是 1 秒钟一个 <code>segment file</code>，这样下来 <code>segment file</code> 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code>，标识所有新的 <code>segment file</code>，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code>。</p>
<h3 id="es-在数据量很大的情况下（数十亿级别）如何提高查询效率"><a href="#es-在数据量很大的情况下（数十亿级别）如何提高查询效率" class="headerlink" title="es 在数据量很大的情况下（数十亿级别）如何提高查询效率"></a>es 在数据量很大的情况下（数十亿级别）如何提高查询效率</h3><h3 id="性能优化的杀手锏——filesystem-cache"><a href="#性能优化的杀手锏——filesystem-cache" class="headerlink" title="性能优化的杀手锏——filesystem cache"></a>性能优化的杀手锏——filesystem cache</h3><p>你往 es 里写的数据，实际上都写到磁盘文件里去了，<strong>查询的时候</strong>，操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/es/es-search-process.png" alt></p>
<p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code>，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code>索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p>
<p>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1秒、5秒、10秒。但如果是走 <code>filesystem cache</code>，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p>
<p>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 <code>64 * 3 = 192G</code>。每台机器给 es jvm heap 是 <code>32G</code>，那么剩下来留给 <code>filesystem cache</code> 的就是每台机器才 <code>32G</code>，总共集群里给 <code>filesystem cache</code> 的就是 <code>32 * 3 = 96G</code> 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 <code>1T</code> 的磁盘容量，es 数据量是 <code>1T</code>，那么每台机器的数据量是 <code>300G</code>。这样性能好吗？ <code>filesystem cache</code> 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</p>
<p>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p>
<p>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要<strong>用来搜索的那些索引</strong>，如果内存留给 <code>filesystem cache</code> 的是 100G，那么你就将索引数据控制在 <code>100G</code> 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p>
<p>比如说你现在有一行数据。<code>id,name,age ....</code> 30 个字段。但是你现在搜索，只需要根据 <code>id,name,age</code> 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 <code>90%</code> 的数据是不用来搜索的，结果硬是占据了 es 机器上的 <code>filesystem cache</code> 的空间，单条数据的数据量越大，就会导致 <code>filesystem cahce</code> 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的<strong>少数几个字段</strong>就可以了，比如说就写入 es <code>id,name,age</code> 三个字段，然后你可以把其他的字段数据存在 mysql/hbase 里，我们一般是建议用 <code>es + hbase</code> 这么一个架构。</p>
<p>hbase 的特点是<strong>适用于海量数据的在线存储</strong>，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 <code>doc id</code>，然后根据 <code>doc id</code> 到 hbase 里去查询每个 <code>doc id</code> 对应的<strong>完整的数据</strong>，给查出来，再返回给前端。</p>
<p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</p>
<h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 <code>filesystem cache</code> 一倍，比如说你写入一台机器 60G 数据，结果 <code>filesystem cache</code> 就 30G，还是有 30G 数据留在了磁盘上。</p>
<p>其实可以做<strong>数据预热</strong>。</p>
<p>举个例子，拿微博来说，你可以把一些大V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 <code>filesystem cache</code> 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</p>
<p>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 <code>filesystem cache</code> 里去。</p>
<p>对于那些你觉得比较热的、经常会有人访问的数据，最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p>
<h3 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h3><p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让他们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p>
<p>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 <code>filesystem cache</code> 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</p>
<h3 id="document-模型设计"><a href="#document-模型设计" class="headerlink" title="document 模型设计"></a>document 模型设计</h3><p>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</p>
<p>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p>
<p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p>
<h3 id="分页性能优化"><a href="#分页性能优化" class="headerlink" title="分页性能优化"></a>分页性能优化</h3><p>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>
<p>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你<strong>必须</strong>得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</p>
<p>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</p>
<p>有什么解决方案吗？</p>
<h4 id="不允许深度分页（默认深度分页性能很差）"><a href="#不允许深度分页（默认深度分页性能很差）" class="headerlink" title="不允许深度分页（默认深度分页性能很差）"></a>不允许深度分页（默认深度分页性能很差）</h4><p>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</p>
<h4 id="类似于-app-里的推荐商品不断下拉出来一页一页的"><a href="#类似于-app-里的推荐商品不断下拉出来一页一页的" class="headerlink" title="类似于 app 里的推荐商品不断下拉出来一页一页的"></a>类似于 app 里的推荐商品不断下拉出来一页一页的</h4><p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code>，关于如何使用，自行上网搜索。</p>
<p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p>
<p>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，<strong>不能随意跳到任何一页的场景</strong>。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</p>
<p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p>
<p>除了用 <code>scroll api</code>，你也可以用 <code>search_after</code> 来做，<code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>
]]></content>
      <categories>
        <category>Es</category>
      </categories>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2020/03/16/WebSocket/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是WebSocket呢？"><a href="#什么是WebSocket呢？" class="headerlink" title="什么是WebSocket呢？"></a>什么是WebSocket呢？</h2><p>WebSocket是HTML5新增的一种通信协议，目标主流的浏览器都支持这个协议，比如Google的Chrome、Apple的Safari、Mozala的Firefox、Microsoft的IE等。对WebSocket协议支持最早的当属Chrome浏览器，从Chrome12开始就已经开始支持，随着协议草案不断完善，各个浏览器对协议的实现也在不停的更新。</p><a id="more"></a>
<h2 id="为什么会引入WebSocket协议呢？"><a href="#为什么会引入WebSocket协议呢？" class="headerlink" title="为什么会引入WebSocket协议呢？"></a>为什么会引入WebSocket协议呢？</h2><p>浏览器已经支持HTTP协议了，为什么还要开发一种新的WebSocket协议呢？因为HTTP协议是一种单向的网络协议，在建立连接后只允许浏览器或用户代理(<code>UserAgent</code>)向Web服务器发出请求资源后，Web服务器才能返回相应的资源数据。而Web服务器是不能够主动推送数据给浏览器的，HTTP设计之初的考虑到安全问题，如果Web服务器能够主动的推送数据给浏览器，那么浏览器就太容易受到攻击，一些广告商也会主动的将广告信息在不经意间强行推送给用户，这不能不说是一个灾难。但是单向的HTTP协议给现代的网站和Web应用程序却带来了许多问题。加入要开发一个基于Web的应用程序去获取当前Web服务器的实时数据的话，比如股票的实时行情，火车票的剩余票数等，这个时候就需要浏览器与Web服务器之间反复的进行HTTP通信，浏览器需要不断地发送请求去获取实时数据。</p>
<h2 id="实时获取Web服务器资源的方式有哪几种呢？"><a href="#实时获取Web服务器资源的方式有哪几种呢？" class="headerlink" title="实时获取Web服务器资源的方式有哪几种呢？"></a>实时获取Web服务器资源的方式有哪几种呢？</h2><p>那么在还没有WebSocket协议之前，有哪几种方式可以实时的获取Web服务器上的资源数据呢？</p>
<ol>
<li>短轮询<code>Polling</code></li>
</ol>
<p>Polling的方式是通过浏览器定时向Web服务器发送HTTP请求，Web服务器接收到请求后会将最新的数据返还给浏览器。浏览器得到数据后将其渲染显示，然后再定期的重复这一过程。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/websocket.png" alt></p>
<p>Polling的方式虽然能够满足实时的需求，但存在一定的问题，比如在某段时间内Web服务器没有数据更新呢，此时浏览器仍然需要定时发送请求过来询问，Web服务器会将以前的老数据再次传送过去，浏览器将这些没有变化的数据又渲染显示出来。<strong>这样既浪费了网络带宽，又浪费了CPU的利用利率。</strong>如果将浏览器发送请求的时间周期调大一些，虽然可以缓解这一问题，但如果在Web服务器上数据更新很快时，又将无法保证Web应用程序获取数据的实时性。</p>
<p>针对这种情况，Polling做出改进而衍生出来Long Polling。</p>
<ol start="2">
<li>长轮询<code>Long Polling</code> </li>
</ol>
<p>Long Polling的操作是这样的：浏览器发送请求到Web服务器时，Web服务器可以做两件事情。第一件事是如果服务器数据更新就会立即将数据发回给浏览器，浏览器接收到数据后再理解发送请求给Web服务器。第二件事是如果服务器没有数据更新，此时与Polling不同的是Web服务器不会立即发送回应信息给浏览器，而会见这个请求保持住，等到有数据更新时，再来响应这个请求。当然，如果服务器的数据长期没有更新的话，一段时间后，这些请求就会超时，浏览器将会收到超时消息，当浏览器收到超时消息又会立即发送一个新的请求给Web服务器，然后依次循环这个过程。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/websocket1.png" alt></p>
<p>Long Polling的方式虽然在某种程度上减小了网络带宽和CPU的利用率等问题，但仍存在缺陷，比如Web服务器的数据更新速度较快，当Web服务器在传送一个数据包给浏览器后，必须等待浏览器的下一个请求的到来才能传递第二给更新的数据包给浏览器。这样的话，浏览器显示的实时数据最快的时间也就是2 x RTT(往返时间)。另外，由于HTTP数据包的头部数据量往往会很大，一般有400多字节，但是真正被服务器使用的却很少，有时只有10字节左右，这样的数据包在网络上周期性的传输，难免对网络带宽又是一种浪费。</p>
<p>实际上Long Polling长轮询的底层实现是在服务器的程序中加入一个死循环，在循环中检测数据的变化，当发现有数据时会立即将其输出给浏览器并断开连接，浏览器收到数据后会再次发起请求进入下一个周期。</p>
<p><strong>长轮询的弊端是服务器长时间连接会消耗服务器资源，另外返回的数据的顺序无法保证，难以管理和维护。</strong></p>
<p>对于长轮询的处理，服务器并不会一直保持，通常的做法是会设置一个最大时限，可以通过心跳包的方式，设置多少秒之后没有接收到心跳包就关闭当前连接。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
</blockquote>
<p>通过以上的分析可知，要想在浏览器上支持双向通信而且协议的头部又不是那么的庞大，不得不采用新的协议，WebSocket也就是为了解决这个问题而设计诞生的。</p>
<h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>WebSocket协议是一种双向的通信协议，它建立在TCP之上，同HTTP一样是通过TCP来传递数据的，不过它与HTTP最大的不同点在于：</p>
<ol>
<li><p>WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和浏览器之间都能主动地向对象发送或接收数据，这就像Socket一样，只是与之不同的是，WebSocket是一种建立在Web基础上的简单模拟Socket的协议。</p>
</li>
<li><p>WebSocket需要通过握手建立连接，类似于TCP也需要客户端和服务端进行握手成功后才能互相通信。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/websocket2.png" alt></p>
</li>
</ol>
<p>这里简要的说明一下WebSocket握手的过程，当Web应用程序调用<code>new WebSocket(url)</code>接口时，浏览器就会开始与对应URL地址的WebSocket服务器建立握手的连接。具体的过程是这样的：</p>
<ol>
<li>首先，浏览器与WebSocket服务器之间通过TCP的三次握手建立连接，如果连接建立失败则后续流程将不再执行，此时Web应用程序将会收到错误消息通知。</li>
<li>当TCP连接建立成功后，浏览器会通过HTTP发送WebSocket所支持的版本号、协议的字版本号、原始地址、主机地址等一系列字段给WebSocket服务器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/<span class="number">1.1</span>  </span><br><span class="line">Host: server.example.com  </span><br><span class="line">Upgrade: websocket  </span><br><span class="line">Connection: Upgrade  </span><br><span class="line">Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==  </span><br><span class="line">Origin: http:<span class="comment">//example.com  </span></span><br><span class="line">Sec-WebSocket-Protocol: chat,superchat  </span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br></pre></td></tr></table></figure>

<p>这里需要重点关注的是<code>Sec-WebSocket-Key</code>这个字段，它又称为“梦幻字符串”也是一个密钥，其值采用<code>base64</code>编码的随机16字节长的字符序列，通过这个密钥服务器才能解码辨认是否为WebSocket握手请求，如果比对辨认成功则认为此协议是WebSocket协议，否则则认为是普通的HTTP协议。</p>
<ol start="3">
<li>当WebSocket服务器接收到浏览器发送过来的握手请求后，如果数据包的数据以及格式正确、客户端和服务器的协议版本号匹配的话，就会接受本次握手连接，并给出相应的数据回复，同时回复的数据包也会采用HTTP协议进行传输。</li>
</ol>
<p>例如：握手响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols  </span><br><span class="line">Upgrade: websocket  </span><br><span class="line">Connection: Upgrade  </span><br><span class="line">Sec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  </span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<p>在响应头中同样存在的一个“梦幻字段”，不过它的名字叫做<code>Sec-WebSocket-Accept</code>，同样也是一个密钥，不同的是这个字符串是要让客户端辨认，当客户端拿到自动解码后，会辨认是否是一个WebSocket握手响应。</p>
<ol start="4">
<li>当浏览器接收到WebSocket服务器回复的数据包后，如果数据包内容、格式正确的话，就表示本次连接建立成功，浏览器会触发<code>onopen</code>消息，此时Web开发人员就可以在此通过WebSocket接口中的<code>send</code>方法向WebSocket服务器发送数据了。否则握手建立失败，Web应用程序将收到<code>onerror</code>的消息，并能够知道握手连接失败的原因。</li>
</ol>
<p>简单来说WebSocket的操作流程是：客户端首先向服务器发起一次特殊的HTTP请求，服务器接收后开始辨认请求头如果是客户端的请求则开始进行普通的TCP三次握手建立建立，否则将会按照普通的HTTP请求进行处理。</p>
<p>WebSocket提供了两种数据传输，一种是文本格式的数据，另一种则是二进制格式的数据。</p>
<h2 id="WebSocket与HTTP和TCP有什么关系呢？"><a href="#WebSocket与HTTP和TCP有什么关系呢？" class="headerlink" title="WebSocket与HTTP和TCP有什么关系呢？"></a>WebSocket与HTTP和TCP有什么关系呢？</h2><p>了解完WebSocket协议的工作原理后，需要弄清楚一点的是WebSocket与TCP和HTTP之间的关系是什么样子的呢？</p>
<p>WebSocket与HTTP协议一样都是基于TCP的，所以它们都是可靠的协议，Web开发者调用WebSocket的<code>send</code>方法，在浏览器的实现最终都是通过TCP的接口进行传输的。</p>
<p>WebSocket和HTTP协议一样都属于应用层的协议，WebSocket在建立握手连接时，数据是通过HTTP协议传输的，因此会采用一部分HTTP的数据包的字段。但是在建立连接之后，真正的数据传输阶段就不需要HTTP参与了。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/websocket3.png" alt></p>
<h2 id="http和websocket的长连接区别"><a href="#http和websocket的长连接区别" class="headerlink" title="http和websocket的长连接区别"></a>http和websocket的长连接区别</h2><p>HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。这种长连接是一种“伪链接”</p>
<p>websocket的长连接，是一个真的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。</p>
<p>keep-alive双方并没有建立真正的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。</p>
<h2 id="WebSocket优点"><a href="#WebSocket优点" class="headerlink" title="WebSocket优点"></a>WebSocket优点</h2><ul>
<li><p>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p>
</li>
<li><p>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</p>
</li>
<li><p>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p>
</li>
<li><p>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</p>
</li>
<li><p>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</p>
</li>
<li><p>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>webSocket</category>
      </categories>
  </entry>
  <entry>
    <title>Netty基本知识</title>
    <url>/2020/03/15/Netty%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-Netty-是什么？"><a href="#1-Netty-是什么？" class="headerlink" title="1.Netty 是什么？"></a>1.Netty 是什么？</h2><p>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty是基于nio的，它封装了jdk的nio，让我们使用起来更加方法灵活。</p><h2 id="2-Netty-的特点是什么？"><a href="#2-Netty-的特点是什么？" class="headerlink" title="2.Netty 的特点是什么？"></a>2.Netty 的特点是什么？</h2><ul>
<li>高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。</li>
<li>传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li>封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。</li>
</ul><a id="more"></a>

<h2 id="3-Netty-的优势有哪些？"><a href="#3-Netty-的优势有哪些？" class="headerlink" title="3.Netty 的优势有哪些？"></a>3.Netty 的优势有哪些？</h2><ul>
<li>使用简单：封装了 NIO 的很多细节，使用更简单。</li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议。</li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。</li>
<li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。</li>
<li>稳定：Netty 修复了已经发现的所有 NIO 的 bug，让开发人员可以专注于业务本身。</li>
<li>社区活跃：Netty 是活跃的开源项目，版本迭代周期短，bug 修复速度快。</li>
</ul>
<h2 id="4-Netty-的应用场景有哪些？"><a href="#4-Netty-的应用场景有哪些？" class="headerlink" title="4.Netty 的应用场景有哪些？"></a>4.Netty 的应用场景有哪些？</h2><p>典型的应用有：阿里分布式服务框架 Dubbo，默认使用 Netty 作为基础通信组件，还有 RocketMQ 也是使用 Netty 作为通讯的基础。</p>
<h2 id="5-Netty-高性能表现在哪些方面？"><a href="#5-Netty-高性能表现在哪些方面？" class="headerlink" title="5.Netty 高性能表现在哪些方面？"></a>5.Netty 高性能表现在哪些方面？</h2><ul>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。</li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。</li>
<li>串形化处理读写：避免使用锁带来的性能开销。</li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h2 id="6-BIO、NIO和AIO的区别？"><a href="#6-BIO、NIO和AIO的区别？" class="headerlink" title="6.BIO、NIO和AIO的区别？"></a>6.BIO、NIO和AIO的区别？</h2><p>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p>
<p>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p>
<p>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p>
<p>AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</p>
<p>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。</p>
<p>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。</p>
<p>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</p>
<h2 id="7-NIO的组成？"><a href="#7-NIO的组成？" class="headerlink" title="7.NIO的组成？"></a>7.NIO的组成？</h2><p>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</p>
<p>flip方法 ：反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</p>
<p>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。</p>
<p>rewind方法 ：重绕此缓冲区，将position置为0</p>
<p>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</p>
<p>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！</p>
<p>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的</p>
<p>原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</p>
<p>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</p>
<p>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</p>
<p>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取</p>
<p>NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</p>
<h2 id="8-Netty的线程模型？"><a href="#8-Netty的线程模型？" class="headerlink" title="8.Netty的线程模型？"></a>8.Netty的线程模型？</h2><p><a href="https://www.jianshu.com/p/1ccbc6a348db" target="_blank" rel="noopener">Netty 那些事儿 ——— Reactor模式详解</a></p>
<p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。</p>
<p>单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</p>
<p>多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</p>
<p>主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；</p>
<h2 id="9-TCP-粘包-拆包的原因及解决方法？"><a href="#9-TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="9.TCP 粘包/拆包的原因及解决方法？"></a>9.TCP 粘包/拆包的原因及解决方法？</h2><p><strong>定义:</strong></p>
<p>TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。</p>
<p>客户端给服务端发送了两条消息<code>ABC</code>和<code>DEF</code>，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息<code>ABCDEF</code>，有可能是收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>。</p>
<p>上面所说的一次性收到了所有的消息<code>ABCDEF</code>，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫<code>粘包</code>。</p>
<p>上面说的后面那种收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了<code>半包</code>(半包不是说只收到了全包的一半，是说收到了全包的一部分)。</p>
<p>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p>
<p><strong>原因:</strong></p>
<p>其实从上面的定义，我们就可以大概知道产生的原因了。</p>
<p>粘包的主要原因：</p>
<ol>
<li><p>发送方每次写入数据 &lt; 套接字(Socket)缓冲区大小</p>
</li>
<li><p>接收方读取套接字(Socket)缓冲区数据不够及时</p>
</li>
</ol>
<p>半包的主要原因：</p>
<ol>
<li><p>发送方每次写入数据 &gt; 套接字(Socket)缓冲区大小</p>
</li>
<li><p>发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包</p>
</li>
</ol>
<p>其实我们可以换个角度看待问题：</p>
<ol>
<li><p>从<code>收发</code>的角度看，便是一个发送可能被多次接收，多个发送可能被一次接收。</p>
</li>
<li><p>从<code>传输</code>的角度看，便是一个发送可能占用多个传输包，多个发送可能共用一个传输包。</p>
</li>
</ol>
<p><strong>根本原因，其实是:</strong></p>
<blockquote>
<p>TCP 是流式协议，消息无边界。 (PS ：UDP 虽然也可以一次传输多个包或者多次传输一个包，但每个消息都是有边界的，因此不会有粘包和半包问题。)</p>
</blockquote>
<p>*<em>解决方法: *</em></p>
<ol>
<li><p>消息定长：FixedLengthFrameDecoder类</p>
</li>
<li><p>包尾增加特殊字符分割：</p>
<ul>
<li>行分隔符类：LineBasedFrameDecoder</li>
<li>自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
</ul>
</li>
</ol>
<p>​       将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</p>
<h2 id="10-什么是-Netty-的零拷贝？"><a href="#10-什么是-Netty-的零拷贝？" class="headerlink" title="10.什么是 Netty 的零拷贝？"></a>10.什么是 Netty 的零拷贝？</h2><p>在发送数据的时候，传统的实现方式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File.read(bytes)</span><br><span class="line">Socket.send(bytes)</span><br></pre></td></tr></table></figure>

<p>这种方式需要四次数据拷贝和四次上下文切换：</p>
<ol>
<li><p>数据从磁盘读取到内核的read buffer</p>
</li>
<li><p>数据从内核缓冲区拷贝到用户缓冲区</p>
</li>
<li><p>数据从用户缓冲区拷贝到内核的socket buffer</p>
</li>
<li><p>数据从内核的socket buffer拷贝到网卡接口的缓冲区</p>
</li>
</ol>
<p>明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p>
<ol>
<li>调用transferTo,数据从文件由DMA引擎拷贝到内核read buffer</li>
<li>接着DMA从内核read buffer将数据拷贝到网卡接口buffer</li>
</ol>
<p>DMA引擎：<strong>直接内存访问</strong>（<strong>D</strong>irect <strong>M</strong>emory <strong>A</strong>ccess，<strong>DMA</strong>）是<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中的一种内存访问技术。它允许某些<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6" target="_blank" rel="noopener">电脑</a>内部的硬件子系统（电脑外设），可以独立地直接读写系统<a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94" target="_blank" rel="noopener">内存</a>，而不需<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8" target="_blank" rel="noopener">中央处理器</a>（CPU）介入处理 。在同等程度的处理器负担下，DMA是一种快速的数据传送方式。</p>
<p><strong>Netty中的零拷贝:</strong></p>
<p>Netty中也用到了FileChannel.transferTo方法，该方法依赖于操作系统实现零拷贝。除此之外，在ByteBuf的实现上，Netty也提供了零拷贝的一些实现。</p>
<p>关于ByteBuffer，Netty提供了两个接口:</p>
<ol>
<li>ByteBuf</li>
<li>ByteBufHolder</li>
</ol>
<p>对于ByteBuf，Netty提供了多种实现：</p>
<ol>
<li>Heap ByteBuf:直接在堆内存分配</li>
<li>Direct ByteBuf：直接在内存区域分配而不是堆内存。直接将数据分配到内存空间，从而避免了数据的拷贝，实现了零拷贝。</li>
<li>CompositeByteBuf：组合Buffer</li>
</ol>
<p><strong>Netty 的零拷贝主要包含三个方面：</strong></p>
<ul>
<li>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</li>
<li>Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li>
</ul>
<h2 id="11-Netty-中有哪种重要组件？"><a href="#11-Netty-中有哪种重要组件？" class="headerlink" title="11.Netty 中有哪种重要组件？"></a>11.Netty 中有哪种重要组件？</h2><ul>
<li>Channel：Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 等。</li>
<li>EventLoop：主要是配合 Channel 处理 I/O 操作，用来处理连接的生命周期中所发生的事情。</li>
<li>ChannelFuture：Netty 框架中所有的 I/O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。</li>
<li>ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</li>
<li>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</li>
</ul>
<h2 id="12-Netty-发送消息有几种方式？"><a href="#12-Netty-发送消息有几种方式？" class="headerlink" title="12.Netty 发送消息有几种方式？"></a>12.Netty 发送消息有几种方式？</h2><p>Netty 有两种发送消息的方式：</p>
<ul>
<li>直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动；</li>
<li>写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从 ChannelPipeline 中的下一个 ChannelHandler 中移动。</li>
</ul>
<h2 id="13-默认情况-Netty-起多少线程？何时启动？"><a href="#13-默认情况-Netty-起多少线程？何时启动？" class="headerlink" title="13.默认情况 Netty 起多少线程？何时启动？"></a>13.默认情况 Netty 起多少线程？何时启动？</h2><p>Netty 默认是 CPU 处理器数的两倍，bind 完之后启动。</p>
<h2 id="14-了解哪几种序列化协议？"><a href="#14-了解哪几种序列化协议？" class="headerlink" title="14.了解哪几种序列化协议？"></a>14.了解哪几种序列化协议？</h2><p>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p>
<p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</p>
<p>Java默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差</p>
<p>XML，优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</p>
<p>JSON，是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</p>
<p>Fastjson，采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前java语言中最快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端</p>
<p>Thrift，不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案</p>
<p>Avro，Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</p>
<p>Protobuf，将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</p>
<p><strong>其它</strong></p>
<p>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可</p>
<p>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口</p>
<p>Message pack 一个高效的二进制序列化格式</p>
<p>Hessian 采用二进制协议的轻量级remoting onhttp工具</p>
<p>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）</p>
<h2 id="15-如何选择序列化协议？"><a href="#15-如何选择序列化协议？" class="headerlink" title="15.如何选择序列化协议？"></a>15.如何选择序列化协议？</h2><p>具体场景</p>
<p>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</p>
<p>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</p>
<p>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</p>
<p>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</p>
<p>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。</p>
<p>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</p>
<p>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</p>
<p>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</p>
<p>protobuf的数据类型有多种：bool、double、float、int32、int64、string、bytes、enum、message。protobuf的限定符：required: 必须赋值，不能为空、optional:字段可以赋值，也可以不赋值、repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</p>
<p>protobuf的基本规则：每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段；repeated表示的字段可以包含0个或多个数据；[1,15]之内的标识号在编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</p>
<p>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</p>
<p>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder = UserProto.User.newBuilder();builder.build()；</p>
<p>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类</p>
<p>将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</p>
<h2 id="16-Netty-支持哪些心跳类型设置？"><a href="#16-Netty-支持哪些心跳类型设置？" class="headerlink" title="16.Netty 支持哪些心跳类型设置？"></a>16.Netty 支持哪些心跳类型设置？</h2><ul>
<li>readerIdleTime：为读超时时间（即测试端一定时间内未接受到被测试端消息）。</li>
<li>writerIdleTime：为写超时时间（即测试端一定时间内向被测试端发送消息）。</li>
<li>allIdleTime：所有类型的超时时间。</li>
</ul>
<h2 id="17-Netty-和-Tomcat-的区别？"><a href="#17-Netty-和-Tomcat-的区别？" class="headerlink" title="17.Netty 和 Tomcat 的区别？"></a>17.Netty 和 Tomcat 的区别？</h2><ul>
<li>作用不同：Tomcat 是 Servlet 容器，可以视为 Web 服务器，而 Netty 是异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如TCP和UDP套接字服务器。</li>
<li>协议不同：Tomcat 是基于 http 协议的 Web 服务器，而 Netty 能通过编程自定义各种协议，因为 Netty 本身自己能编码/解码字节流，所有 Netty 可以实现，HTTP 服务器、FTP 服务器、UDP 服务器、RPC 服务器、WebSocket 服务器、Redis 的 Proxy 服务器、MySQL 的 Proxy 服务器等等。</li>
</ul>
<h2 id="18-NIOEventLoopGroup源码？"><a href="#18-NIOEventLoopGroup源码？" class="headerlink" title="18.NIOEventLoopGroup源码？"></a>18.NIOEventLoopGroup源码？</h2><p>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。</p>
<p>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法</p>
<p>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。</p>
<p>rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的selectionKey执行cancel。最后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</p>
<p>接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。</p>
<p>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</p>
<p>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。</p>
<p>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</p>
<p>内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。</p>
<p>ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开；方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象。</p>
<h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>
<h3 id="JDK原生NIO程序的问题"><a href="#JDK原生NIO程序的问题" class="headerlink" title="JDK原生NIO程序的问题"></a>JDK原生NIO程序的问题</h3><p>JDK原生也有一套网络应用程序API，但是存在一系列问题，主要如下：</p>
<ul>
<li>NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等</li>
<li>需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序</li>
<li>可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大</li>
<li>JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决</li>
</ul>
<h3 id="Netty的特点"><a href="#Netty的特点" class="headerlink" title="Netty的特点"></a>Netty的特点</h3><p>Netty的对JDK自带的NIO的API进行封装，解决上述问题，主要特点有：</p>
<ul>
<li>设计优雅 适用于各种传输类型的统一API - 阻塞和非阻塞Socket 基于灵活且可扩展的事件模型，可以清晰地分离关注点 高度可定制的线程模型 - 单线程，一个或多个线程池 真正的无连接数据报套接字支持（自3.1起）</li>
<li>使用方便 详细记录的Javadoc，用户指南和示例 没有其他依赖项，JDK 5（Netty 3.x）或6（Netty 4.x）就足够了</li>
<li>高性能 吞吐量更高，延迟更低 减少资源消耗 最小化不必要的内存复制</li>
<li>安全 完整的SSL / TLS和StartTLS支持</li>
<li>社区活跃，不断更新 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入</li>
</ul>
<h3 id="Netty常见使用场景"><a href="#Netty常见使用场景" class="headerlink" title="Netty常见使用场景"></a>Netty常见使用场景</h3><p>Netty常见的使用场景如下：</p>
<ul>
<li>互联网行业 在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</li>
<li>游戏行业 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈。非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信</li>
<li>大数据领域 经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现</li>
</ul>
<p><strong>Netty高性能设计</strong></p>
<p>Netty作为异步事件驱动的网络，高性能之处主要来自于其I/O模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据</p>
<p><strong>I/O模型</strong></p>
<p>用什么样的通道将数据发送给对方，BIO、NIO或者AIO，I/O模型在很大程度上决定了框架的性能</p>
<p><strong>阻塞I/O</strong></p>
<p>传统阻塞型I/O(BIO)可以用下图表示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty1.png" alt></p>
<p><strong>特点</strong></p>
<ul>
<li>每个请求都需要独立的线程完成数据read，业务处理，数据write的完整操作</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>
</ul>
<h4 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h4><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty2.png" alt></p>
<p>在I/O复用模型中，会用到select，这个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数 </p>
<p>Netty的非阻塞I/O的实现关键是基于I/O复用模型，这里用Selector对象表示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty3.png" alt></p>
<p>Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端连接。当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</p>
<p>由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁I/O阻塞导致的线程挂起，一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
<h4 id="基于buffer"><a href="#基于buffer" class="headerlink" title="基于buffer"></a>基于buffer</h4><p>传统的I/O是面向字节流或字符流的，以流式的方式顺序地从一个Stream 中读取一个或多个字节, 因此也就不能随意改变读取指针的位置。</p>
<p>在NIO中, 抛弃了传统的 I/O流, 而是引入了Channel和Buffer的概念. 在NIO中, 只能从Channel中读取数据到Buffer中或将数据 Buffer 中写入到 Channel。</p>
<p>基于buffer操作不像传统IO的顺序操作, NIO 中可以随意地读取任意位置的数据</p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，线程模型的不同，对性能的影响也非常大。</p>
<h4 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h4><p>通常，我们设计一个事件处理模型的程序有两种思路</p>
<ul>
<li>轮询方式 线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。</li>
<li>事件驱动方式 发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中<strong>观察者模式</strong>的思路。</li>
</ul>
<p>以GUI的逻辑处理为例，说明两种逻辑的不同：</p>
<ul>
<li>轮询方式 线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑</li>
<li>事件驱动方式 发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑</li>
</ul>
<p>这里借用O’Reilly 大神关于事件驱动模型解释图</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty4.png" alt></p>
<p>主要包括4个基本组件：</p>
<ul>
<li>事件队列（event queue）：接收事件的入口，存储待处理事件</li>
<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>
<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>
<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>
</ul>
<p>可以看出，相对传统轮询模式，事件驱动有如下优点：</p>
<ul>
<li>可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑</li>
<li>高性能，基于队列暂存事件，能方便并行异步处理事件</li>
</ul>
<p><strong>Reactor线程模型</strong></p>
<p>Reactor是反应堆的意思，Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一。</p>
<p><strong>Reactor模型中有2个关键组成：</strong></p>
<ul>
<li>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>
<li>Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty5.png" alt></p>
<p>取决于Reactor的数量和Hanndler线程数量的不同，Reactor模型有3个变种</p>
<ul>
<li>单Reactor单线程</li>
<li>单Reactor多线程</li>
<li>主从Reactor多线程</li>
</ul>
<p>可以这样理解，Reactor就是一个执行while (true) { selector.select(); …}循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。 </p>
<p>篇幅关系，这里不再具体展开Reactor特性、优缺点比较，有兴趣的读者可以参考我之前另外一篇文章：《理解高性能网络模型》<a href="https://www.jianshu.com/p/2965fca6bb8f" target="_blank" rel="noopener">https://www.jianshu.com/p/2965fca6bb8f</a></p>
<h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p>Netty主要<strong>基于主从Reactors多线程模型</strong>（如下图）做了一定的修改，其中主从Reactor多线程模型有多个Reactor：MainReactor和SubReactor：</p>
<ul>
<li>MainReactor负责客户端的连接请求，并将请求转交给SubReactor</li>
<li>SubReactor负责相应通道的IO读写请求</li>
<li>非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理</li>
</ul>
<p>这里引用Doug Lee大神的Reactor介绍：Scalable IO in Java里面关于主从Reactor多线程模型的图</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty6.png" alt></p>
<p>特别说明的是：虽然Netty的线程模型基于主从Reactor多线程，借用了MainReactor和SubReactor的结构，但是实际实现上，SubReactor和Worker线程在同一个线程池中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">server.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br></pre></td></tr></table></figure>

<p>上面代码中的bossGroup 和workerGroup是Bootstrap构造方法中传入的两个对象，这两个group均是线程池</p>
<ul>
<li>bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor，专门处理端口的accept事件，<strong>每个端口对应一个boss线程</strong></li>
<li>workerGroup线程池会被各个SubReactor和worker线程充分利用</li>
</ul>
<p><strong>异步处理</strong></p>
<p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>Netty中的I/O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture，调用者并不能立刻获得结果，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p>
<p>当future对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操，常见有如下操作：</p>
<ul>
<li>通过isDone方法来判断当前操作是否完成</li>
<li>通过isSuccess方法来判断已完成的当前操作是否成功</li>
<li>通过getCause方法来获取已完成的当前操作失败的原因</li>
<li>通过isCancelled方法来判断已完成的当前操作是否被取消</li>
<li>通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果future对象已完成，则理解通知指定的监听器</li>
</ul>
<p>例如下面的的代码中绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;        </span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;            </span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">": 端口["</span> + port + <span class="string">"]绑定成功!"</span>);        </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">    System.err.println(<span class="string">"端口["</span> + port + <span class="string">"]绑定失败!"</span>);        </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>相比传统阻塞I/O，执行I/O操作后线程会被阻塞住, 直到操作完成；异步处理的好处是不会造成线程阻塞，线程在I/O操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量。</p>
<h2 id="Netty架构设计"><a href="#Netty架构设计" class="headerlink" title="Netty架构设计"></a>Netty架构设计</h2><p>前面介绍完Netty相关一些理论介绍，下面从功能特性、模块组件、运作过程来介绍Netty的架构设计</p>
<h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty7.png" alt></p>
<ul>
<li>传输服务 支持BIO和NIO</li>
<li>容器集成 支持OSGI、JBossMC、Spring、Guice容器</li>
<li>协议支持 HTTP、Protobuf、二进制、文本、WebSocket等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议</li>
<li>Core核心 可扩展事件模型、通用通信API、支持零拷贝的ByteBuf缓冲对象</li>
</ul>
<h3 id="模块组件"><a href="#模块组件" class="headerlink" title="模块组件"></a>模块组件</h3><h4 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h4><p>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p>
<p><strong>Future、ChannelFuture</strong></p>
<p>正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Netty网络通信的组件，能够用于执行网络I/O操作。Channel为用户提供：</p>
<ul>
<li>当前网络连接的通道的状态（例如是否打开？是否已连接？）</li>
<li>网络连接的配置参数 （例如接收缓冲区大小）</li>
<li>提供异步的网络I/O操作(如建立连接，读写，绑定端口)，异步调用意味着任何I / O调用都将立即返回，并且不保证在调用结束时所请求的I / O操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I / O操作成功、失败或取消时回调通知调用方。</li>
<li>支持关联I/O操作与对应的处理程序</li>
</ul>
<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型</p>
<ul>
<li>NioSocketChannel，异步的客户端 TCP Socket 连接</li>
<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接</li>
<li>NioDatagramChannel，异步的 UDP 连接</li>
<li>NioSctpChannel，异步的客户端 Sctp 连接</li>
<li>NioSctpServerChannel，异步的 Sctp 服务器端连接 这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO.</li>
</ul>
<p><strong>Selector</strong></p>
<p>Netty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>
<h4 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h4><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：</p>
<ul>
<li>I/O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。</li>
<li>非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。</li>
</ul>
<p>两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。</p>
<h4 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h4><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。</p>
<p><strong>ChannelHandler</strong></p>
<p>ChannelHandler是一个接口，处理I / O事件或拦截I / O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。</p>
<p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<ul>
<li>ChannelInboundHandler用于处理入站I / O事件</li>
<li>ChannelOutboundHandler用于处理出站I / O操作</li>
</ul>
<p>或者使用以下适配器类：</p>
<ul>
<li>ChannelInboundHandlerAdapter用于处理入站I / O事件</li>
<li>ChannelOutboundHandlerAdapter用于处理出站I / O操作</li>
<li>ChannelDuplexHandler用于处理入站和出站事件</li>
</ul>
<h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象</p>
<p><strong>ChannelPipline</strong></p>
<p>保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。</p>
<p>下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了ChannelPipeline中ChannelHandler通常如何处理I/O事件。I/O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead（Object）和ChannelOutboundInvoker.write（Object））转发到其最近的处理程序。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty.png" alt></p>
<p>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。入站Handler处理程序通常处理由图底部的I / O线程生成的入站数据。通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。</p>
<p>出站事件由上下方向处理，如图右侧所示。出站Handler处理程序通常会生成或转换出站传输，例如write请求。I/O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。</p>
<p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty7.png" alt></p>
<p>一个 Channel 包含了一个 ChannelPipeline, 而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰。</p>
<h3 id="工作原理架构"><a href="#工作原理架构" class="headerlink" title="工作原理架构"></a>工作原理架构</h3><p>初始化并启动Netty服务端过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建mainReactor</span></span><br><span class="line">        NioEventLoopGroup boosGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// 创建工作线程组</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap </span><br><span class="line">                 <span class="comment">// 组装NioEventLoopGroup </span></span><br><span class="line">                .group(boosGroup, workerGroup)</span><br><span class="line">                 <span class="comment">// 设置channel类型为NIO类型</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 设置连接配置参数</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// 配置入站、出站事件handler</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 配置入站、出站事件channel</span></span><br><span class="line">                        ch.pipeline().addLast(...);</span><br><span class="line">                        ch.pipeline().addLast(...);</span><br><span class="line">                    &#125;</span><br><span class="line">    		&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">": 端口["</span> + port + <span class="string">"]绑定成功!"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">"端口["</span> + port + <span class="string">"]绑定失败!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本过程如下：</p>
<ul>
<li>1 初始化创建2个NioEventLoopGroup，其中boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I/O读写事件和业务逻辑</li>
<li>2 基于ServerBootstrap(服务端启动引导类)，配置EventLoopGroup、Channel类型，连接参数、配置入站、出站事件handler</li>
<li>3 绑定端口，开始工作</li>
</ul>
<p>结合上面的介绍的Netty Reactor模型，介绍服务端Netty的工作架构图：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/netty/netty8.png" alt></p>
<p>server端包含1个Boss NioEventLoopGroup和1个Worker NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1个事件循环线程。</p>
<p>每个Boss NioEventLoop循环执行的任务包含3步：</p>
<ul>
<li>1 轮询accept事件</li>
<li>2 处理accept I/O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上 </li>
<li>3 处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用eventloop.execute或schedule执行的任务，或者其它线程提交到该eventloop的任务。</li>
</ul>
<p>每个Worker NioEventLoop循环执行的任务包含3步：</p>
<ul>
<li>1 轮询read、write事件；</li>
<li>2 处I/O事件，即read、write事件，在NioSocketChannel可读、可写事件发生时进行处理</li>
<li>3 处理任务队列中的任务，runAllTasks。</li>
</ul>
<p>其中任务队列中的task有3种典型使用场景</p>
<ul>
<li>1 用户程序自定义的普通任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>2 非当前reactor线程调用channel的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景。最终的write会提交到任务队列中后被异步消费。</li>
<li>3 用户自定义定时任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>现在稳定推荐使用的主流版本还是Netty4，Netty5 中使用了 ForkJoinPool，增加了代码的复杂度，但是对性能的改善却不明显，所以这个版本不推荐使用，官网也没有提供下载链接。</p>
<p>Netty 入门门槛相对较高，其实是因为这方面的资料较少，并不是因为他有多难，大家其实都可以像搞透 Spring 一样搞透 Netty。在学习之前，建议先理解透整个框架原理结构，运行过程，可以少走很多弯路。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-cluster</title>
    <url>/2020/03/14/Redis-cluster/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>redis 如果要搞几个节点，每个节点存储一部分的数据，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code>，或者 <code>twemproxy</code>，都有。有一些 redis 中间件，你读写 redis 中间件，redis 中间件负责将你的数据分布式存储在多台机器上的 redis 实例中。redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。redis cluster 支撑 N 个 redis master node，每个 master node 都可以挂载多个 slave node。这样整个 redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><a id="more"></a>
<h2 id="redis-cluster-介绍"><a href="#redis-cluster-介绍" class="headerlink" title="redis cluster 介绍"></a>redis cluster 介绍</h2><ul>
<li>自动将数据进行分片，每个 master 上放一部分数据</li>
<li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li>
</ul>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<h3 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h3><h4 id="基本通信原理"><a href="#基本通信原理" class="headerlink" title="基本通信原理"></a>基本通信原理</h4><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>
<p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）几种存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code>。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis_cluster.png" alt></p>
<p>redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>
<p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p>
<p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p>
<ul>
<li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code>。</li>
<li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li>
</ul>
<h4 id="gossip-协议"><a href="#gossip-协议" class="headerlink" title="gossip 协议"></a>gossip 协议</h4><p>gossip 协议包含多种消息，包含 <code>ping</code>,<code>pong</code>,<code>meet</code>,<code>fail</code> 等等。</p>
<ul>
<li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">redis-trib.rb add-<span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>

<p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p>
<ul>
<li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</li>
<li>pong：返回 ping 和 meeet，包含自己的状态和其它信息，也用于信息广播和更新。</li>
<li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</li>
</ul>
<h4 id="ping-消息深入"><a href="#ping-消息深入" class="headerlink" title="ping 消息深入"></a>ping 消息深入</h4><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p>
<p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code>，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p>
<p>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息。</p>
<h3 id="分布式寻址算法"><a href="#分布式寻址算法" class="headerlink" title="分布式寻址算法"></a>分布式寻址算法</h3><ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<h4 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h4><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p>
<h4 id="一致性-hash-算法"><a href="#一致性-hash-算法" class="headerlink" title="一致性 hash 算法"></a>一致性 hash 算法</h4><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis_cluster1.png" alt></p>
<p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p>
<p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p>
<p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis_cluster2.png" alt></p>
<h4 id="redis-cluster-的-hash-slot-算法"><a href="#redis-cluster-的-hash-slot-算法" class="headerlink" title="redis cluster 的 hash slot 算法"></a>redis cluster 的 hash slot 算法</h4><p>redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p>
<p>redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p>
<p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis_cluster3.png" alt></p>
<h3 id="redis-cluster-的高可用与主备切换原理"><a href="#redis-cluster-的高可用与主备切换原理" class="headerlink" title="redis cluster 的高可用与主备切换原理"></a>redis cluster 的高可用与主备切换原理</h3><p>redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p>
<h4 id="判断节点宕机"><a href="#判断节点宕机" class="headerlink" title="判断节点宕机"></a>判断节点宕机</h4><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code>，<strong>主观宕机</strong>。如果多个节点都认为另外一个节点宕机了，那么就是 <code>fail</code>，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，sdown，odown。</p>
<p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 <code>pong</code>，那么就被认为 <code>pfail</code>。</p>
<p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中，<code>ping</code> 给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code>。</p>
<h4 id="从节点过滤"><a href="#从节点过滤" class="headerlink" title="从节点过滤"></a>从节点过滤</h4><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p>
<p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就<strong>没有资格</strong>切换成 <code>master</code>。</p>
<h4 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h4><p>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p>
<p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node<code>（N/2 + 1）</code>都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p>
<p>从节点执行主备切换，从节点切换为主节点。</p>
<h4 id="与哨兵比较"><a href="#与哨兵比较" class="headerlink" title="与哨兵比较"></a>与哨兵比较</h4><p>整个流程跟哨兵相比，非常类似，所以说，redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。</p>
<p>[分布式锁]<a href="https://cloud.tencent.com/developer/article/1476050" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1476050</a></p>
<h2 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h2><p>Redis 官方站这篇文章提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h3 id="怎么在单节点上实现分布式锁"><a href="#怎么在单节点上实现分布式锁" class="headerlink" title="怎么在单节点上实现分布式锁"></a>怎么在单节点上实现分布式锁</h3><blockquote>
<p>SET resource_name my_random_value NX PX 30000</p>
</blockquote>
<p>主要依靠上述命令，该命令仅当 Key 不存在时（NX保证）set 值，并且设置过期时间 3000ms （PX保证），值 my_random_value 必须是所有 client 和所有锁请求发生期间唯一的，释放锁的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>上述实现可以避免释放另一个client创建的锁，如果只有 del 命令的话，那么如果 client1 拿到 lock1 之后因为某些操作阻塞了很长时间，此时 Redis 端 lock1 已经过期了并且已经被重新分配给了 client2，那么 client1 此时再去释放这把锁就会造成 client2 原本获取到的锁被 client1 无故释放了，但现在为每个 client 分配一个 unique 的 string 值可以避免这个问题。至于如何去生成这个 unique string，方法很多随意选择一种就行了。</p>
<h3 id="Redlock-算法"><a href="#Redlock-算法" class="headerlink" title="Redlock 算法"></a>Redlock 算法</h3><p>算法很易懂，起 5 个 master 节点，分布在不同的机房尽量保证可用性。为了获得锁，client 会进行如下操作：</p>
<ol>
<li>得到当前的时间，微秒单位</li>
<li>尝试顺序地在 5 个实例上申请锁，当然需要使用相同的 key 和 random value，这里一个 client 需要合理设置与 master 节点沟通的 timeout 大小，避免长时间和一个 fail 了的节点浪费时间</li>
<li>当 client 在大于等于 3 个 master 上成功申请到锁的时候，且它会计算申请锁消耗了多少时间，这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了。</li>
<li>如果锁申请到了，那么锁真正的 lock validity time 应该是 origin（lock validity time） - 申请锁期间流逝的时间</li>
<li>如果 client 申请锁失败了，那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作，重置状态</li>
</ol>
<h3 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h3><p>如果一个 client 申请锁失败了，那么它需要稍等一会在重试避免多个 client 同时申请锁的情况，最好的情况是一个 client 需要几乎同时向 5 个 master 发起锁申请。另外就是如果 client 申请锁失败了它需要尽快在它曾经申请到锁的 master 上执行 unlock 操作，便于其他 client 获得这把锁，避免这些锁过期造成的时间浪费，当然如果这时候网络分区使得 client 无法联系上这些 master，那么这种浪费就是不得不付出的代价了。</p>
<h3 id="放锁"><a href="#放锁" class="headerlink" title="放锁"></a>放锁</h3><p>放锁操作很简单，就是依次释放所有节点上的锁就行了</p>
<h3 id="性能、崩溃恢复和-fsync"><a href="#性能、崩溃恢复和-fsync" class="headerlink" title="性能、崩溃恢复和 fsync"></a>性能、崩溃恢复和 fsync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redis实例的配置不进行任何持久化,集群中<span class="number">5</span>个实例 M1,M2,M3,M4,M5</span><br><span class="line">client A获得了M1,M2,M3实例的锁。</span><br><span class="line">此时M1宕机并重启。</span><br><span class="line">由于没有进行持久化，M1重启后不存在任何KEY</span><br><span class="line">client B获得M4,M5和重启后的M1中的锁。</span><br><span class="line">此时client A 和Client B 同时获得锁</span><br></pre></td></tr></table></figure>

<p>如果我们的节点没有持久化机制，client 从 5 个 master 中的 3 个处获得了锁，然后其中一个重启了，这是注意 <strong>整个环境中又出现了 3 个 master 可供另一个 client 申请同一把锁！</strong> 违反了互斥性。如果我们开启了 AOF 持久化那么情况会稍微好转一些，因为 Redis 的过期机制是语义层面实现的，所以在 server 挂了的时候时间依旧在流逝，重启之后锁状态不会受到污染。但是考虑断电之后呢，AOF部分命令没来得及刷回磁盘直接丢失了，除非我们配置刷回策略为 fsnyc = always，但这会损伤性能。解决这个问题的方法是，当一个节点重启之后，我们规定在 max TTL 期间它是不可用的，这样它就不会干扰原本已经申请到的锁，等到它 crash 前的那部分锁都过期了，环境不存在历史锁了，那么再把这个节点加进来正常工作。</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>cluster</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/03/14/Redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="redis-简介"><a href="#redis-简介" class="headerlink" title="redis 简介"></a>redis 简介</h3><p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><a id="more"></a>
<h3 id="为什么要用-redis-为什么要用缓存"><a href="#为什么要用-redis-为什么要用缓存" class="headerlink" title="为什么要用 redis/为什么要用缓存"></a>为什么要用 redis/为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis.png" alt></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis1.png" alt></p>
<h3 id="为什么要用-redis-而不用-map-guava-做缓存"><a href="#为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 redis 而不用 map/guava 做缓存?"></a>为什么要用 redis 而不用 map/guava 做缓存?</h3><blockquote>
<p>下面的内容来自 segmentfault 一位网友的提问，地址：<a href="https://segmentfault.com/q/1010000009106416" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009106416</a></p>
</blockquote>
<p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h3 id="redis-的线程模型"><a href="#redis-的线程模型" class="headerlink" title="redis 的线程模型"></a>redis 的线程模型</h3><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。</p>
<p>来看客户端与 redis 的一次通信过程：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis7.png" alt></p>
<p>要明白，通信是通过 socket 来完成的，不懂的同学可以先去看一看 socket 网络编程。</p>
<p>首先，redis 服务端进程初始化的时候，会将 server socket 的 <code>AE_READABLE</code> 事件与连接应答处理器关联。</p>
<p>客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</p>
<p>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 <code>AE_READABLE</code> 事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</p>
<p>这样便完成了一次通信。关于 Redis 的一次通信过程，推荐读者阅读《<a href="https://github.com/doocs/technical-books#database" target="_blank" rel="noopener">Redis 设计与实现——黄健宏</a>》进行系统学习。</p>
<h3 id="为啥-redis-单线程模型也能效率这么高？"><a href="#为啥-redis-单线程模型也能效率这么高？" class="headerlink" title="为啥 redis 单线程模型也能效率这么高？"></a>为啥 redis 单线程模型也能效率这么高？</h3><ul>
<li>纯内存操作。</li>
<li>核心是基于非阻塞的 IO 多路复用机制。</li>
<li>C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li>
<li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>
</ul>
<h3 id="redis-和-memcached-的区别"><a href="#redis-和-memcached-的区别" class="headerlink" title="redis 和 memcached 的区别"></a>redis 和 memcached 的区别</h3><p>对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！</p>
<ol>
<li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li>
</ol>
<blockquote>
<p>来自网络上的一张图，这里分享给大家！</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis2.png" alt></p>
<h3 id="redis-常见数据结构以及使用场景分析"><a href="#redis-常见数据结构以及使用场景分析" class="headerlink" title="redis 常见数据结构以及使用场景分析"></a>redis 常见数据结构以及使用场景分析</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h4><blockquote>
<p><strong>常用命令:</strong> set,get,decr,incr,mget 等。</p>
</blockquote>
<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p>
<h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><blockquote>
<p><strong>常用命令：</strong> hget,hset,hgetall 等。</p>
</blockquote>
<p>hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">  “id”: <span class="number">1</span>,</span><br><span class="line">  “name”: “SnailClimb”,</span><br><span class="line">  “age”: <span class="number">22</span>,</span><br><span class="line">  “location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><blockquote>
<p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p>
</blockquote>
<p>list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p>
<p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><blockquote>
<p><strong>常用命令：</strong> sadd,spop,smembers,sunion 等</p>
</blockquote>
<p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p>
<p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p>
<p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sinterstore</span> key1 key2 key3     将交集存在key1内</span><br></pre></td></tr></table></figure>

<h4 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h4><blockquote>
<p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p>
</blockquote>
<p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
<p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p>
<h3 id="redis-设置过期时间"><a href="#redis-设置过期时间" class="headerlink" title="redis 设置过期时间"></a>redis 设置过期时间</h3><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p>
<h3 id="redis-内存淘汰机制-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据"><a href="#redis-内存淘汰机制-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据" class="headerlink" title="redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)"></a>redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)</h3><p><strong>redis 提供 6种数据淘汰策略：</strong></p>
<ol>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li>
</ol>
<p><strong>备注： 关于 redis 设置过期时间以及内存淘汰机制，我这里只是简单的总结一下，后面会专门写一篇文章来总结！</strong></p>
<h3 id="redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复"><a href="#redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)"></a>redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>
<p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p><strong>补充内容：AOF 重写</strong></p>
<p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</p>
<p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作</p>
<p><strong>更多内容可以查看我的这篇文章：</strong></p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/Redis持久化.md" target="_blank" rel="noopener">Redis持久化</a></li>
</ul>
<h3 id="redis-事务"><a href="#redis-事务" class="headerlink" title="redis 事务"></a>redis 事务</h3><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p>
<p>补充内容：</p>
<blockquote>
<ol>
<li>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/452" target="_blank" rel="noopener">issue:关于Redis事务不是原子性问题</a> ）</li>
</ol>
</blockquote>
<h3 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h3><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作 mysql，半天查出来一个结果，耗时 600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？</p>
<p>缓存啊，折腾 600ms 查出来的结果，扔缓存里，一个 key 对应一个 value，下次再有人查，别走 mysql 折腾 600ms 了，直接从缓存里，通过一个 key 查出来一个 value，2ms 搞定。性能提升 300 倍。</p>
<p>就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。</p>
<h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p>mysql 这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql 单机支撑到 <code>2000QPS</code> 也开始容易报警了。</p>
<p>所以要是你有个系统，高峰期一秒钟过来的请求有 1万，那一个 mysql 单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放 mysql。缓存功能简单，说白了就是 <code>key-value</code> 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p>
<blockquote>
<p>缓存是走内存的，内存天然就支撑高并发。</p>
</blockquote>
<h3 id="用了缓存之后会有什么不良后果？"><a href="#用了缓存之后会有什么不良后果？" class="headerlink" title="用了缓存之后会有什么不良后果？"></a>用了缓存之后会有什么不良后果？</h3><p>常见的缓存问题有以下几个：</p>
<ul>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md" target="_blank" rel="noopener">缓存与数据库双写不一致</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md" target="_blank" rel="noopener">缓存雪崩、缓存穿透</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cas.md" target="_blank" rel="noopener">缓存并发竞争</a></li>
</ul>
<h3 id="缓存雪崩和缓存穿透问题解决方案"><a href="#缓存雪崩和缓存穿透问题解决方案" class="headerlink" title="缓存雪崩和缓存穿透问题解决方案"></a>缓存雪崩和缓存穿透问题解决方案</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h4><p><strong>什么是缓存雪崩？</strong></p>
<p>简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>有哪些解决办法？</strong></p>
<ul>
<li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li>
<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</li>
<li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis3.png" alt></p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h4><p><strong>什么是缓存穿透？</strong></p>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。下面用图片展示一下(这两张图片不是我画的，为了省事直接在网上找的，这里说明一下)：</p>
<p><strong>正常缓存处理流程：</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis4.png" alt></p>
<p><strong>缓存穿透情况处理流程：</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis5.png" alt></p>
<p>一般MySQL 默认的最大连接数在 150 左右，这个可以通过 <code>show variables like &#39;%max_connections%&#39;;</code>命令来查看。最大连接数一个还只是一个指标，cpu，内存，磁盘，网络等无力条件都是其运行指标，这些指标都会限制其并发能力！所以，一般 3000 个并发请求就能打死大部分数据库了。</p>
<p><strong>有哪些解决办法？</strong></p>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong> : 如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code>。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）布隆过滤器：</strong>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。总结一下就是下面这张图(这张图片不是我画的，为了省事直接在网上找的)：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis6.png" alt></p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
<h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<h3 id="如何保证缓存与数据库双写时的数据一致性"><a href="#如何保证缓存与数据库双写时的数据一致性" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性?"></a>如何保证缓存与数据库双写时的数据一致性?</h3><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p>
<ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>更新的时候，先删除缓存，然后更新数据库。</li>
</ul>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<ol>
<li><p>因为很多时候，缓存中放的并不是简单的从数据中取出来值，可能要进行一个状态的替换，一些数据的计算，还有可能要进行数据的组合等等。</p>
</li>
<li><p>二八法则，即20%的数据，占用了80%的访问量，这个更新的数据，可能是冷门数据，好久也访问不了不了一次，这样只会占用缓存内存。lazy思想，数据等你第一次要的时候再去加载，避免没必要的内存和时间浪费。</p>
</li>
</ol>
<h4 id="最初级的缓存不一致问题及解决方案"><a href="#最初级的缓存不一致问题及解决方案" class="headerlink" title="最初级的缓存不一致问题及解决方案"></a>最初级的缓存不一致问题及解决方案</h4><p>问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/redis/redis8.png" alt></p>
<p><strong>解决思路：</strong>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p>
<h4 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p>
<p><strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p>
<p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就<strong>可能会出现上述的数据库+缓存不一致的情况</strong>。</p>
<p><strong>解决方案如下：</strong></p>
<p>为了解决上面的并发读写问题，可以考虑将更新和读取操作进行串行化。</p>
<ol>
<li><p>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列里面去。</p>
</li>
<li><p>读取数据的时候，如果发现缓存中没有，那么将从数据库读取数据的操作和更新缓存的操作一起路由到同一个JVM内部的队列中去。</p>
</li>
<li><p>一个队列对应一个工作线程，然后线程从队列里面去取请求进行操作，然后一条一条的执行。</p>
</li>
</ol>
<p>这样就可以将同一个key的操作进行串行化，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新，此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p>
<p>这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>
<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>
<h3 id="高并发的场景下，该解决方案要注意的问题"><a href="#高并发的场景下，该解决方案要注意的问题" class="headerlink" title="高并发的场景下，该解决方案要注意的问题"></a>高并发的场景下，该解决方案要注意的问题</h3><ul>
<li>读请求长时阻塞</li>
</ul>
<p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p>
<p>该解决方案，最大的风险点在于说，<strong>可能数据更新很频繁</strong>，导致队列中积压了大量更新操作在里面，然后<strong>读请求会发生大量的超时</strong>，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p>
<p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要<strong>部署多个服务</strong>，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致<strong>读请求的长时阻塞</strong>。</p>
<p>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p>
<p><strong>如果一个内存队列中可能积压的更新操作特别多</strong>，那么你就要<strong>加机器</strong>，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p>
<p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p>
<p>我们来<strong>实际粗略测算一下</strong>。</p>
<p>如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。</p>
<p>经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。</p>
<ul>
<li>读请求并发量过高</li>
</ul>
<p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p>
<p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p>
<ul>
<li>多服务实例部署的请求路由</li>
</ul>
<p>可能这个服务部署了多个实例，那么必须<strong>保证</strong>说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器<strong>路由到相同的服务实例上</strong>。</p>
<p>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p>
<ul>
<li>热点商品的路由问题，导致请求的倾斜</li>
</ul>
<p>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql-Innodb中的事务隔离级别和锁的关系</title>
    <url>/2020/03/14/Mysql-Innodb%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一次封锁or两段锁？"><a href="#一次封锁or两段锁？" class="headerlink" title="一次封锁or两段锁？"></a>一次封锁or两段锁？</h2><p>因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）</p><a id="more"></a>

<ul>
<li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li>
<li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">事务</th>
<th align="left">加锁/解锁处理</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into test …..</td>
<td align="left">加insert对应的锁</td>
</tr>
<tr>
<td align="left">update test set…</td>
<td align="left">加update对应的锁</td>
</tr>
<tr>
<td align="left">delete from test ….</td>
<td align="left">加delete对应的锁</td>
</tr>
<tr>
<td align="left">commit;</td>
<td align="left">事务提交时，同时释放insert、update、delete对应的锁</td>
</tr>
</tbody></table>
<p>这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。</p>
<p>这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。</p>
<h2 id="事务中的加锁方式"><a href="#事务中的加锁方式" class="headerlink" title="事务中的加锁方式"></a>事务中的加锁方式</h2><h3 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h3><p>在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读（Dirty Read）</th>
<th align="left">不可重复读（NonRepeatable Read）</th>
<th align="left">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未提交读（Read uncommitted）</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">已提交读（Read committed）</td>
<td align="left">不可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可重复读（Repeatable read）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可串行化（Serializable ）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
</tr>
</tbody></table>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<p>Read Uncommitted这种级别，数据库一般都不会用，而且任何操作都不会加锁，这里就不讨论了。</p>
<h3 id="MySQL中锁的种类"><a href="#MySQL中锁的种类" class="headerlink" title="MySQL中锁的种类"></a>MySQL中锁的种类</h3><p>MySQL中锁的种类很多，有常见的表锁和行锁，也有新加入的Metadata Lock等等,表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。</p>
<p>行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。这里主要讨论的也就是行锁。</p>
<h3 id="Read-Committed（读取提交内容）"><a href="#Read-Committed（读取提交内容）" class="headerlink" title="Read Committed（读取提交内容）"></a>Read Committed（读取提交内容）</h3><p>在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。效果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL&gt; show create table class_teacher \G\</span><br><span class="line">Table: class_teacher</span><br><span class="line">Create Table: CREATE TABLE &#96;class_teacher&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;class_name&#96; varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  &#96;teacher_id&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_teacher_id&#96; (&#96;teacher_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;5 DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_unicode_ci</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line">MySQL&gt; select * from class_teacher;</span><br><span class="line">+----+--------------+------------+</span><br><span class="line">| id | class_name   | teacher_id |</span><br><span class="line">+----+--------------+------------+</span><br><span class="line">|  1 | 初三一班     |          1 |</span><br><span class="line">|  3 | 初二一班     |          2 |</span><br><span class="line">|  4 | 初二二班     |          2 |</span><br><span class="line">+----+--------------+------------+</span><br></pre></td></tr></table></figure>

<p>由于MySQL的InnoDB默认是使用的RR级别，所以我们先要将该session开启成RC级别，并且设置binlog的模式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> binlog_format = <span class="string">'ROW'</span>;（或者是MIXED）</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">update class_teacher set class_name=‘初三二班’ where teacher_id=1;</td>
<td align="left">update class_teacher set class_name=‘初三三班’ where teacher_id=1;</td>
</tr>
<tr>
<td align="left">commit;</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>为了防止并发过程中的修改冲突，事务A中MySQL给teacher_id=1的数据行加锁，并一直不commit（释放锁），那么事务B也就一直拿不到该行锁，wait直到超时。</p>
<p>这时我们要注意到，teacher_id是有索引的，如果是没有索引的class_name呢？update class_teacher set teacher_id=3 where class_name = ‘初三一班’; 那么MySQL会给整张表的所有数据行的加行锁。这里听起来有点不可思议，但是当sql运行的过程中，MySQL并不知道哪些数据行是 class_name = ‘初三一班’的（没有索引嘛），如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由MySQL Server层进行过滤。</p>
<p>但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。（参见《高性能MySQL》中文第三版p181）</p>
<p>这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。</p>
<h3 id="Repeatable-Read（可重读）"><a href="#Repeatable-Read（可重读）" class="headerlink" title="Repeatable Read（可重读）"></a>Repeatable Read（可重读）</h3><p>这是MySQL中InnoDB默认的隔离级别。我们姑且分“读”和“写”两个模块来讲解。</p>
<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>读就是可重读，可重读这个概念是一事务的多个实例在并发读取数据时，会看到同样的数据行，有点抽象，我们来看一下效果。</p>
<p>RC（不可重读）模式下的展现</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/innodb_lock1.png" alt></p>
<p>事务B修改id=1的数据提交之后，事务A同样的查询，后一次和前一次的结果不一样，这就是不可重读（重新读取产生的结果不一样）。这就很可能带来一些问题，那么我们来看看在RR级别中MySQL的表现：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/innodb_lock2.png" alt></p>
<p>我们注意到，当teacher_id=1时，事务A先做了一次读取，事务B中间修改了id=1的数据，并commit之后，事务A第二次读到的数据和第一次完全相同。所以说它是可重读的。那么MySQL是怎么做到的呢？这里姑且卖个关子，我们往下看。</p>
<h3 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h3><p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>
<p>所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p>
<p>上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。</p>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li>悲观锁</li>
</ul>
<p>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>
<ul>
<li>乐观锁</li>
</ul>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p>要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。</p>
<h3 id="MVCC在MySQL的InnoDB中的实现"><a href="#MVCC在MySQL的InnoDB中的实现" class="headerlink" title="MVCC在MySQL的InnoDB中的实现"></a>MVCC在MySQL的InnoDB中的实现</h3><p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p>
<ul>
<li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li>
<li>INSERT时，保存当前事务版本号为行的创建版本号</li>
<li>DELETE时，保存当前事务版本号为行的删除版本号</li>
<li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li>
</ul>
<p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p>
<p>我们不管从数据库方面的教课书中学到，还是从网络上看到，大都是上文中事务的四种隔离级别这一模块列出的意思，RR级别是可重复读的，但无法解决幻读，而只有在Serializable级别才能解决幻读。于是我就加了一个事务C来展示效果。在事务C中添加了一条teacher_id=1的数据commit，RR级别中应该会有幻读现象，事务A在查询teacher_id=1的数据时会读到事务C新加的数据。但是测试后发现，在MySQL中是不存在这种情况的，在事务C提交后，事务A还是不会读到这条数据。可见在MySQL的RR级别中，是解决了幻读的读问题的。参见下图</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/innodb_lock.png" alt></p>
<p>读问题解决了，根据MVCC的定义，并发提交数据时会出现冲突，那么冲突时如何解决呢？我们再来看看InnoDB中RR级别对于写数据的处理。</p>
<h3 id="“读”与“读”的区别"><a href="#“读”与“读”的区别" class="headerlink" title="“读”与“读”的区别"></a>“读”与“读”的区别</h3><p>可能有读者会疑惑，事务的隔离级别其实都是对于读数据的定义，但到了这里，就被拆成了读和写两个模块来讲解。这主要是因为MySQL中的读，和事务隔离级别中的读，是不一样的。</p>
<p>我们且看，在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p>
<p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p>
<ul>
<li>快照读：就是select<ul>
<li>select * from table ….;</li>
</ul>
</li>
<li>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert;</li>
<li>update ;</li>
<li>delete;</li>
</ul>
</li>
</ul>
<p>事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。</p>
<h3 id="写（”当前读”）"><a href="#写（”当前读”）" class="headerlink" title="写（”当前读”）"></a>写（”当前读”）</h3><p>事务的隔离级别中虽然只定义了读数据的要求，实际上这也可以说是写数据的要求。上文的“读”，实际是讲的快照读；而这里说的“写”就是当前读了。</p>
<p>为了解决当前读中的幻读问题，MySQL事务使用了Next-Key锁。</p>
<h3 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h3><p>Next-Key锁是行锁和GAP（间隙锁）的合并，行锁上文已经介绍了，接下来说下GAP间隙锁。</p>
<p>行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况。但如何避免别的事务插入数据就成了问题。我们可以看看RR级别和RC级别的对比</p>
<p>RC级别：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/innodb_lock3.png" alt></p>
<p>RR级别：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/innodb_lock4.png" alt></p>
<p>通过对比我们可以发现，在RC级别中，事务A修改了所有teacher_id=30的数据，但是当事务Binsert进新数据后，事务A发现莫名其妙多了一行teacher_id=30的数据，而且没有被之前的update语句所修改，这就是“当前读”的幻读。</p>
<p>RR级别中，事务A在update后加锁，事务B无法插入新数据，这样事务A在update前后读的数据保持一致，避免了幻读。这个锁，就是Gap锁。</p>
<p>MySQL是这么实现的：</p>
<p>在class_teacher这张表中，teacher_id是个索引，那么它就会维护一套B+树的数据关系，为了简化，我们用链表结构来表达（实际上是个树形结构，但原理相同）</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/gap_lock.png" alt></p>
<p>如图所示，InnoDB使用的是聚集索引，teacher_id身为二级索引，就要维护一个索引字段和主键id的树状结构（这里用链表形式表现），并保持顺序排列。</p>
<p>Innodb将这段数据分成几个个区间</p>
<ul>
<li>(negative infinity, 5],</li>
<li>(5,30],</li>
<li>(30,positive infinity)；</li>
</ul>
<p>update class_teacher set class_name=‘初三四班’ where teacher_id=30;不仅用行锁，锁住了相应的数据行；同时也在两边的区间，（5,30]和（30，positive infinity），都加入了gap锁。这样事务B就无法在这个两个区间insert进新数据。</p>
<p>受限于这种实现方式，Innodb很多时候会锁住不需要锁的区间。如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/innodb_lock5.png" alt></p>
<p>update的teacher_id=20是在(5，30]区间，即使没有修改任何数据，Innodb也会在这个区间加gap锁，而其它区间不会影响，事务C正常插入。</p>
<p>如果使用的是没有索引的字段，比如update class_teacher set teacher_id=7 where class_name=‘初三八班（即使没有匹配到任何数据）’,那么会给全表加入gap锁。同时，它不能像上文中行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没有索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其它事务无法插入任何数据。</p>
<p>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p>
<p>不要看到select就说不会加锁了，在Serializable这个级别，还是会加锁的！</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>innodb锁</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql-基本知识总结</title>
    <url>/2020/03/14/Mysql-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p><a id="more"></a>
<p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p>
<p><strong>两者的对比：</strong></p>
<ol>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。</li>
</ol>
<p>《MySQL高性能》上面有一句话这样写到:</p>
<blockquote>
<p>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
</blockquote>
<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong> </li>
</ul>
<p><a href="https://juejin.im/post/5b25bc1051882574b00fb7da" target="_blank" rel="noopener">为什么使用B+tree索引</a></p>
<p><a href="https://www.cnblogs.com/yycc/p/7338894.html" target="_blank" rel="noopener">执行计划分析</a></p>
<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h3><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h3><ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h3 id="事务隔离级别有哪些-MySQL的默认隔离级别是"><a href="#事务隔离级别有哪些-MySQL的默认隔离级别是" class="headerlink" title="事务隔离级别有哪些?MySQL的默认隔离级别是?"></a>事务隔离级别有哪些?MySQL的默认隔离级别是?</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p>
<p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<h3 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h3><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p><strong>相关知识点：</strong></p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<h4 id="1-限定数据的范围"><a href="#1-限定数据的范围" class="headerlink" title="1. 限定数据的范围"></a>1. 限定数据的范围</h4><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h4 id="2-读-写分离"><a href="#2-读-写分离" class="headerlink" title="2. 读/写分离"></a>2. 读/写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h4 id="3-垂直分区"><a href="#3-垂直分区" class="headerlink" title="3. 垂直分区"></a>3. 垂直分区</h4><p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/mysql_table.png" alt></p>
<ul>
<li><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h4 id="4-水平分区"><a href="#4-水平分区" class="headerlink" title="4. 水平分区"></a>4. 水平分区</h4><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/mysql_table1.png" alt></p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>
<ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h3 id="分库分表之后-id-主键如何处理？"><a href="#分库分表之后-id-主键如何处理？" class="headerlink" title="分库分表之后,id 主键如何处理？"></a>分库分表之后,id 主键如何处理？</h3><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。</p>
<p>生成全局 id 有下面这几种方式：</p>
<ul>
<li><p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p>
</li>
<li><p><strong>数据库自增 id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>
</li>
<li><p><strong>利用 redis 生成 id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
</li>
<li><p><strong>Twitter的snowflake算法</strong> ：Github 地址：<a href="https://github.com/twitter-archive/snowflake。" target="_blank" rel="noopener">https://github.com/twitter-archive/snowflake。</a></p>
<p>  <a href="https://segmentfault.com/a/1190000011282426#item-3-4" target="_blank" rel="noopener">snowflake算法</a></p>
</li>
<li><p><strong>美团的<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf</a>分布式ID生成系统</strong> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/04/21/mt-leaf.html</a> 。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/chenpeng19910926/article/details/51789934" target="_blank" rel="noopener">高并发系统设计-数据层</a></p>
<h3 id="分库分表后数据迁移方案"><a href="#分库分表后数据迁移方案" class="headerlink" title="分库分表后数据迁移方案"></a>分库分表后数据迁移方案</h3><h4 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h4><p>我先给你说一个最 low 的方案，就是很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p>
<p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个<strong>导数的一次性工具</strong>，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p>
<p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p>
<p>验证一下，ok了，完美，大家伸个懒腰，看看看凌晨 4 点钟的北京夜景，打个滴滴回家吧。</p>
<p>但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p>
<p><a href="https://github.com/doocs/advanced-java/blob/master/images/database-shard-method-1.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/master/images/database-shard-method-1.png" alt="database-shard-method-1"></a></p>
<h4 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h4><p>这个是我们常用的一种迁移方案，比较靠谱一些，不用停机，不用看北京凌晨 4 点的风景。</p>
<p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，<strong>除了对老库增删改，都加上对新库的增删改</strong>，这就是所谓的<strong>双写</strong>，同时写俩库，老库和新库。</p>
<p>然后<strong>系统部署</strong>之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p>
<p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p>
<p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。</p>
<p><a href="https://github.com/doocs/advanced-java/blob/master/images/database-shard-method-2.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/master/images/database-shard-method-2.png" alt="database-shard-method-2"></a></p>
<h3 id="如何设计可以动态扩容缩容的分库分表方案"><a href="#如何设计可以动态扩容缩容的分库分表方案" class="headerlink" title="如何设计可以动态扩容缩容的分库分表方案"></a>如何设计可以动态扩容缩容的分库分表方案</h3><h4 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h4><p>这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然<strong>分库分表</strong>就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p>
<p>从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1小时数据就导完了。这没有问题。</p>
<p>如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p>
<h4 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h4><p>一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p>
<p>我可以告诉各位同学，这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题。</p>
<p>每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载 32 * 1000 = 32000 的写并发，如果每个库承载 1500 的写并发，32 * 1500 = 48000 的写并发，接近 5 万每秒的写入并发，前面再加一个MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p>
<p>有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128 个库，256 个库，512 个库。</p>
<p>1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p>
<p>每秒 5 万的写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p>
<p>谈分库分表的扩容，<strong>第一次分库分表，就一次性给他分个够</strong>，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p>
<p>一个实践是利用 <code>32 * 32</code> 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p>
<table>
<thead>
<tr>
<th>orderId</th>
<th>id % 32 (库)</th>
<th>id / 32 % 32 (表)</th>
</tr>
</thead>
<tbody><tr>
<td>259</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>1189</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>352</td>
<td>0</td>
<td>11</td>
</tr>
<tr>
<td>4593</td>
<td>17</td>
<td>15</td>
</tr>
</tbody></table>
<p>刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个 mysql 服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 mysql 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p>
<p>比如说最多可以扩展到 32 个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是 1024 个表。</p>
<p>这么搞，是不用自己写代码做数据迁移的，都交给 dba 来搞好了，但是 dba 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p>
<p>哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p>
<p>这里对步骤做一个总结：</p>
<ol>
<li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32 库 * 32 表，对于大部分公司来说，可能几年都够了。</li>
<li>路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表</li>
<li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li>
<li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li>
<li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li>
<li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li>
</ol>
<h3 id="如何实现-MySQL-的读写分离？"><a href="#如何实现-MySQL-的读写分离？" class="headerlink" title="如何实现 MySQL 的读写分离？"></a>如何实现 MySQL 的读写分离？</h3><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p>
<h4 id="MySQL-主从复制原理的是啥？"><a href="#MySQL-主从复制原理的是啥？" class="headerlink" title="MySQL 主从复制原理的是啥？"></a>MySQL 主从复制原理的是啥？</h4><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p>
<p><a href="https://github.com/doocs/advanced-java/blob/master/images/mysql-master-slave.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/master/images/mysql-master-slave.png" alt="mysql-master-slave"></a></p>
<p>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p>
<p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p>
<p>所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p>
<p>这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p>
<p>所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p>
<h4 id="MySQL-主从同步延时问题（精华）"><a href="#MySQL-主从同步延时问题（精华）" class="headerlink" title="MySQL 主从同步延时问题（精华）"></a>MySQL 主从同步延时问题（精华）</h4><p>以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p>
<p>是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p>
<p>我们通过 MySQL 命令：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">show</span> <span class="built_in">status</span></span><br></pre></td></tr></table></figure>

<p>查看 <code>Seconds_Behind_Master</code>，可以看到从库复制主库的数据落后了几 ms。</p>
<p>一般来说，如果主从延迟较为严重，有以下解决方案：</p>
<ul>
<li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li>
<li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</li>
<li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li>
<li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>基本知识点</category>
      </categories>
  </entry>
  <entry>
    <title>Jvm-GC优化</title>
    <url>/2020/03/13/Jvm-GC%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。但GC算法复杂，影响GC性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了GC优化的难度。即便如此，GC调优也不是无章可循，仍然有一些通用的思考方法。本篇会介绍这些通用的GC优化策略和相关实践案例，主要包括如下内容： &gt; 优化前准备: 简单回顾JVM相关知识、介绍GC优化的一些通用策略。 &gt; 优化方法: 介绍调优的一般流程：明确优化目标→优化→跟踪优化结果。</p><a id="more"></a>
<h2 id="一、优化前的准备"><a href="#一、优化前的准备" class="headerlink" title="一、优化前的准备"></a>一、优化前的准备</h2><h3 id="GC优化需知"><a href="#GC优化需知" class="headerlink" title="GC优化需知"></a>GC优化需知</h3><p>为了更好地理解本篇所介绍的内容，你需要了解如下内容。 1. GC相关基础知识，包括但不限于： a) GC工作原理。 b) 理解新生代、老年代、晋升等术语含义。 c) 可以看懂GC日志。</p>
<ol>
<li>GC优化不能解决一切性能问题，它是最后的调优手段。</li>
</ol>
<p>如果对第一点中提及的知识点不是很熟悉，可以先阅读小结-JVM基础回顾；如果已经很熟悉，可以跳过该节直接往下阅读。</p>
<h3 id="JVM基础回顾"><a href="#JVM基础回顾" class="headerlink" title="JVM基础回顾"></a>JVM基础回顾</h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><p>简单介绍一下JVM内存结构和常见的垃圾回收器。</p>
<p>当代主流虚拟机（Hotspot VM）的垃圾回收都采用“分代回收”的算法。“分代回收”是基于这样一个事实：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。</p>
<p>Hotspot VM将内存划分为不同的物理区，就是“分代”思想的体现。如图所示，JVM内存主要由新生代、老年代、永久代构成。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/ab15459b.png" alt></p>
<ol>
<li><p>新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。</p>
<p> 新生代内又分三个区：一个Eden区，两个Survivor区（一般而言），大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。</p>
</li>
<li><p>老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</p>
</li>
<li><p>永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。</p>
</li>
</ol>
<h4 id="常见垃圾回收器"><a href="#常见垃圾回收器" class="headerlink" title="常见垃圾回收器"></a>常见垃圾回收器</h4><p>不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器：</p>
<ul>
<li>串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。</li>
<li>并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。</li>
<li>吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。</li>
<li>并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。</li>
</ul>
<h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><p>每一种回收器的日志格式都是由其自身的实现决定的，换而言之，每种回收器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个回收器的日志都维持一定的共性。</p>
<h3 id="参数基本策略"><a href="#参数基本策略" class="headerlink" title="参数基本策略"></a>参数基本策略</h3><p>各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。</p>
<p><strong>活跃数据的大小</strong>是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取GC数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下：</p>
<table>
<thead>
<tr>
<th>空间</th>
<th>倍数</th>
</tr>
</thead>
<tbody><tr>
<td>总大小</td>
<td><strong>3-4</strong> 倍活跃数据的大小</td>
</tr>
<tr>
<td>新生代</td>
<td><strong>1-1.5</strong> 活跃数据的大小</td>
</tr>
<tr>
<td>老年代</td>
<td><strong>2-3</strong> 倍活跃数据的大小</td>
</tr>
<tr>
<td>永久代</td>
<td><strong>1.2-1.5</strong> 倍Full GC后的永久代空间占用</td>
</tr>
</tbody></table>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p>
<blockquote>
<p>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</p>
</blockquote>
<p>这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。</p>
<h2 id="二、优化步骤"><a href="#二、优化步骤" class="headerlink" title="二、优化步骤"></a>二、优化步骤</h2><p>GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。</p>
<h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h3><p>明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如： - 高可用，可用性达到几个9。 - 低延迟，请求必须多少毫秒内完成响应。 - 高吞吐，每秒完成多少次事务。</p>
<p>明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是降低吞吐量或者消耗更多的内存或者两者同时发生。</p>
<p>由于笔者所在团队主要关注高可用和低延迟两项指标，所以接下来分析，如何量化GC时间和频率对于响应时间和可用性的影响。通过这个量化指标，可以计算出当前GC情况对服务的影响，也能评估出GC优化后对响应时间的收益，这两点对于低延迟服务很重要。</p>
<p>举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/f6e7326e.png" alt></p>
<p>那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，<strong>受GC影响请求占比=(接口响应时间+GC时间)×N/T</strong> 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>通过收集GC信息，结合系统需求，确定优化方案，例如选用合适的GC回收器、重新设置内存比例、调整JVM参数等。</p>
<p>进行调整后，将不同的优化方案分别应用到多台机器上，然后比较这些机器上GC的性能差异，有针对性的做出选择，再通过不断的试验和观察，找到最合适的参数。</p>
<h3 id="验收优化结果"><a href="#验收优化结果" class="headerlink" title="验收优化结果"></a>验收优化结果</h3><p>将修改应用到所有服务器，判断优化结果是否符合预期，总结相关经验。</p>
<p>接下来，我们通过三个案例来实践以上的优化流程和基本原则（本文中三个案例使用的垃圾回收器均为ParNew+CMS，CMS失败时Serial Old替补)。</p>
<h2 id="三、GC优化案例"><a href="#三、GC优化案例" class="headerlink" title="三、GC优化案例"></a>三、GC优化案例</h2><h3 id="案例一-Major-GC和Minor-GC频繁"><a href="#案例一-Major-GC和Minor-GC频繁" class="headerlink" title="案例一 Major GC和Minor GC频繁"></a>案例一 Major GC和Minor GC频繁</h3><h4 id="确定目标-1"><a href="#确定目标-1" class="headerlink" title="确定目标"></a>确定目标</h4><p>服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。</p>
<p>由于这个服务要求低延时高可用，结合上文中提到的GC对服务响应时间的影响，计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，可见当前GC情况对响应时间影响较大。</p>
<p><em>（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3%</em> 。</p>
<p>优化目标：降低TP99、TP90时间。</p>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>
<p>这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。我们结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？ 首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/6eb9b856.png" alt></p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/1470cba5.png" alt></p>
<p>通过上图GC日志中两处红色框标记内容可知： 1. new threshold = 2（动态年龄判断，对象的晋升年龄阈值为2），对象仅经历2次Minor GC后就晋升到老年代，这样老年代会迅速被填满，直接导致了频繁的Major GC。 2. Major GC后老年代使用空间为300M+，意味着此时绝大多数(86% = 2G/2.3G)的对象已经不再存活，也就是说生命周期长的对象占比很小。</p>
<p>由此可见，服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。</p>
<h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4><p>通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。</p>
<p>调整前：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/a1532bd7.png" alt></p>
<p>调整后：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/ae11fb41.png" alt></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如何选择各分区大小应该依赖应用程序中<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p>
<h4 id="更多思考"><a href="#更多思考" class="headerlink" title="更多思考"></a>更多思考</h4><p>关于上文中提到晋升年龄阈值为2，很多同学有疑问，为什么设置了MaxTenuringThreshold=15，对象仍然仅经历2次Minor GC，就晋升到老年代？这里涉及到“动态年龄计算”的概念。</p>
<p><strong>动态年龄计算</strong>：Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 = 64M，desired survivor = 32M，此时Survivor区中age&lt;=2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。</p>
<p>JVM引入动态年龄计算，主要基于如下两点考虑：</p>
<ol>
<li>如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件： a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。 b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</li>
<li>相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。</li>
</ol>
<p>总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。</p>
<h3 id="案例二-请求高峰期发生GC，导致服务可用性下降"><a href="#案例二-请求高峰期发生GC，导致服务可用性下降" class="headerlink" title="案例二 请求高峰期发生GC，导致服务可用性下降"></a>案例二 请求高峰期发生GC，导致服务可用性下降</h3><h4 id="确定目标-2"><a href="#确定目标-2" class="headerlink" title="确定目标"></a>确定目标</h4><p>GC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。Remark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/ee8d24f9.png" alt></p>
<h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><p>解决问题前，先回顾一下CMS的四个主要阶段，以及各个阶段的工作内容。下图展示了CMS各个阶段可以标记的对象，用不同颜色区分。 1. Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。 2. Concurrent-mark并发标记，由前阶段标记过的绿色对象出发，所有可到达的对象都在本阶段中标记。 3. Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。 4. 并发清理，进行并发的垃圾清理。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/09cf176b.png" alt></p>
<p>可见，Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？结论是不可行，原因如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/eaa94379.png" alt></p>
<p>如果仅扫描老年代中对象，即以老年代中对象为根，判断对象是否存在引用，上图中，对象A因为引用存在新生代中，它在Remark阶段就不会被修正标记为可达，GC时会被错误回收。 新生代对象持有老年代中对象的引用，这种情况称为<strong>“跨代引用”</strong>。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活，包括图中灰色的不可达对象。</p>
<p>灰色对象已经不可达，但仍然需要扫描的原因：<strong>新生代GC和老年代的GC是各自分开独立进行的</strong>，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。由此可见堆中对象的数目影响了Remark阶段耗时。 分析GC日志可以得出同样的规律，Remark耗时&gt;500ms时，新生代使用率都在75%以上。这样降低Remark阶段耗时问题转换成如何减少新生代对象数量。</p>
<p>新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。CMS就采用了这样的方式，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。</p>
<p>除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。 根据GC日志红色标记2处显示，可中断的并发预清理执行了5.35s，超过了设置的5s被中断，期间没有等到Minor GC ，所以Remark时新生代中仍然有很多对象。</p>
<p>对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。</p>
<h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a>优化结果</h4><p>经过增加CMSScavengeBeforeRemark参数，单次执行时间&gt;200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/6b73e4c0.png" alt></p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。</p>
<h4 id="更多思考-1"><a href="#更多思考-1" class="headerlink" title="更多思考"></a>更多思考</h4><p>案例中只涉及老年代GC，其实新生代GC存在同样的问题，即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。</p>
<p><strong>JVM是如何避免Minor GC时扫描全堆的？</strong> 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/df96e180.png" alt></p>
<p><strong>卡表</strong>的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</p>
<p>总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。</p>
<h3 id="案例三-发生Stop-The-World的GC"><a href="#案例三-发生Stop-The-World的GC" class="headerlink" title="案例三 发生Stop-The-World的GC"></a>案例三 发生Stop-The-World的GC</h3><h4 id="确定目标-3"><a href="#确定目标-3" class="headerlink" title="确定目标"></a>确定目标</h4><p>GC日志如下图（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。本次优化目标是降低单次STW回收停顿时间，提高可用性。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/b15554ea.png" alt></p>
<h4 id="优化-3"><a href="#优化-3" class="headerlink" title="优化"></a>优化</h4><p>首先，什么时候可能会触发STW的Full GC呢？ 1. Perm空间不足； 2. CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）； 3. 统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间； 4. 主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。</p>
<p>然后，我们来逐一分析一下： - 排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。 - 排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。 - 排除原因4：因为当时没有相关命令执行。 - 锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。</p>
<p>找到原因后解决方法有两种： 1. 通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。 2. CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。</p>
<p>由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。</p>
<h4 id="优化结果-2"><a href="#优化结果-2" class="headerlink" title="优化结果"></a>优化结果</h4><p>调整参数后，服务不再有Perm区扩容导致的STW GC发生。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>结合上述GC优化案例做个总结： </p>
<ol>
<li>首先再次声明，在进行GC优化之前，需要确认项目的架构和代码等已经没有优化空间。我们不能指望一个系统架构有缺陷或者代码层次优化没有穷尽的应用，通过GC优化令其性能达到一个质的飞跃。 </li>
<li>其次，通过上述分析，可以看出虚拟机内部已有很多优化来保证应用的稳定运行，所以不要为了调优而调优，不当的调优可能适得其反。</li>
<li>最后，GC优化是一个系统而复杂的工作，没有万能的调优策略可以满足所有的性能指标。GC优化必须建立在我们深入理解各种垃圾回收器的基础上，才能有事半功倍的效果。</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Gc</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-索引原理及慢查询优化</title>
    <url>/2020/03/13/Mysql-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h2><h3 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h3><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p><a id="more"></a>
<h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h4 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h4><p>前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/mysql_index.png" alt></p>
<p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><p>前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p>
<h4 id="详解b-树"><a href="#详解b-树" class="headerlink" title="详解b+树"></a>详解b+树</h4><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/mysql_index1.png" alt></p>
<p>如上图，是一颗b+树，关于b+树的定义可以参见<a href="http://zh.wikipedia.org/wiki/B%2B树" target="_blank" rel="noopener">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h4 id="b-树的查找过程"><a href="#b-树的查找过程" class="headerlink" title="b+树的查找过程"></a>b+树的查找过程</h4><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<h4 id="b-树性质"><a href="#b-树性质" class="headerlink" title="b+树性质"></a>b+树性质</h4><ol>
<li><p>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>
</li>
<li><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
</li>
</ol>
<h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><p>关于MySQL索引原理是比较枯燥的东西，大家只需要有一个感性的认识，并不需要理解得非常透彻和深入。我们回头来看看一开始我们说的慢查询，了解完索引原理之后，大家是不是有什么想法呢？先总结一下索引的几大基本原则：</p>
<h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol>
<li><p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
</li>
<li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
</li>
<li><p>尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p>
</li>
<li><p>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p>
</li>
<li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
</li>
</ol>
<h3 id="查询优化神器-explain命令"><a href="#查询优化神器-explain命令" class="headerlink" title="查询优化神器 - explain命令"></a>查询优化神器 - explain命令</h3><p>关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网<a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html" target="_blank" rel="noopener">explain-output</a>，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。</p>
<h3 id="慢查询优化基本步骤"><a href="#慢查询优化基本步骤" class="headerlink" title="慢查询优化基本步骤"></a>慢查询优化基本步骤</h3><ol>
<li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li>
<li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li>
<li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li>
<li>order by limit 形式的sql语句让排序的表优先查</li>
<li>了解业务方使用场景</li>
<li>加索引时参照建索引的几大原则</li>
<li>观察结果，不符合预期继续从0分析</li>
</ol>
<h3 id="几个慢查询案例"><a href="#几个慢查询案例" class="headerlink" title="几个慢查询案例"></a>几个慢查询案例</h3><p>下面几个例子详细解释了如何分析和优化慢查询。</p>
<h4 id="复杂语句写法"><a href="#复杂语句写法" class="headerlink" title="复杂语句写法"></a>复杂语句写法</h4><p>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id = emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted=<span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table=<span class="string">'Employee'</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid= cert.emp_id</span><br><span class="line">      ) </span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table=<span class="string">'EmpCertificate'</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid= cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">'2013-11-07 15:03:00'</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">'2013-11-08 16:00:00'</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">53 rows in <span class="keyword">set</span> (<span class="number">1.87</span> sec)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>explain</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/mysql_index2.png" alt></p>
<p>简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。</p>
<p>如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p>
<p>优化过的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table = <span class="string">'Employee'</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid = emp.id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">'2013-11-07 15:03:00'</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">'2013-11-08 16:00:00'</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   emp_certificate ec </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table = <span class="string">'EmpCertificate'</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid = ec.id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> emp.id = ec.emp_id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">'2013-11-07 15:03:00'</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">'2013-11-08 16:00:00'</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>4.不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p>
<p>5.现有索引可以满足，不需要建索引</p>
<p>6.用改造后的语句实验一下，只需要10ms 降低了近200倍！</p>
<h4 id="明确应用场景"><a href="#明确应用场景" class="headerlink" title="明确应用场景"></a>明确应用场景</h4><p>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   * </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   stage_poi sp </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   sp.accurate_result=<span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> (</span><br><span class="line">      sp.sync_status=<span class="number">0</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status=<span class="number">2</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status=<span class="number">4</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>0.先看看运行多长时间,951条数据6.22秒，真的很慢。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">951 rows in <span class="keyword">set</span> (<span class="number">6.22</span> sec)</span><br></pre></td></tr></table></figure>

<p>1.先explain，rows达到了361万，type = ALL表明是全表扫描。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/sql_index3.png" alt></p>
<p>2.所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条。</p>
<p>3.让explain的rows 尽量逼近951。</p>
<p>看一下accurate_result = 1的记录数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),accurate_result <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> accurate_result;</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br><span class="line">| count(*) | accurate_result |</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br><span class="line">|     1023 |              -1 |</span><br><span class="line">|  2114655 |               0 |</span><br><span class="line">|   972815 |               1 |</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p>我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据。</p>
<p>再看一下sync_status字段的情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),sync_status <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> sync_status;</span><br><span class="line">+<span class="comment">----------+-------------+</span></span><br><span class="line">| count(*) | sync_status |</span><br><span class="line">+<span class="comment">----------+-------------+</span></span><br><span class="line">|     3080 |           0 |</span><br><span class="line">|  3085413 |           3 |</span><br><span class="line">+<span class="comment">----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>同样的区分度也很低，根据理论，也不适合建立索引。</p>
<p>问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁定记录也是百万级别的。</p>
<p>4.找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据。</p>
<p>5.根据建立索引规则，使用如下语句建立索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stage_poi <span class="keyword">add</span> <span class="keyword">index</span> idx_acc_status(accurate_result,sync_status);</span><br></pre></td></tr></table></figure>

<p>6.观察预期结果,发现只需要200ms，快了30多倍。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">952 rows in <span class="keyword">set</span> (<span class="number">0.20</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>
<h4 id="无法优化的语句"><a href="#无法优化的语句" class="headerlink" title="无法优化的语句"></a>无法优化的语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.position,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">   from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">   c.last_modified_user_id  </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   contact_branch cb </span><br><span class="line">      <span class="keyword">on</span>  c.id = cb.contact_id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   branch_user bu </span><br><span class="line">      <span class="keyword">on</span>  cb.branch_id = bu.branch_id </span><br><span class="line">      <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>)  </span><br><span class="line">   <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">      org_emp_info oei </span><br><span class="line">         <span class="keyword">on</span>  oei.data_id = bu.user_id </span><br><span class="line">         <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span> </span><br><span class="line">         <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span> </span><br><span class="line">         <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>  </span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      c.created_time <span class="keyword">desc</span>  <span class="keyword">limit</span> <span class="number">0</span> ,</span><br><span class="line">      <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>还是几个步骤。</p>
<p>0.先看语句运行多长时间，10条记录用了13秒，已经不可忍受。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">13.06</span> sec)</span><br></pre></td></tr></table></figure>

<p>1.explain</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/mysql/sql_index4.png" alt></p>
<p>从执行计划上看，mysql先查org_emp_info表扫描8849记录，再用索引idx_userid_status关联branch_user表，再用索引idx_branch_id关联contact_branch表，最后主键关联contact表。</p>
<p>rows返回的都非常少，看不到有什么异常情况。我们在看一下语句，发现后面有order by + limit组合，会不会是排序量太大搞的？于是我们简化SQL，去掉后面的order by 和 limit，看看到底用了多少记录来排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   contact_branch cb </span><br><span class="line">      <span class="keyword">on</span>  c.id = cb.contact_id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   branch_user bu </span><br><span class="line">      <span class="keyword">on</span>  cb.branch_id = bu.branch_id </span><br><span class="line">      <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>)  </span><br><span class="line">   <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">      org_emp_info oei </span><br><span class="line">         <span class="keyword">on</span>  oei.data_id = bu.user_id </span><br><span class="line">         <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span> </span><br><span class="line">         <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span> </span><br><span class="line">         <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>  </span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| <span class="keyword">count</span>(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|   <span class="number">778878</span> |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">5.19</span> sec)</span><br></pre></td></tr></table></figure>

<p>发现排序之前居然锁定了778878条记录，如果针对70万的结果集排序，将是灾难性的，怪不得这么慢，那我们能不能换个思路，先根据contact的created_time排序，再来join会不会比较快呢？</p>
<p>于是改造成下面的语句，也可以用straight_join来优化：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.<span class="built_in">position</span>,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">   from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">   c.last_modified_user_id   </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         <span class="number">1</span> </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         contact_branch cb  </span><br><span class="line">      <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">         branch_user bu        </span><br><span class="line">            <span class="keyword">on</span>  cb.branch_id = bu.branch_id        </span><br><span class="line">            <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">               <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>)      </span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">            org_emp_info oei           </span><br><span class="line">               <span class="keyword">on</span>  oei.data_id = bu.user_id           </span><br><span class="line">               <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span>           </span><br><span class="line">               <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span>           </span><br><span class="line">               <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>      </span><br><span class="line">         <span class="keyword">where</span></span><br><span class="line">            c.id = cb.contact_id    </span><br><span class="line">      )    </span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      c.created_time <span class="keyword">desc</span>  <span class="keyword">limit</span> <span class="number">0</span> ,</span><br><span class="line">      <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>验证一下效果 预计在1ms内，提升了13000多倍！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>本以为至此大工告成，但我们在前面的分析中漏了一个细节，先排序再join和先join再排序理论上开销是一样的，为何提升这么多是因为有一个limit！大致执行过程是：mysql先按索引排序得到前10条记录，然后再去join过滤，当发现不够10条的时候，再次去10条，再次join，这显然在内层join过滤的数据非常多的时候，将是灾难的，极端情况，内层一条数据都找不到，mysql还傻乎乎的每次取10条，几乎遍历了这个数据表！</p>
<p>用不同参数的SQL试验下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   sql_no_cache   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.position,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">   from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">   c.last_modified_user_id    </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c   </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         <span class="number">1</span>        </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         contact_branch cb         </span><br><span class="line">      <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">         branch_user bu                     </span><br><span class="line">            <span class="keyword">on</span>  cb.branch_id = bu.branch_id                     </span><br><span class="line">            <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">               <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>)                </span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">            org_emp_info oei                           </span><br><span class="line">               <span class="keyword">on</span>  oei.data_id = bu.user_id                           </span><br><span class="line">               <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span>                           </span><br><span class="line">               <span class="keyword">and</span> oei.node_right &lt;= <span class="number">2875</span>                           </span><br><span class="line">               <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>                </span><br><span class="line">         <span class="keyword">where</span></span><br><span class="line">            c.id = cb.contact_id           </span><br><span class="line">      )        </span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      c.created_time <span class="keyword">desc</span>  <span class="keyword">limit</span> <span class="number">0</span> ,</span><br><span class="line">      <span class="number">10</span>;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">2</span> <span class="keyword">min</span> <span class="number">18.99</span> sec)</span><br></pre></td></tr></table></figure>

<p>2 min 18.99 sec！比之前的情况还糟糕很多。由于mysql的nested loop机制，遇到这种情况，基本是无法优化的。这条语句最终也只能交给应用系统去优化自己的逻辑了。</p>
<p>通过这个例子我们可以看到，并不是所有语句都能优化，而往往我们优化时，由于SQL用例回归时落掉一些极端情况，会造成比原来还严重的后果。所以，第一：不要指望所有语句都能通过SQL优化，第二：不要过于自信，只针对具体case来优化，而忽略了更复杂的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>任何数据库层面的优化都抵不上应用系统的优化，同样是MySQL，可以用来支撑Google/FaceBook/Taobao应用，但可能连你的个人网站都撑不住。套用最近比较流行的话：“查询容易，优化不易，且写且珍惜！”</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>索引</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法笔记进阶-缓存结构的设计</title>
    <url>/2020/03/12/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6-%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="设计可以变更的缓存结构（LRU）"><a href="#设计可以变更的缓存结构（LRU）" class="headerlink" title="设计可以变更的缓存结构（LRU）"></a>设计可以变更的缓存结构（LRU）</h2><p>设计一种缓存结构，该结构在构造时确定大小，假设大小为K，并有两个功能：<code>set(key,value)</code>：将记录<code>(key,value)</code>插入该结构。<code>get(key)</code>：返回key对应的value值。</p><p>【要求】</p><ul>
<li>set和get方法的时间复杂度为O(1)。</li>
<li>某个key的set或get操作一旦发生，认为这个key的记录成了最经常使用的。</li>
<li>当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。</li>
</ul><a id="more"></a>


<p>【举例】</p>
<p>假设缓存结构的实例是cache，大小为3，并依次发生如下行为：</p>
<ol>
<li>cache.set(“A”,1)。最经常使用的记录为(“A”,1)。</li>
<li>cache.set(“B”,2)。最经常使用的记录为(“B”,2)，(“A”,1)变为最不经常的。</li>
<li>cache.set(“C”,3)。最经常使用的记录为(“C”,2)，(“A”,1)还是最不经常的。</li>
<li>cache.get(“A”)。最经常使用的记录为(“A”,1)，(“B”,2)变为最不经常的。</li>
<li>cache.set(“D”,4)。大小超过了3，所以移除此时最不经常使用的记录(“B”,2)，加入记录 (“D”,4)，并且为最经常使用的记录，然后(“C”,2)变为最不经常使用的记录</li>
</ol>
<blockquote>
<p>设计思路：使用一个哈希表和双向链表</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/cache_design.png" alt> </p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; prev;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * the head is the oldest record and the tail is the newest record</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * the add() will append the record to tail</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; head;</span><br><span class="line">        Node&lt;K, V&gt; tail;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node&lt;K,V&gt; node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.head = node;</span><br><span class="line">                <span class="keyword">this</span>.tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">                node.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">                <span class="keyword">this</span>.tail = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(Node&lt;K,V&gt; node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">                Node&lt;K, V&gt; newHead = node.next;</span><br><span class="line">                newHead.prev = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.head = newHead;</span><br><span class="line"></span><br><span class="line">                node.next = <span class="keyword">null</span>;</span><br><span class="line">                node.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">                <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">                <span class="keyword">this</span>.tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev.next = node.next;</span><br><span class="line">                node.next.prev = node.prev;</span><br><span class="line"></span><br><span class="line">                node.next=<span class="keyword">null</span>;</span><br><span class="line">                node.prev=<span class="keyword">this</span>.tail;</span><br><span class="line">                <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">                <span class="keyword">this</span>.tail = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">removeHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K deletedK = <span class="keyword">this</span>.head.key;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K, V&gt; newHead = <span class="keyword">this</span>.head.next;</span><br><span class="line">                    newHead.prev = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">this</span>.head = newHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> deletedK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        HashMap&lt;K, Node&lt;K, V&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        DoubleLinkedList list = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        <span class="keyword">int</span> capacity;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">//swap value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//update map</span></span><br><span class="line">                Node&lt;K, V&gt; node = map.get(key);</span><br><span class="line">                node.value = value;</span><br><span class="line">                map.put(key, node);</span><br><span class="line">                <span class="comment">//update list</span></span><br><span class="line">                list.moveToTail(node);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//save record</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//if full,remove the oldest first and then save</span></span><br><span class="line">                <span class="keyword">if</span> (map.size() == <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">                    K deletedK = (K) list.removeHead();</span><br><span class="line">                    map.remove(deletedK);</span><br><span class="line">                &#125;</span><br><span class="line">                Node&lt;K, V&gt; record = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">                map.put(key, record);</span><br><span class="line">                list.add(record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                Node&lt;K, V&gt; target = map.get(key);</span><br><span class="line">                list.moveToTail(target);</span><br><span class="line">                <span class="keyword">return</span> target.value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache&lt;String, Integer&gt; myCache = <span class="keyword">new</span> MyCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        myCache.set(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        myCache.set(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        myCache.set(<span class="string">"C"</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(myCache.get(<span class="string">"A"</span>));</span><br><span class="line">        myCache.set(<span class="string">"D"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(myCache.get(<span class="string">"B"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>面试技巧：</p>
<p>在刷题时，如果感觉这个题明显在30分钟内解不出来就放弃，因为面试给出的题目一般会让你在30分内解出。</p>
<p>在面试时如果碰到自己遇到过的题也要装作没遇到过，假装一番苦思冥想、和面试官沟通细节，然后突然想通了的样子。</p>
</blockquote>
<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>LFU也是一种经典的缓存结构，只不过它是以<code>key</code>的访问频度作为缓存替换依据的。</p>
<p>举例：<code>set(&quot;A&quot;,Data)</code>将会在LFU结构中放入一条key为“A”的记录，并将该记录的使用频度置为1，后续的<code>set(&quot;A&quot;,newData)</code>或<code>get(&quot;A&quot;)</code>都会将该key对应的记录的使用频度加1；当该结构容量已满还尝试往里添加记录时，会先将结构中使用频度最少的记录删除，再将新的记录添加进去。</p>
<blockquote>
<p>设计思路：使用一个哈希表和一个二维双向链表（链表中包含链表）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/lru_cache.png" alt> </p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save all record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Record&lt;K,V&gt;&gt; recordMap;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The reference of the FrequencyList whose frequency is the lowest</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FrequencyList headList;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save what FrequencyList a record belongs to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Record,FrequencyList&gt; listOfRecord;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * How many recordMap the LFUCache can contain</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * how many recordMap has been saved</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.recordMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">this</span>.listOfRecord = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.headList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add or update a record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//update</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.recordMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">//update value and frequency</span></span><br><span class="line">            Record&lt;K, V&gt; record = recordMap.get(key);</span><br><span class="line">            record.value = value;</span><br><span class="line">            record.frequency++;</span><br><span class="line">            <span class="comment">//adjust the record's position in FrequencyList</span></span><br><span class="line">            adjust(record, listOfRecord.get(record));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//add</span></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">                <span class="comment">//delete</span></span><br><span class="line">                recordMap.remove(headList.tail.key);</span><br><span class="line">                headList.deleteRecord(headList.tail);</span><br><span class="line">                size--;</span><br><span class="line">                modifyFrequencyList(headList);</span><br><span class="line">            &#125;</span><br><span class="line">            Record&lt;K, V&gt; newRecord = <span class="keyword">new</span> Record&lt;&gt;(key, value);</span><br><span class="line">            recordMap.put(key, newRecord);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (headList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                headList = <span class="keyword">new</span> FrequencyList(newRecord);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (headList.head.frequency != <span class="number">1</span>) &#123;</span><br><span class="line">                FrequencyList frequencyList = <span class="keyword">new</span> FrequencyList(newRecord);</span><br><span class="line">                headList.prev = frequencyList;</span><br><span class="line">                frequencyList.next = headList;</span><br><span class="line">                frequencyList.prev = <span class="keyword">null</span>;</span><br><span class="line">                headList = frequencyList;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                headList.addRecordToHead(newRecord);</span><br><span class="line">            &#125;</span><br><span class="line">            listOfRecord.put(newRecord, headList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get a record by a key,return null if not exists</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!recordMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Record&lt;K, V&gt; record = recordMap.get(key);</span><br><span class="line">        record.frequency++;</span><br><span class="line">        adjust(record, listOfRecord.get(record));</span><br><span class="line">        <span class="keyword">return</span> record.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When the record's frequency changed,split it from its current</span></span><br><span class="line"><span class="comment">     * FrequencyList and insert to another one</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frequencyList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(Record&lt;K, V&gt; record, FrequencyList frequencyList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//split</span></span><br><span class="line">        frequencyList.deleteRecord(record);</span><br><span class="line">        <span class="keyword">boolean</span> deleted = modifyFrequencyList(frequencyList);</span><br><span class="line">        <span class="comment">//insert to anther one</span></span><br><span class="line">        FrequencyList prevList = frequencyList.prev;</span><br><span class="line">        FrequencyList nextList = frequencyList.next;</span><br><span class="line">        <span class="keyword">if</span> (nextList != <span class="keyword">null</span> &amp;&amp; record.frequency == nextList.head.frequency) &#123;</span><br><span class="line">            nextList.addRecordToHead(record);</span><br><span class="line">            listOfRecord.put(record, nextList);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            FrequencyList newList = <span class="keyword">new</span> FrequencyList(record);</span><br><span class="line">            <span class="keyword">if</span> (prevList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nextList.prev = newList;</span><br><span class="line">                &#125;</span><br><span class="line">                newList.next = nextList;</span><br><span class="line">                newList.prev = <span class="keyword">null</span>;</span><br><span class="line">                headList = newList;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                prevList.next = newList;</span><br><span class="line">                newList.prev = prevList;</span><br><span class="line">                newList.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prevList.next = newList;</span><br><span class="line">                newList.prev = prevList;</span><br><span class="line">                newList.next = nextList;</span><br><span class="line">                nextList.prev = newList;</span><br><span class="line">            &#125;</span><br><span class="line">            listOfRecord.put(record, newList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return whether the frequencyList is deleted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frequencyList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">modifyFrequencyList</span><span class="params">(FrequencyList frequencyList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!frequencyList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (frequencyList.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            headList = frequencyList.next;</span><br><span class="line">            <span class="keyword">if</span> (headList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                headList.prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frequencyList.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            frequencyList.prev.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frequencyList.prev.next = frequencyList.next;</span><br><span class="line">            frequencyList.next.prev = frequencyList.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The Record can be design to Record&lt;K,V&gt; or Record&lt;V&gt; used</span></span><br><span class="line"><span class="comment">     * to encapsulate data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * up-&gt;the predecessor pointer</span></span><br><span class="line"><span class="comment">         * down-&gt;the successor pointer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Record&lt;K, V&gt; up;</span><br><span class="line">        Record&lt;K, V&gt; down;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * the frequency of use</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> frequency;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * when the record was created , set the frequency to 1</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Record</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.frequency = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The FrequencyList save a series of Records that</span></span><br><span class="line"><span class="comment">     * has the same frequency</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * prev-&gt;the predecessor pointer</span></span><br><span class="line"><span class="comment">         * next-&gt;the successor pointer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FrequencyList prev;</span><br><span class="line">        FrequencyList next;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The reference of the internal RecordList's head and tail</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Record&lt;K,V&gt; head;</span><br><span class="line">        Record&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FrequencyList</span><span class="params">(Record&lt;K, V&gt; record)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = record;</span><br><span class="line">            <span class="keyword">this</span>.tail = record;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRecordToHead</span><span class="params">(Record&lt;K, V&gt; record)</span> </span>&#123;</span><br><span class="line">            head.up = record;</span><br><span class="line">            record.down = head;</span><br><span class="line">            head = record;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> head == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteRecord</span><span class="params">(Record&lt;K,V&gt; record)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                head = <span class="keyword">null</span>;</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (record == head) &#123;</span><br><span class="line">                head=head.down;</span><br><span class="line">                head.up = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (record == tail) &#123;</span><br><span class="line">                tail = tail.up;</span><br><span class="line">                tail.down = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                record.up.down = record.down;</span><br><span class="line">                record.down.up = record.up;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LFUCache&lt;String, Integer&gt; cache = <span class="keyword">new</span> LFUCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        cache.set(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        cache.set(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        cache.set(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        cache.set(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        cache.set(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        cache.set(<span class="string">"C"</span>, <span class="number">3</span>);</span><br><span class="line">        cache.set(<span class="string">"D"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"break point"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="手写二叉搜索树"><a href="#手写二叉搜索树" class="headerlink" title="手写二叉搜索树"></a>手写二叉搜索树</h2><blockquote>
<p>下列代码来源于<code>github</code></p>
</blockquote>
<h4 id="AbstractBinarySearchTree"><a href="#AbstractBinarySearchTree" class="headerlink" title="AbstractBinarySearchTree"></a>AbstractBinarySearchTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Abstract binary search tree implementation. Its basically fully implemented</span></span><br><span class="line"><span class="comment"> * binary search tree, just template method is provided for creating Node (other</span></span><br><span class="line"><span class="comment"> * trees can have slightly different nodes with more info). This way some code</span></span><br><span class="line"><span class="comment"> * from standart binary search tree can be reused for other kinds of binary</span></span><br><span class="line"><span class="comment"> * trees.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ignas Lelys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> Jun 29, 2011</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Root node where whole tree starts. */</span></span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Tree size. */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Because this is abstract class and various trees have different</span></span><br><span class="line"><span class="comment">	 * additional information on different nodes subclasses uses this abstract</span></span><br><span class="line"><span class="comment">	 * method to create nodes (maybe of class &#123;<span class="doctag">@link</span> Node&#125; or maybe some</span></span><br><span class="line"><span class="comment">	 * different node sub class).</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">	 *            Value that node will have.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">	 *            Node's parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">	 *            Node's left child.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">	 *            Node's right child.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Created node instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> value, Node parent, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(value, parent, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Finds a node with concrete value. If it is not found then null is</span></span><br><span class="line"><span class="comment">	 * returned.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 *            Element value.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Node with value provided, or null if not found.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.value != <span class="keyword">null</span> &amp;&amp; node.value != element) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element &lt; node.value) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Insert new element to tree.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 *            Element to insert.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = createNode(element, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node insertParentNode = <span class="keyword">null</span>;</span><br><span class="line">        Node searchTempNode = root;</span><br><span class="line">        <span class="keyword">while</span> (searchTempNode != <span class="keyword">null</span> &amp;&amp; searchTempNode.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            insertParentNode = searchTempNode;</span><br><span class="line">            <span class="keyword">if</span> (element &lt; searchTempNode.value) &#123;</span><br><span class="line">                searchTempNode = searchTempNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                searchTempNode = searchTempNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node newNode = createNode(element, insertParentNode, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (insertParentNode.value &gt; newNode.value) &#123;</span><br><span class="line">            insertParentNode.left = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insertParentNode.right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Removes element if node with such value exists.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 *            Element value to remove.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> New node that is in place of deleted node. Or null if element for</span></span><br><span class="line"><span class="comment">	 *         delete was not found.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">delete</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        Node deleteNode = search(element);</span><br><span class="line">        <span class="keyword">if</span> (deleteNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> delete(deleteNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Delete logic when node is already found.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> deleteNode</span></span><br><span class="line"><span class="comment">	 *            Node that needs to be deleted.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> New node that is in place of deleted node. Or null if element for</span></span><br><span class="line"><span class="comment">	 *         delete was not found.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">delete</span><span class="params">(Node deleteNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deleteNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node nodeToReturn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (deleteNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nodeToReturn = transplant(deleteNode, deleteNode.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nodeToReturn = transplant(deleteNode, deleteNode.left);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node successorNode = getMinimum(deleteNode.right);</span><br><span class="line">                    <span class="keyword">if</span> (successorNode.parent != deleteNode) &#123;</span><br><span class="line">                        transplant(successorNode, successorNode.right);</span><br><span class="line">                        successorNode.right = deleteNode.right;</span><br><span class="line">                        successorNode.right.parent = successorNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    transplant(deleteNode, successorNode);</span><br><span class="line">                    successorNode.left = deleteNode.left;</span><br><span class="line">                    successorNode.left.parent = successorNode;</span><br><span class="line">                    nodeToReturn = successorNode;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nodeToReturn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Put one node from tree (newNode) to the place of another (nodeToReplace).</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nodeToReplace</span></span><br><span class="line"><span class="comment">	 *            Node which is replaced by newNode and removed from tree.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> newNode</span></span><br><span class="line"><span class="comment">	 *            New node.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> New replaced node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">transplant</span><span class="params">(Node nodeToReplace, Node newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeToReplace.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeToReplace == nodeToReplace.parent.left) &#123;</span><br><span class="line">            nodeToReplace.parent.left = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeToReplace.parent.right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newNode.parent = nodeToReplace.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true if tree contains element.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(element) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Minimum element in tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMinimum(root).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Maximum element in tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMaximum(root).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Get next element element who is bigger than provided element.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 *            Element for whom descendand element is searched</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Successor value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// TODO Predecessor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuccessor</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSuccessor(search(element)).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Number of elements in the tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Tree traversal with printing element values. In order method.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeInOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printTreeInOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Tree traversal with printing element values. Pre order method.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreePreOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printTreePreOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Tree traversal with printing element values. Post order method.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreePostOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printTreePostOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------PRIVATE HELPER METHODS-------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeInOrder</span><span class="params">(Node entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printTreeInOrder(entry.left);</span><br><span class="line">            <span class="keyword">if</span> (entry.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            printTreeInOrder(entry.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreePreOrder</span><span class="params">(Node entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            printTreeInOrder(entry.left);</span><br><span class="line">            printTreeInOrder(entry.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreePostOrder</span><span class="params">(Node entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printTreeInOrder(entry.left);</span><br><span class="line">            printTreeInOrder(entry.right);</span><br><span class="line">            <span class="keyword">if</span> (entry.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">getMinimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">getMaximum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">getSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if there is right branch, then successor is leftmost node of that</span></span><br><span class="line">        <span class="comment">// subtree</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getMinimum(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// otherwise it is a lowest ancestor whose left child is also</span></span><br><span class="line">            <span class="comment">// ancestor of node</span></span><br><span class="line">            Node currentNode = node;</span><br><span class="line">            Node parentNode = node.parent;</span><br><span class="line">            <span class="keyword">while</span> (parentNode != <span class="keyword">null</span> &amp;&amp; currentNode == parentNode.right) &#123;</span><br><span class="line">                <span class="comment">// go up until we find parent that currentNode is not in right</span></span><br><span class="line">                <span class="comment">// subtree.</span></span><br><span class="line">                currentNode = parentNode;</span><br><span class="line">                parentNode = parentNode.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parentNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------- TREE PRINTING</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printSubtree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSubtree</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printTree(node.right, <span class="keyword">true</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printNodeValue(node);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printTree(node.left, <span class="keyword">false</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNodeValue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"&lt;null&gt;"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(node.value.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node node, <span class="keyword">boolean</span> isRight, String indent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printTree(node.right, <span class="keyword">true</span>, indent + (isRight ? <span class="string">"        "</span> : <span class="string">" |      "</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(indent);</span><br><span class="line">        <span class="keyword">if</span> (isRight) &#123;</span><br><span class="line">            System.out.print(<span class="string">" /"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">" \\"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"----- "</span>);</span><br><span class="line">        printNodeValue(node);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printTree(node.left, <span class="keyword">false</span>, indent + (isRight ? <span class="string">" |      "</span> : <span class="string">"        "</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer value, Node parent, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer value;</span><br><span class="line">        <span class="keyword">public</span> Node parent;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">            result = prime * result + ((value == <span class="keyword">null</span>) ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Node other = (Node) obj;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (other.value != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!value.equals(other.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractSelfBalancingBinarySearchTree"><a href="#AbstractSelfBalancingBinarySearchTree" class="headerlink" title="AbstractSelfBalancingBinarySearchTree"></a>AbstractSelfBalancingBinarySearchTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Abstract class for self balancing binary search trees. Contains some methods</span></span><br><span class="line"><span class="comment"> * that is used for self balancing trees.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ignas Lelys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> Jul 24, 2011</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSelfBalancingBinarySearchTree</span> <span class="keyword">extends</span> <span class="title">AbstractBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rotate to the left.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node Node on which to rotate.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node that is in place of provided node after rotation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">rotateLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = node.right;</span><br><span class="line">        temp.parent = node.parent;</span><br><span class="line"></span><br><span class="line">        node.right = temp.left;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.right.parent = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.left = node;</span><br><span class="line">        node.parent = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// temp took over node's place so now its parent should point to temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == temp.parent.left) &#123;</span><br><span class="line">                temp.parent.left = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.parent.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rotate to the right.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node Node on which to rotate.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node that is in place of provided node after rotation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">rotateRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = node.left;</span><br><span class="line">        temp.parent = node.parent;</span><br><span class="line"></span><br><span class="line">        node.left = temp.right;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.left.parent = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.right = node;</span><br><span class="line">        node.parent = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// temp took over node's place so now its parent should point to temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == temp.parent.left) &#123;</span><br><span class="line">                temp.parent.left = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.parent.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AVLTree"><a href="#AVLTree" class="headerlink" title="AVLTree"></a>AVLTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * AVL tree implementation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In computer science, an AVL tree is a self-balancing binary search tree, and</span></span><br><span class="line"><span class="comment"> * it was the first such data structure to be invented.[1] In an AVL tree, the</span></span><br><span class="line"><span class="comment"> * heights of the two child subtrees of any node differ by at most one. Lookup,</span></span><br><span class="line"><span class="comment"> * insertion, and deletion all take O(log n) time in both the average and worst</span></span><br><span class="line"><span class="comment"> * cases, where n is the number of nodes in the tree prior to the operation.</span></span><br><span class="line"><span class="comment"> * Insertions and deletions may require the tree to be rebalanced by one or more</span></span><br><span class="line"><span class="comment"> * tree rotations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ignas Lelys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> Jun 28, 2011</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> <span class="keyword">extends</span> <span class="title">AbstractSelfBalancingBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> trees.AbstractBinarySearchTree#insert(int)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *      AVL tree insert method also balances tree if needed. Additional</span></span><br><span class="line"><span class="comment">     *      height parameter on node is used to track if one subtree is higher</span></span><br><span class="line"><span class="comment">     *      than other by more than one, if so AVL tree rotations is performed</span></span><br><span class="line"><span class="comment">     *      to regain balance of the tree.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">super</span>.insert(element);</span><br><span class="line">        rebalance((AVLNode)newNode);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> trees.AbstractBinarySearchTree#delete(int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">delete</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        Node deleteNode = <span class="keyword">super</span>.search(element);</span><br><span class="line">        <span class="keyword">if</span> (deleteNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node successorNode = <span class="keyword">super</span>.delete(deleteNode);</span><br><span class="line">            <span class="keyword">if</span> (successorNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// if replaced from getMinimum(deleteNode.right) then come back there and update heights</span></span><br><span class="line">                AVLNode minimum = successorNode.right != <span class="keyword">null</span> ? (AVLNode)getMinimum(successorNode.right) : (AVLNode)successorNode;</span><br><span class="line">                recomputeHeight(minimum);</span><br><span class="line">                rebalance((AVLNode)minimum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                recomputeHeight((AVLNode)deleteNode.parent);</span><br><span class="line">                rebalance((AVLNode)deleteNode.parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> successorNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> trees.AbstractBinarySearchTree#createNode(int, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> value, Node parent, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AVLNode(value, parent, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Go up from inserted node, and update height and balance informations if needed.</span></span><br><span class="line"><span class="comment">     * If some node balance reaches 2 or -2 that means that subtree must be rebalanced.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node Inserted Node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalance</span><span class="params">(AVLNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Node parent = node.parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> leftHeight = (node.left == <span class="keyword">null</span>) ? -<span class="number">1</span> : ((AVLNode) node.left).height;</span><br><span class="line">            <span class="keyword">int</span> rightHeight = (node.right == <span class="keyword">null</span>) ? -<span class="number">1</span> : ((AVLNode) node.right).height;</span><br><span class="line">            <span class="keyword">int</span> nodeBalance = rightHeight - leftHeight;</span><br><span class="line">            <span class="comment">// rebalance (-2 means left subtree outgrow, 2 means right subtree)</span></span><br><span class="line">            <span class="keyword">if</span> (nodeBalance == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.right.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node = (AVLNode)avlRotateLeft(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = (AVLNode)doubleRotateRightLeft(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeBalance == -<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node = (AVLNode)avlRotateRight(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = (AVLNode)doubleRotateLeftRight(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                updateHeight(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = (AVLNode)parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rotates to left side.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">avlRotateLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = <span class="keyword">super</span>.rotateLeft(node);</span><br><span class="line"></span><br><span class="line">        updateHeight((AVLNode)temp.left);</span><br><span class="line">        updateHeight((AVLNode)temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rotates to right side.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">avlRotateRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = <span class="keyword">super</span>.rotateRight(node);</span><br><span class="line"></span><br><span class="line">        updateHeight((AVLNode)temp.right);</span><br><span class="line">        updateHeight((AVLNode)temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Take right child and rotate it to the right side first and then rotate</span></span><br><span class="line"><span class="comment">     * node to the left side.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">doubleRotateRightLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.right = avlRotateRight(node.right);</span><br><span class="line">        <span class="keyword">return</span> avlRotateLeft(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Take right child and rotate it to the right side first and then rotate</span></span><br><span class="line"><span class="comment">     * node to the left side.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">doubleRotateLeftRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.left = avlRotateLeft(node.left);</span><br><span class="line">        <span class="keyword">return</span> avlRotateRight(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recomputes height information from the node and up for all of parents. It needs to be done after delete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recomputeHeight</span><span class="params">(AVLNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.height = maxHeight((AVLNode)node.left, (AVLNode)node.right) + <span class="number">1</span>;</span><br><span class="line">            node = (AVLNode)node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns higher height of 2 nodes. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxHeight</span><span class="params">(AVLNode node1, AVLNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node1.height &gt; node2.height ? node1.height : node2.height;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node2 != <span class="keyword">null</span> ? node2.height : -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node1 != <span class="keyword">null</span> ? node1.height : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Updates height and balance of the node.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node Node for which height and balance must be updated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(AVLNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = (node.left == <span class="keyword">null</span>) ? -<span class="number">1</span> : ((AVLNode) node.left).height;</span><br><span class="line">        <span class="keyword">int</span> rightHeight = (node.right == <span class="keyword">null</span>) ? -<span class="number">1</span> : ((AVLNode) node.right).height;</span><br><span class="line">        node.height = <span class="number">1</span> + Math.max(leftHeight, rightHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node of AVL tree has height and balance additional properties. If balance</span></span><br><span class="line"><span class="comment">     * equals 2 (or -2) that node needs to be re balanced. (Height is height of</span></span><br><span class="line"><span class="comment">     * the subtree starting with this node, and balance is difference between</span></span><br><span class="line"><span class="comment">     * left and right nodes heights).</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Ignas Lelys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@created</span> Jun 30, 2011</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AVLNode</span><span class="params">(<span class="keyword">int</span> value, Node parent, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(value, parent, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RedBlackTree"><a href="#RedBlackTree" class="headerlink" title="RedBlackTree"></a>RedBlackTree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Red-Black tree implementation. From Introduction to Algorithms 3rd edition.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ignas Lelys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> May 6, 2011</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span> <span class="keyword">extends</span> <span class="title">AbstractSelfBalancingBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">enum</span> ColorEnum &#123;</span><br><span class="line">        RED,</span><br><span class="line">        BLACK</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> RedBlackNode nilNode = <span class="keyword">new</span> RedBlackNode(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, ColorEnum.BLACK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> trees.AbstractBinarySearchTree#insert(int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">super</span>.insert(element);</span><br><span class="line">        newNode.left = nilNode;</span><br><span class="line">        newNode.right = nilNode;</span><br><span class="line">        root.parent = nilNode;</span><br><span class="line">        insertRBFixup((RedBlackNode) newNode);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Slightly modified delete routine for red-black tree.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">delete</span><span class="params">(Node deleteNode)</span> </span>&#123;</span><br><span class="line">        Node replaceNode = <span class="keyword">null</span>; <span class="comment">// track node that replaces removedOrMovedNode</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode != <span class="keyword">null</span> &amp;&amp; deleteNode != nilNode) &#123;</span><br><span class="line">            Node removedOrMovedNode = deleteNode; <span class="comment">// same as deleteNode if it has only one child, and otherwise it replaces deleteNode</span></span><br><span class="line">            ColorEnum removedOrMovedNodeColor = ((RedBlackNode)removedOrMovedNode).color;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deleteNode.left == nilNode) &#123;</span><br><span class="line">                replaceNode = deleteNode.right;</span><br><span class="line">                rbTreeTransplant(deleteNode, deleteNode.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.right == nilNode) &#123;</span><br><span class="line">                replaceNode = deleteNode.left;</span><br><span class="line">                rbTreeTransplant(deleteNode, deleteNode.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removedOrMovedNode = getMinimum(deleteNode.right);</span><br><span class="line">                removedOrMovedNodeColor = ((RedBlackNode)removedOrMovedNode).color;</span><br><span class="line">                replaceNode = removedOrMovedNode.right;</span><br><span class="line">                <span class="keyword">if</span> (removedOrMovedNode.parent == deleteNode) &#123;</span><br><span class="line">                    replaceNode.parent = removedOrMovedNode;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rbTreeTransplant(removedOrMovedNode, removedOrMovedNode.right);</span><br><span class="line">                    removedOrMovedNode.right = deleteNode.right;</span><br><span class="line">                    removedOrMovedNode.right.parent = removedOrMovedNode;</span><br><span class="line">                &#125;</span><br><span class="line">                rbTreeTransplant(deleteNode, removedOrMovedNode);</span><br><span class="line">                removedOrMovedNode.left = deleteNode.left;</span><br><span class="line">                removedOrMovedNode.left.parent = removedOrMovedNode;</span><br><span class="line">                ((RedBlackNode)removedOrMovedNode).color = ((RedBlackNode)deleteNode).color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (removedOrMovedNodeColor == ColorEnum.BLACK) &#123;</span><br><span class="line">                deleteRBFixup((RedBlackNode)replaceNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> replaceNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> trees.AbstractBinarySearchTree#createNode(int, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> value, Node parent, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedBlackNode(value, parent, left, right, ColorEnum.RED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">getMinimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node.left != nilNode) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">getMaximum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node.right != nilNode) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">rotateLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = node.right;</span><br><span class="line">        temp.parent = node.parent;</span><br><span class="line"></span><br><span class="line">        node.right = temp.left;</span><br><span class="line">        <span class="keyword">if</span> (node.right != nilNode) &#123;</span><br><span class="line">            node.right.parent = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.left = node;</span><br><span class="line">        node.parent = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// temp took over node's place so now its parent should point to temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent != nilNode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == temp.parent.left) &#123;</span><br><span class="line">                temp.parent.left = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.parent.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node <span class="title">rotateRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = node.left;</span><br><span class="line">        temp.parent = node.parent;</span><br><span class="line"></span><br><span class="line">        node.left = temp.right;</span><br><span class="line">        <span class="keyword">if</span> (node.left != nilNode) &#123;</span><br><span class="line">            node.left.parent = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.right = node;</span><br><span class="line">        node.parent = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// temp took over node's place so now its parent should point to temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.parent != nilNode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == temp.parent.left) &#123;</span><br><span class="line">                temp.parent.left = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.parent.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Similar to original transplant() method in BST but uses nilNode instead of null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rbTreeTransplant</span><span class="params">(Node nodeToReplace, Node newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeToReplace.parent == nilNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeToReplace == nodeToReplace.parent.left) &#123;</span><br><span class="line">            nodeToReplace.parent.left = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeToReplace.parent.right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.parent = nodeToReplace.parent;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Restores Red-Black tree properties after delete if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteRBFixup</span><span class="params">(RedBlackNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != root &amp;&amp; isBlack(x)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">                RedBlackNode w = (RedBlackNode)x.parent.right;</span><br><span class="line">                <span class="keyword">if</span> (isRed(w)) &#123; <span class="comment">// case 1 - sibling is red</span></span><br><span class="line">                    w.color = ColorEnum.BLACK;</span><br><span class="line">                    ((RedBlackNode)x.parent).color = ColorEnum.RED;</span><br><span class="line">                    rotateLeft(x.parent);</span><br><span class="line">                    w = (RedBlackNode)x.parent.right; <span class="comment">// converted to case 2, 3 or 4</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// case 2 sibling is black and both of its children are black</span></span><br><span class="line">                <span class="keyword">if</span> (isBlack(w.left) &amp;&amp; isBlack(w.right)) &#123;</span><br><span class="line">                    w.color = ColorEnum.RED;</span><br><span class="line">                    x = (RedBlackNode)x.parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w != nilNode) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isBlack(w.right)) &#123; <span class="comment">// case 3 sibling is black and its left child is red and right child is black</span></span><br><span class="line">                        ((RedBlackNode)w.left).color = ColorEnum.BLACK;</span><br><span class="line">                        w.color = ColorEnum.RED;</span><br><span class="line">                        rotateRight(w);</span><br><span class="line">                        w = (RedBlackNode)x.parent.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    w.color = ((RedBlackNode)x.parent).color; <span class="comment">// case 4 sibling is black and right child is red</span></span><br><span class="line">                    ((RedBlackNode)x.parent).color = ColorEnum.BLACK;</span><br><span class="line">                    ((RedBlackNode)w.right).color = ColorEnum.BLACK;</span><br><span class="line">                    rotateLeft(x.parent);</span><br><span class="line">                    x = (RedBlackNode)root;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x.color = ColorEnum.BLACK;</span><br><span class="line">                    x = (RedBlackNode)x.parent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RedBlackNode w = (RedBlackNode)x.parent.left;</span><br><span class="line">                <span class="keyword">if</span> (isRed(w)) &#123; <span class="comment">// case 1 - sibling is red</span></span><br><span class="line">                    w.color = ColorEnum.BLACK;</span><br><span class="line">                    ((RedBlackNode)x.parent).color = ColorEnum.RED;</span><br><span class="line">                    rotateRight(x.parent);</span><br><span class="line">                    w = (RedBlackNode)x.parent.left; <span class="comment">// converted to case 2, 3 or 4</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// case 2 sibling is black and both of its children are black</span></span><br><span class="line">                <span class="keyword">if</span> (isBlack(w.left) &amp;&amp; isBlack(w.right)) &#123;</span><br><span class="line">                    w.color = ColorEnum.RED;</span><br><span class="line">                    x = (RedBlackNode)x.parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w != nilNode) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isBlack(w.left)) &#123; <span class="comment">// case 3 sibling is black and its right child is red and left child is black</span></span><br><span class="line">                        ((RedBlackNode)w.right).color = ColorEnum.BLACK;</span><br><span class="line">                        w.color = ColorEnum.RED;</span><br><span class="line">                        rotateLeft(w);</span><br><span class="line">                        w = (RedBlackNode)x.parent.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    w.color = ((RedBlackNode)x.parent).color; <span class="comment">// case 4 sibling is black and left child is red</span></span><br><span class="line">                    ((RedBlackNode)x.parent).color = ColorEnum.BLACK;</span><br><span class="line">                    ((RedBlackNode)w.left).color = ColorEnum.BLACK;</span><br><span class="line">                    rotateRight(x.parent);</span><br><span class="line">                    x = (RedBlackNode)root;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x.color = ColorEnum.BLACK;</span><br><span class="line">                    x = (RedBlackNode)x.parent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> ? ((RedBlackNode)node).color == ColorEnum.BLACK : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> ? ((RedBlackNode)node).color == ColorEnum.RED : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Restores Red-Black tree properties after insert if needed. Insert can</span></span><br><span class="line"><span class="comment">     * break only 2 properties: root is red or if node is red then children must</span></span><br><span class="line"><span class="comment">     * be black.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertRBFixup</span><span class="params">(RedBlackNode currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// current node is always RED, so if its parent is red it breaks</span></span><br><span class="line">        <span class="comment">// Red-Black property, otherwise no fixup needed and loop can terminate</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode.parent != root &amp;&amp; ((RedBlackNode) currentNode.parent).color == ColorEnum.RED) &#123;</span><br><span class="line">            RedBlackNode parent = (RedBlackNode) currentNode.parent;</span><br><span class="line">            RedBlackNode grandParent = (RedBlackNode) parent.parent;</span><br><span class="line">            <span class="keyword">if</span> (parent == grandParent.left) &#123;</span><br><span class="line">                RedBlackNode uncle = (RedBlackNode) grandParent.right;</span><br><span class="line">                <span class="comment">// case1 - uncle and parent are both red</span></span><br><span class="line">                <span class="comment">// re color both of them to black</span></span><br><span class="line">                <span class="keyword">if</span> (((RedBlackNode) uncle).color == ColorEnum.RED) &#123;</span><br><span class="line">                    parent.color = ColorEnum.BLACK;</span><br><span class="line">                    uncle.color = ColorEnum.BLACK;</span><br><span class="line">                    grandParent.color = ColorEnum.RED;</span><br><span class="line">                    <span class="comment">// grandparent was recolored to red, so in next iteration we</span></span><br><span class="line">                    <span class="comment">// check if it does not break Red-Black property</span></span><br><span class="line">                    currentNode = grandParent;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// case 2/3 uncle is black - then we perform rotations</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == parent.right) &#123; <span class="comment">// case 2, first rotate left</span></span><br><span class="line">                        currentNode = parent;</span><br><span class="line">                        rotateLeft(currentNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// do not use parent</span></span><br><span class="line">                    parent.color = ColorEnum.BLACK; <span class="comment">// case 3</span></span><br><span class="line">                    grandParent.color = ColorEnum.RED;</span><br><span class="line">                    rotateRight(grandParent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == grandParent.right) &#123;</span><br><span class="line">                RedBlackNode uncle = (RedBlackNode) grandParent.left;</span><br><span class="line">                <span class="comment">// case1 - uncle and parent are both red</span></span><br><span class="line">                <span class="comment">// re color both of them to black</span></span><br><span class="line">                <span class="keyword">if</span> (((RedBlackNode) uncle).color == ColorEnum.RED) &#123;</span><br><span class="line">                    parent.color = ColorEnum.BLACK;</span><br><span class="line">                    uncle.color = ColorEnum.BLACK;</span><br><span class="line">                    grandParent.color = ColorEnum.RED;</span><br><span class="line">                    <span class="comment">// grandparent was recolored to red, so in next iteration we</span></span><br><span class="line">                    <span class="comment">// check if it does not break Red-Black property</span></span><br><span class="line">                    currentNode = grandParent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// case 2/3 uncle is black - then we perform rotations</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == parent.left) &#123; <span class="comment">// case 2, first rotate right</span></span><br><span class="line">                        currentNode = parent;</span><br><span class="line">                        rotateRight(currentNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// do not use parent</span></span><br><span class="line">                    parent.color = ColorEnum.BLACK; <span class="comment">// case 3</span></span><br><span class="line">                    grandParent.color = ColorEnum.RED;</span><br><span class="line">                    rotateLeft(grandParent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ensure root is black in case it was colored red in fixup</span></span><br><span class="line">        ((RedBlackNode) root).color = ColorEnum.BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ColorEnum color;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RedBlackNode</span><span class="params">(Integer value, Node parent, Node left, Node right, ColorEnum color &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">super</span>(value, parent, left, right)</span></span>;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>左神算法进阶</category>
        <category>缓存结构设计</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法笔记进阶-从暴力尝试到动态规划</title>
    <url>/2020/03/12/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6-%E4%BB%8E%E6%9A%B4%E5%8A%9B%E5%B0%9D%E8%AF%95%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>动态规划不是玄学，也无需去记那些所谓的刻板的“公式”（例如状态转换表达式等），其实动态规划是从暴力递归而来。并不是说一个可以动态规划的题一上来就可以写出动态规划的求解步骤，我们只需要能够写出暴力递归版本，然后对重复计算的子过程结果做一个缓存，最后分析状态依赖寻求最优解，即衍生成了动态规划。本节将以多个例题示例，展示求解过程是如何从暴力尝试，一步步到动态规划的。</p><a id="more"></a>
<h2 id="换钱的方法数"><a href="#换钱的方法数" class="headerlink" title="换钱的方法数"></a>换钱的方法数</h2><p><strong>题目</strong>：给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。</p>
<p>举例：<code>arr=[5,10,25,1]，aim=0</code>：成0元的方法有1种，就是所有面值的货币都不用。所以返回1。<code>arr=[5,10,25,1]，aim=15</code>：组成15元的方法有6种，分别为3张5元、1张10元+1张5元、1张10元+5张1元、10张1元+1张5元、2张5元+5张1元和15张1元。所以返回6。<code>arr=[3,5]，aim=2</code>：任何方法都无法组成2元。所以返回0。</p>
<h3 id="暴力尝试"><a href="#暴力尝试" class="headerlink" title="暴力尝试"></a>暴力尝试</h3><p>我们可以将该题要求解的问题定义成一个过程：对于下标<code>index</code>，<code>arr</code>中在<code>index</code>及其之后的所有面值不限张数任意组合，该过程最终返回所有有效的组合方案。因此该过程可以描述为<code>int process(int arr[],int index,int aim)</code>，题目的解就是调用<code>process(arr,0,aim)</code>。那么函数内部具体该如何解决此问题呢？</p>
<p>其实所有面值不限张数的任意组合就是对每一个面值需要多少张的一个<strong>决策</strong>，那我们不妨从碰到的第一个面值开始决策，比如 <code>arr=[5,10,25,1]，aim=15</code>时，（ 选0张5元之后剩下的面值不限张数组合成15元的方法数 + 选1张5元之后剩下的面值不限张数组合成10元方法数 + 选2张5元之后剩下的面值不限张数组合成5元方法数 + 选3张5元之后剩下的面值不限张数组合成0元方法数 ）就是所给参数对应的解，其中“剩下的面值不限张数组合成一定的钱数”又是同类问题，可以使用相同的过程求解，因此有了如下的暴力递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arr中的每个元素代表一个货币面值，使用数组index及其之后的面值（不限张数）</span></span><br><span class="line"><span class="comment">     * 拼凑成钱数为aim的方法有多少种，返回种数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//index位置面值的决策，从0张开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> zhangshu = <span class="number">0</span>; arr[index] * zhangshu &lt;= aim; zhangshu++) &#123;</span><br><span class="line">        res += process(arr, index + <span class="number">1</span>, aim - (arr[index] * zhangshu));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swapMoneyMethods</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    System.out.println(swapMoneyMethods(arr, <span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存每个状态的结果，以免重复计算"><a href="#缓存每个状态的结果，以免重复计算" class="headerlink" title="缓存每个状态的结果，以免重复计算"></a>缓存每个状态的结果，以免重复计算</h3><p>上述的暴力递归是极其暴力的，比如对于参数 <code>arr=[5，3，1，30，15，20，10]，aim=100</code>来说，如果已经决策了<code>3张5元+0张3元+0张1元</code>的接着会调子过程<code>process(arr, 3, 85)</code>；如果已经决策了<code>0张5元+5张3元+0张1元</code>接着也会调子过程<code>process(arr, 3, 85)</code>；如果已经决策了<code>0张5元+0张3元+15张1元</code>接着还是会调子过程<code>process(arr, 3, 85)</code>。</p>
<p>你会发现，这个已知面额种类和要凑的钱数，求凑钱的方法的解是固定的。也就是说不管之前的决策是3张5元的，还是5张3元的，又或是15张1元的，对后续子过程的<code>[30，15，20，10]</code>凑成<code>85</code>这个问题的解是不影响的，这个解该是多少还是多少。这也是<strong>无后效性问题</strong>。无后效性问题就是某一状态的求解不依赖其他状态，比如著名的N皇后问题就是有后效性问题。</p>
<p>因此，我们不妨再求解一个状态之后，将该状态对应的解做个缓存，在后续的状态求解时先到缓存中找是否有该状态的解，有则直接使用，没有再求解并放入缓存，这样就不会有重复计算的情况了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swapMoneyMethods</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process2(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用哈希表左缓存容器</span></span><br><span class="line"><span class="comment">* key是某个状态的代号，value是该状态对应的解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> zhangshu = <span class="number">0</span>; arr[index] * zhangshu &lt;= aim; zhangshu++) &#123;</span><br><span class="line">        <span class="comment">//使用index及其之后的面值拼凑成aim的方法数这个状态的代号：index_aim</span></span><br><span class="line">        String key = String.valueOf(index) + <span class="string">"_"</span> + String.valueOf(aim);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            res += map.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = process(arr, index + <span class="number">1</span>, aim - (arr[index] * zhangshu));</span><br><span class="line">            key = String.valueOf(index + <span class="number">1</span>) + <span class="string">"_"</span> + String.valueOf(aim - (arr[index] * zhangshu));</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            res += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    System.out.println(swapMoneyMethods(arr, <span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="确定依赖关系，寻找最优解"><a href="#确定依赖关系，寻找最优解" class="headerlink" title="确定依赖关系，寻找最优解"></a>确定依赖关系，寻找最优解</h3><p>当然，借助缓存已经将暴力递归的时间复杂度拉低了很多，但这还不是最优解。下面我们将以寻求最优解为引导，挖掘出动态规划中的状态转换。</p>
<p>从暴力尝试到动态规划，我们只需观察暴力尝试版本的代码，甚至可以忘却题目，按照下面高度套路化的步骤，就可以轻易改出动态规划：</p>
<ol>
<li><p>首先每个状态都有两个参数<code>index</code>和<code>aim</code>（<code>arr</code>作为输入参数是不变的），因此可以对应两个变量的变化范围建立一张二维表：</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program.png" alt> </p>
</li>
</ol>
<ol start="2">
<li><p>从<code>base case</code>中找出特殊位置的解。比如<code>if(index==arr.length) return aim==0?1:0</code>，那么上述二维表的最后一行对应的所有状态可以直接求解：</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program1.png" alt> </p>
</li>
<li><p>从暴力递归中找出普遍位置对应的状态所依赖的其他状态。比如：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> zhangshu = <span class="number">0</span>; arr[index] * zhangshu &lt;= aim; zhangshu++) &#123;</span><br><span class="line">    res += process(arr, index + <span class="number">1</span>, aim - (arr[index] * zhangshu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 那么对于二维表中的一个普遍位置<code>(i,j)</code>，它所依赖的状态如下所示：</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program2.png" alt> </p>
<p> 也就是说一个普遍位置的状态依赖它的下一行的几个位置上的状态。那么我们已经知道了最后一行所有位置上的状态，当然可以根据这个依赖关系推出倒数第二行的，继而推出倒数第三行的……整个二维表的所有位置上的状态都能推出来。</p>
</li>
<li><p>找出主问题对应二维表的哪个状态（<code>(0,maxAim)</code>），那个状态的值就是问题的解。</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxMethodsDp</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二维表</span></span><br><span class="line">    <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[arr.length][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从倒数第二行开始推，推出整个二维表每个位置的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">            <span class="comment">//i对应的面值取0张</span></span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">//i对应的面值取1张、2张、3张……</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> subAim = j - arr[i]; subAim &gt;= <span class="number">0</span>; subAim = subAim - arr[i]) &#123;</span><br><span class="line">                dp[i][j] += dp[i + <span class="number">1</span>][subAim];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    System.out.println(maxMethodsDp(arr, <span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里也许你会送一口气，终于找到了最优解，其实不然，因为如果你再分析一下每个状态的求解过程，仍然存在瑕疵：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program3.png" alt> </p>
<p>比如你在求解状态A时，可能会将其依赖的状态M,N,P的值累加起来；然后在求解状态B时，有需要将其依赖的状态M,N,P,Q累加起来，你会发现在这个过程中<code>M+N+P</code>的计算是重复的，因此还可以有如下优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">        dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j - arr[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] += dp[i][j - arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，此题最优解的求解完毕。</p>
<h2 id="排成一条线的纸牌博弈问题"><a href="#排成一条线的纸牌博弈问题" class="headerlink" title="排成一条线的纸牌博弈问题"></a>排成一条线的纸牌博弈问题</h2><p><strong>题目：</strong>给定一个整型数组arr，代表分数不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。</p>
<p><strong>举例：</strong><code>arr=[1,2,100,4]</code>。开始时玩家A只能拿走1或4。如果玩家A拿走1，则排列变为<code>[2,100,4]</code>，接下来玩家B可以拿走2或4，然后继续轮到玩家A。如果开始时玩家A拿走4，则排列变为<code>[1,2,100]</code>，接下来玩家B可以拿走1或100，然后继续轮到玩家A。玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，让排列变为<code>[2,100,4]</code>，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。<code>arr=[1,100,2]</code>。开始时玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回100。</p>
<blockquote>
<p>动态规划的题难就难在暴力尝试这个“试”法，只要能够试出了暴力版本，那改为动态规划就是高度套路的。</p>
</blockquote>
<h3 id="暴力尝试-1"><a href="#暴力尝试-1" class="headerlink" title="暴力尝试"></a>暴力尝试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxScoreOfWinner</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(</span><br><span class="line">        f(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>),</span><br><span class="line">        s(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex == endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[beginIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(</span><br><span class="line">        arr[beginIndex] + s(arr, beginIndex + <span class="number">1</span>, endIndex),</span><br><span class="line">        arr[endIndex] + s(arr, beginIndex, endIndex - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex == endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(</span><br><span class="line">        f(arr, beginIndex + <span class="number">1</span>, endIndex),</span><br><span class="line">        f(arr, beginIndex, endIndex - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    System.out.println(maxScoreOfWinner(arr));<span class="comment">//101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题的试法其实很不容易，笔者直接看别人写出的暴力尝试版本表示根本看不懂，最后还是搜了博文才弄懂。其中<code>f()</code>和<code>s()</code>就是整个尝试中的思路，与以往穷举法的暴力递归不同，这里是两个函数相互递归调用。</p>
<p><code>f(int arr[],int begin,int end)</code>表示如果纸牌只剩下标在<code>begin~end</code>之间的几个了，那么作为先拿者，纸牌被拿完后，先拿者能达到的最大分数；而<code>s(int arr[],int begin,int end)</code>表示如果纸牌只剩下标在<code>begin~end</code>之间的几个了，那么作为后拿者，纸牌被拿完后，后拿者能达到的最大分数。</p>
<p>在<code>f()</code>中，如果只有一张纸牌，那么该纸牌分数就是先拿者能达到的最大分数，直接返回，无需决策。否则先拿者A的第一次决策只有两种情况：</p>
<ul>
<li>先拿最左边的<code>arr[beginIndex]</code>，那么在A拿完这一张之后就会作为后拿者参与到剩下的<code>(begin+1)~end</code>之间的纸牌的决策了，这一过程可以交给<code>s()</code>来做。</li>
<li>先拿最右边的<code>arr[endIndex]</code>，那么在A拿完这一张之后就会作为后拿者参与到剩下的<code>begin~(end-1)</code>之间的纸牌的决策了，这一过程可以交给<code>s()</code>来做。</li>
</ul>
<p>最后返回两种情况中，<strong>结果较大</strong>的那种。</p>
<p>在<code>s()</code>中，如果只有一张纸牌，那么作为后拿者没有纸牌可拿，分数为0，直接返回。否则以假设的方式巧妙的将问题递归了下去：</p>
<ul>
<li>假设先拿者A拿到了<code>arr[beginIndex]</code>，那么去掉该纸牌后，对于剩下的<code>(begin+1)~end</code>之间的纸牌，后拿者B就转变身份成了先拿者，这一过程可以交给<code>f()</code>来处理。</li>
<li>假设先拿者A拿到了<code>arr[endIndex]</code>，那么去掉该纸牌后，对于剩下的<code>begin~(end-1)</code>之间的纸牌，后拿者B就转变身份成了先拿者，这一过程可以交给<code>f()</code>来处理。</li>
</ul>
<p>这里取两种情况中<strong>结果较小</strong>的一种，是因为这两种情况是我们假设的，但先拿者A绝顶聪明，他的选择肯定会让后拿者尽可能拿到更小的分数。比如<code>arr=[1,2,100,4]</code>，虽然我们的假设有先拿者拿<code>1</code>和拿<code>4</code>两种情况，对应<code>f(arr,1,3)</code>和<code>f(arr,0,2)</code>，但实际上先拿者不会让后拿者拿到<code>100</code>，因此取两种情况中结果较小的一种。</p>
<h3 id="改动态规划"><a href="#改动态规划" class="headerlink" title="改动态规划"></a>改动态规划</h3><p>这里是两个函数相互递归，每个函数的参数列表又都是<code>beginIndex</code>和<code>endIndex</code>是可变的，因此需要两张二维表保存<code>(begin,end)</code>确定时，<code>f()</code>和<code>s()</code>的状态值。</p>
<ol>
<li><p>确定<code>base case</code>对应的特殊位置上的状态值：</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program4.png" alt> </p>
<p> 可以发现两张表的对角线位置上的状态值都是可以确定的，<code>begin&lt;=end</code>，因此对角线左下方的区域不用管。</p>
</li>
<li><p>由递归调用逻辑找出状态依赖。</p>
<p> <code>f()</code>依赖的状态：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Math.max(</span><br><span class="line">                arr[beginIndex] + s(arr, beginIndex + <span class="number">1</span>, endIndex),</span><br><span class="line">                arr[endIndex] + s(arr, beginIndex, endIndex - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p> F表的<code>(begin,end)</code>依赖S表<code>(begin+1,end)</code>和<code>(begin,end-1)</code>。</p>
<p> <code>s()</code>依赖的状态：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Math.min(</span><br><span class="line">                f(arr, beginIndex + <span class="number">1</span>, endIndex),</span><br><span class="line">                f(arr, beginIndex, endIndex - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p> S表的<code>(begin,end)</code>依赖F表的<code>(begin+1,end)</code>和<code>(begin,end-1)</code>。</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program5.png" alt> </p>
<p> 如此的话，对于对角线的右上区域，对角线位置上的状态能推出倒数第二长对角线位置上的状态，进而推出倒数第三长位置上的状态……右上区域每个位置的状态都能推出。</p>
</li>
<li><p>确定主问题对应的状态：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Math.max(</span><br><span class="line">                f(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>),</span><br><span class="line">                s(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxScoreOfWinnerDp</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> F[][] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">    <span class="keyword">int</span> S[][] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                F[i][i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依次推出每条对角线，一共n-1条</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; arr.length - i; row++) &#123;</span><br><span class="line">            <span class="keyword">int</span> col = row + i;</span><br><span class="line">            F[row][col] = Math.max(arr[row] + S[row + <span class="number">1</span>][col], arr[col] + S[row][col - <span class="number">1</span>]);</span><br><span class="line">            S[row][col] = Math.min(F[row + <span class="number">1</span>][col], F[row][col - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(F[<span class="number">0</span>][arr.length - <span class="number">1</span>], S[<span class="number">0</span>][arr.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    System.out.println(maxScoreOfWinnerDp(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line"><span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">    f[j][j] = arr[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        f[i][j] = Math.max(arr[i] + s[i + <span class="number">1</span>][j], arr[j] + s[i][j - <span class="number">1</span>]);</span><br><span class="line">        s[i][j] = Math.min(f[i + <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(f[<span class="number">0</span>][arr.length - <span class="number">1</span>], s[<span class="number">0</span>][arr.length - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="机器人走路问题"><a href="#机器人走路问题" class="headerlink" title="机器人走路问题"></a>机器人走路问题</h2><p>给你标号为1、2、3、……、N的N个位置，机器人初始停在M位置上，走P步后停在K位置上的走法有多少种。注：机器人在1位置上时只能向右走，在N位置上时只能向左走，其它位置既可向右又可向左。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> P, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> M == K ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (M == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> process(N, M + <span class="number">1</span>, P - <span class="number">1</span>, K);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (M == N) &#123;</span><br><span class="line">        <span class="keyword">return</span> process(N, M - <span class="number">1</span>, P - <span class="number">1</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(N, M + <span class="number">1</span>, P - <span class="number">1</span>, K) + process(N, M - <span class="number">1</span>, P - <span class="number">1</span>, K);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(process(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里暴力递归参数列表的可变变量有<code>M</code>和<code>P</code>，根据<code>base case</code>和其它特殊情况画出二维表：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program6.png" alt> </p>
<p>动态规划示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">robotWalkWaysDp</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> P, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][P + <span class="number">1</span>];</span><br><span class="line">    dp[K][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= P; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &gt; N) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[M][P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(robotWalkWaysDp(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串正则匹配问题"><a href="#字符串正则匹配问题" class="headerlink" title="字符串正则匹配问题"></a>字符串正则匹配问题</h2><p>给定字符串<code>str</code>，其中绝对不含有字符<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>。再给定字符串<code>exp</code>，其中可以含有<code>&#39;.&#39;</code>或<code>&#39;*&#39;</code>，<code>&#39;*&#39;</code>字符不能是<code>exp</code>的首字符，并且任意两个<code>&#39;*&#39;</code>字符不相邻。exp中的<code>&#39;.&#39;</code>代表任何一个字符，exp中的<code>&#39;*&#39;</code>表示<code>&#39;*&#39;</code>的前一个字符可以有0个或者多个。请写一个函数，判断<code>str</code>是否能被<code>exp</code>匹配。</p>
<p>举例：</p>
<ul>
<li><code>str=&quot;abc&quot;，exp=&quot;abc&quot;</code>，返回<code>true</code>。<code>str=&quot;abc&quot;，exp=&quot;a.c&quot;</code>，exp中单个<code>&#39;.&#39;</code>可以代表任意字符，所以返回<code>true</code>。</li>
<li><code>str=&quot;abcd&quot;，exp=&quot;.*&quot;</code>。exp中<code>&#39;*&#39;</code>的前一个字符是<code>&#39;.&#39;</code>，所以可表示任意数量的<code>&#39;.&#39;</code>字符，当exp是<code>&quot;....&quot;</code>时与<code>&quot;abcd&quot;</code>匹配，返回<code>true</code>。</li>
<li><code>str=&quot;&quot;，exp=&quot;..*&quot;</code>。exp中<code>&#39;*&#39;</code>的前一个字符是<code>&#39;.&#39;</code>，可表示任意数量的<code>&#39;.&#39;</code>字符，但是<code>&quot;.*&quot;</code>之前还有一个<code>&#39;.&#39;</code>字符，该字符不受<code>&#39;*&#39;</code>的影响，所以<code>str</code>起码有一个字符才能被<code>exp</code>匹配。所以返回<code>false</code>。</li>
</ul>
<h3 id="暴力尝试-2"><a href="#暴力尝试-2" class="headerlink" title="暴力尝试"></a>暴力尝试</h3><p>定义一个方法<code>bool match(char[] str, int i, char[] exp, int j)</code>，表示<code>str</code>的下标<code>i ~ str.length</code>部分能否和<code>exp</code>的下标<code>j ~ exp.length</code>部分匹配，分情况讨论如下：</p>
<ol>
<li><p>如果<code>j</code>到了<code>exp.length</code>而<code>i</code>还没到<code>str.length</code>，返回<code>false</code>，否则返回<code>true</code></p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program7.png" alt> </p>
</li>
<li><p>如果<code>i</code>和<code>j</code>都没到右边界，并且<code>j</code>的后一个字符不是<code>*</code>或者越界，那么只有当<code>str[i]=exp[j]</code>或<code>exp[j]=&#39;.&#39;</code>时，<code>i</code>和<code>j</code>才同时右移继续比较<code>match(str, i+1, exp, j+1)</code>，否则返回<code>false</code></p>
</li>
<li><p>如果<code>i</code>和<code>j</code>都没到右边界，并且<code>j</code>后一个字符是<code>*</code>，这时右有两种情况：</p>
<ol>
<li><p><code>str[i] = exp[j]</code>或<code>exp[j]=&#39;.&#39;</code>。比如<code>a*</code>可以匹配空串也可以匹配一个<code>a</code>，如果<code>str[i]</code>之后还有连续的相同字符，那么<code>a*</code>还可以匹配多个，不管是哪种情况，将匹配后右移的<code>i</code>和<code>j</code>交给子过程<code>match</code></p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program8.png" alt> </p>
</li>
<li><p><code>str[i] != exp[j]</code>且<code>exp[j] != ‘.’</code> ，那么<code>exp[j]*</code>只能选择匹配空串。</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program9.png" alt> </p>
</li>
</ol>
</li>
<li><p>如果<code>i</code>到了<code>str.length</code>而<code>j</code>还没到<code>exp.length</code>，那么<code>j</code>之后的字符只能是<code>a*b*c*.*</code>的形式，也就是一个字符后必须跟一个<code>*</code>的形式，这个检验过程同样可以交给<code>match</code>来做</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program10.png" alt> </p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">char</span>[] e, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (j == e.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i == s.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//j下一个越界或者j下一个不是*</span></span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> == e.length || e[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != s.length &amp;&amp; s[i] == e[j] || e[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> match(s, i + <span class="number">1</span>, e, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//j下一个不越界并且j下一个是*</span></span><br><span class="line">    <span class="keyword">while</span> (i != s.length &amp;&amp; s[i] == e[j] || e[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (match(s, i, e, j + <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的while是因为 s[i]!=e[j] 而停止的</span></span><br><span class="line">    <span class="keyword">return</span> match(s, i, e, j + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || exp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] s = str.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] e = exp.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> match(s, <span class="number">0</span>, e, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(isMatch(<span class="string">"abbbbc"</span>,<span class="string">"a.*b*c"</span>));<span class="comment">//T</span></span><br><span class="line">    System.out.println(isMatch(<span class="string">"abbbbc"</span>,<span class="string">"a.*bbc"</span>));<span class="comment">//T</span></span><br><span class="line">    System.out.println(isMatch(<span class="string">"abbbbc"</span>,<span class="string">"a.bbc"</span>));<span class="comment">//F</span></span><br><span class="line">    System.out.println(isMatch(<span class="string">"abbbbc"</span>,<span class="string">"a.bbbc"</span>));<span class="comment">//T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><code>match</code>的参数列表中只有<code>i</code>和<code>j</code>是变化的，也就是说只要确定了<code>i</code>和<code>j</code>就能对应确定一个<code>match</code>的状态，画出二维表并将<code>base case</code>对应位置状态值标注出来：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program11.png" alt> </p>
<p>再看普遍位置<code>(i,j)</code>的依赖，第<code>6</code>行的<code>if</code>表明<code>(i,j)</code>可能依赖<code>(i+1, j+1)</code>，第<code>13</code>行的<code>while</code>表明<code>(i,j)</code>可能依赖<code>(i, j+2)</code>、<code>(i+1, j+2)</code>、<code>(i+2, j+2)</code>、……、<code>(s.length-1, j+2)</code>：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program12.png" alt> </p>
<p>你会发现<code>(i,j)</code>依赖它下面一行和右边相邻两列的状态，也就是说要想推出普遍位置的状态值，起码需要最后一行、最后一列和倒数第二列上的状态值。而<code>base case</code>仅为我们提供了最后一列的状态值，主过程<code>match(e, 0, s, 0)</code>对应<code>(0,0)</code>位置的状态值，我们需要推出整张表所有位置的状态值才行。</p>
<p>这时就要回归题意了，看倒数第二列和最后一行上的状态有什么特殊含义。</p>
<p>首先最后一行表示<code>i</code>到了<code>str.length</code>，此时如果<code>j</code>还没走完<code>exp</code>的话，从<code>j</code>开始到末尾的字符必须满足<code>字符*字符*字符*</code>的范式才返回<code>true</code>。因此最后一行状态值易求：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program13.png" alt> </p>
<p>而对于倒数第二列，表示<code>j</code>来到了<code>exp</code>的末尾字符，此时如果<code>i</code>如果在<code>str</code>末尾字符之前，那么也是直接返回<code>false</code>的：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/dynamic_program14.png" alt> </p>
<p>那么接下来就只剩下<code>(str.length-1, exp.length-1)</code>这个位置的状态值了，该位置标明<code>i</code>来到了<code>str</code>的末尾字符，<code>j</code>来到了<code>exp</code>的末尾字符，只有当这两个字符相等或<code>exp</code>的末尾字符为<code>.</code>才返回<code>true</code>否则<code>false</code>，也就是说该状态可以直接通过输入参数<code>str</code>和<code>exp</code>计算，它不依赖其他状态。二维表的初始化至此全部完成。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || exp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchDp(str, exp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matchDp</span><span class="params">(String str, String exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || exp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> s[] = str.toCharArray();</span><br><span class="line">    <span class="keyword">char</span> e[] = exp.toCharArray();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dpMap = initDpMap(s, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从倒数第二行开始推，每一行从右向左推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = e.length - <span class="number">2</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                dpMap[i][j] = (s[i] == e[j] || e[j] == <span class="string">'.'</span>) &amp;&amp; dpMap[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = i;</span><br><span class="line">                <span class="keyword">while</span> (tmp != s.length &amp;&amp; (s[tmp] == e[j] || e[j] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dpMap[tmp][j + <span class="number">2</span>]) &#123;</span><br><span class="line">                        dpMap[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dpMap[i][j] != <span class="keyword">true</span>) &#123;</span><br><span class="line">                    dpMap[i][j] = dpMap[i][j + <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpMap[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[][] initDpMap(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] e) &#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dpMap = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length + <span class="number">1</span>][e.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//last column</span></span><br><span class="line">    dpMap[s.length][e.length] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//last row -&gt; i=s.length-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = e.length - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j = j - <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[j] != <span class="string">'*'</span> &amp;&amp; e[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            dpMap[s.length - <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(str.length-1, e.length-1)</span></span><br><span class="line">    <span class="keyword">if</span> (s[s.length - <span class="number">1</span>] == e[e.length - <span class="number">1</span>] || e[e.length - <span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        dpMap[s.length - <span class="number">1</span>][e.length - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>左神算法进阶</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法笔记进阶-经典结构</title>
    <url>/2020/03/12/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6-%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="窗口最大值更新结构"><a href="#窗口最大值更新结构" class="headerlink" title="窗口最大值更新结构"></a>窗口最大值更新结构</h2><h3 id="最大值更新结构"><a href="#最大值更新结构" class="headerlink" title="最大值更新结构"></a>最大值更新结构</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_window.png" alt> </p><p>当向此结构放数据时会检查一下结构中的已有数据，从时间戳最大的开始检查，如果检查过程中发现该数据小于即将放入的数据则将其弹出并检查下一个，直到即将放入的数据小于正在检查的数据或者结构中的数据都被弹出了为止，再将要放入的数据放入结构中并盖上时间戳。如此每次从该结构取数据时，都会返回结构中时间戳最小的数据，也是目前为止进入过此结构的所有数据中最大的那一个。</p><a id="more"></a>

<p>此结构可以使用一个双端队列来实现，一端只用来放数据（放数据之前的检查过程可能会弹出其他数据），另一端用来获取目前为止出现过的最大值。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxValueWindow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxValueWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新窗口最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.getLast() &lt;= i) &#123;</span><br><span class="line">      queue.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取窗口最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使窗口最大值过期</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MaxValueWindow window = <span class="keyword">new</span> MaxValueWindow();</span><br><span class="line">    window.add(<span class="number">6</span>);</span><br><span class="line">    window.add(<span class="number">4</span>);</span><br><span class="line">    window.add(<span class="number">9</span>);</span><br><span class="line">    window.add(<span class="number">8</span>);</span><br><span class="line">    System.out.println(window.getMax());<span class="comment">//9</span></span><br><span class="line">    window.expireMaxValue();</span><br><span class="line">    System.out.println(window.getMax());<span class="comment">//8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="窗口移动"><a href="#窗口移动" class="headerlink" title="窗口移动"></a>窗口移动</h4><p>给你一个长度为<code>N</code>的整型数组和大小为<code>W</code>的窗口，用一个长度为<code>N-W+1</code>的数组记录窗口从数组由左向右移动过程中窗口内最大值。</p>
<p>对于数组<code>[1,2,3,4,5,6,7]</code>和窗口大小为<code>3</code>，窗口由左向右移动时有：</p>
<ul>
<li><code>[1,2,3],4,5,6,7</code>，窗口起始下标为0时，框住的数是<code>1,2,3</code>，最大值是3</li>
<li><code>1,[2,3,4],5,6,7</code>，最大值是4</li>
<li><code>1,2,[3,4,5],6,7</code>，最大值是5</li>
<li>……</li>
</ul>
<p>因此所求数组是<code>[3,4,5,6,7]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> index, LinkedList&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; arr[queue.getLast()] &lt; arr[index]) &#123;</span><br><span class="line">    queue.pollLast();</span><br><span class="line">  &#125;</span><br><span class="line">  queue.add(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expireIndex</span><span class="params">(<span class="keyword">int</span> index, LinkedList&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peek() == index) &#123;</span><br><span class="line">    queue.pollFirst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxValues(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">  LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) &#123;</span><br><span class="line">    add(arr, i, queue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">    res[i] = queue.peek();</span><br><span class="line">    <span class="keyword">if</span> (i + w &lt;= arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      expireIndex(i, queue);</span><br><span class="line">      add(arr, i + w, queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">    res[i] = arr[res[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  System.out.println(Arrays.toString(maxValues(arr,<span class="number">3</span>)));<span class="comment">//[3, 5, 6, 6, 7, 8, 10, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要的注意的是，针对这道题将窗口最大值更新结构的<code>add</code>和<code>expire</code>方法做了改进（结构中存的是值对应的下标）。例如<code>[2,1,2],-1-&gt;2,[1,2,-1]</code>，应当翻译为<code>[2,1,2],-1</code>状态下的窗口最大值为2下标上的数<code>2</code>，变为<code>2,[1,2,-1]</code>时应当翻译为下标为0的数从窗口过期了，而不应该是数据<code>2</code>从窗口过期了（这样会误删窗口中下标为2的最大值2）。</p>
<h4 id="求达标的子数组个数"><a href="#求达标的子数组个数" class="headerlink" title="求达标的子数组个数"></a>求达标的子数组个数</h4><p>给你一个整型数组，判断其所有子数组中最大值和最小值的差值不超过<code>num</code>（如果满足则称该数组达标）的个数。（子数组指原数组中任意个连续下标上的元素组成的数组）</p>
<p>暴力解：遍历每个元素，再遍历以当前元素为首的所有子数组，再遍历子数组找到其中的最大值和最小值以判断其是否达标。很显然这种方法的时间复杂度为<code>o(N^3)</code>，但如果使用最大值更新结构，则能实现<code>O(N)</code>级别的解。</p>
<p>如果使用<code>L</code>和<code>R</code>两个指针指向数组的两个下标，且<code>L</code>在<code>R</code>的左边。当<code>L~R</code>这一子数组达标时，可以推导出以<code>L</code>开头的长度不超过<code>R-L+1</code>的所有子数组都达标；当<code>L~R</code>这一子数组不达标时，无论<code>L</code>向左扩多少个位置或者<code>R</code>向右扩多少个位置，<code>L~R</code>还是不达标。</p>
<p><code>O(N)</code>的解对应的算法是：<code>L</code>和<code>R</code>都从0开始，<code>R</code>先向右移动，<code>R</code>每右移一个位置就使用最大值更新结构和最小值更新结构记录一下<code>L~R</code>之间的最大值和最小值的下标，当<code>R</code>移动到如果再右移一个位置<code>L~R</code>就不达标了时停止，这时以当前<code>L</code>开头的长度不超过<code>R-L+1</code>的子数组都达标；然后<code>L</code>右移一个位置，同时更新一下最大值、最小值更新结构（<code>L-1</code>下标过期了），再右移<code>R</code>至<code>R</code>如果右移一个位置<code>L~R</code>就不达标了停止（每右移<code>R</code>一次也更新最大、小值更新结构）……；直到<code>L</code>到达数组尾元素为止。将每次<code>R</code>停止时，<code>R-L+1</code>的数量累加起来就是<code>O(N)</code>的解，因为<code>L</code>和<code>R</code>都只向右移动，并且每次<code>R</code>停止时，以<code>L</code>开头的达标子串的数量直接通过<code>R-L+1</code>计算，所以时间复杂度就是将数组遍历了一遍即<code>O(N)</code>。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getComplianceChildArr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//最大值、最小值更新结构</span></span><br><span class="line">  LinkedList&lt;Integer&gt; maxq = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  LinkedList&lt;Integer&gt; minq = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">  maxq.add(<span class="number">0</span>);</span><br><span class="line">  minq.add(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line">    <span class="keyword">while</span> (R &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!maxq.isEmpty() &amp;&amp; arr[maxq.getLast()] &lt;= arr[R + <span class="number">1</span>]) &#123;</span><br><span class="line">        maxq.pollLast();</span><br><span class="line">      &#125;</span><br><span class="line">      maxq.add(R + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (!minq.isEmpty() &amp;&amp; arr[minq.getLast()] &gt;= arr[R + <span class="number">1</span>]) &#123;</span><br><span class="line">        minq.pollLast();</span><br><span class="line">      &#125;</span><br><span class="line">      minq.add(R + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (arr[maxq.peekFirst()] - arr[minq.peekFirst()] &gt; num) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      R++;</span><br><span class="line">    &#125;</span><br><span class="line">    res += (R - L + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (maxq.peekFirst() == L) &#123;</span><br><span class="line">      maxq.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minq.peekFirst() == L) &#123;</span><br><span class="line">      minq.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    L++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  System.out.println(getComplianceChildArr(arr, <span class="number">3</span>));<span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><h3 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h3><p>给你一个数组，找出数组中每个数左边离它最近的比它大的数和右边离它最近的比它大的数。</p>
<blockquote>
<p>思路：使用一个栈，要求每次元素进栈后要维持栈中从栈底到栈顶元素值是从大到小排列的约定。将数组中的元素依次进栈，如果某次元素进栈后会违反了上述的约定（即该进栈元素比栈顶元素大），就先弹出栈顶元素，并记录该栈顶元素的信息：</p>
<ul>
<li>该元素左边离它最近的比它大的是该元素出栈后的栈顶元素，如果出栈后栈空，那么该元素左边没有比它大的数</li>
<li>该元素右边离它最近的比它大的是进栈元素</li>
</ul>
<p>然后再尝试将进栈元素进栈，如果进栈后还会违反约定那就重复操作“弹出栈顶元素并记录该元素信息”，直到符合约定或栈中元素全部弹出时再将该进栈元素进栈。当数组所有元素都进栈之后，栈势必不为空，弹出栈顶元素并记录信息：</p>
<ul>
<li>该元素右边没有比它大的数</li>
<li>该元素左边离它最近的比它大的数是该元素从栈弹出后的栈顶元素，如果该元素弹出后栈为空，那么该元素左边没有比它大的数</li>
</ul>
<p>由于每个元素仅进栈一次、出栈一次，且出栈时能得到题目所求信息，因此时间复杂度为<code>O(N)</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findLeftAndRightBigger</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//check the agreement before push the index of element</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; arr[stack.peek()] &lt; arr[i]) &#123;</span><br><span class="line">            <span class="comment">//pop and record the info(print or save)</span></span><br><span class="line">            <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">            System.out.print(<span class="string">"index:"</span> + index + <span class="string">",element:"</span> + arr[index] + <span class="string">",right bigger is:"</span> + arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                System.out.print(<span class="string">",hasn't left bigger\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">",left bigger is:"</span> + arr[stack.peek()]+<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//push</span></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">        System.out.print(<span class="string">"index:"</span> + index + <span class="string">",element:"</span> + arr[index] + <span class="string">",hasn't right bigger"</span>);</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            System.out.print(<span class="string">",hasn't left bigger\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">",left bigger is:"</span> + arr[stack.peek()]+<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    findLeftAndRightBigger(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给你一些数，创建一棵大根堆二叉树"><a href="#给你一些数，创建一棵大根堆二叉树" class="headerlink" title="给你一些数，创建一棵大根堆二叉树"></a>给你一些数，创建一棵大根堆二叉树</h3><blockquote>
<p>思路：使用一个栈底到栈顶单调递减的单调栈，将这些数<code>arr[]</code>依次入栈，记录每个数左边离它最近的比它大的数，保存在<code>left[]</code>中（下标和<code>arr[]</code>一一对应），记录每个数右边离它最近的比它大的数，保存在<code>right[]</code>中。</p>
<p>遍历<code>arr[]</code>建树：<code>left[i]</code>和<code>right[i]</code>都不存在的，说明<code>arr[i]</code>是最大的数，将其作为根节点；对于其他任何一个数<code>arr[i]</code>，<code>left[i]</code>和<code>right[i]</code>必有一个存在，如果都存在则将<code>arr[i]</code>作为<code>Math.min(left[i],right[i])</code>的孩子节点，如果只有一个存在（如<code>left[i]</code>）那就将<code>arr[i]</code>作为<code>left[i]</code>的孩子节点</p>
</blockquote>
<blockquote>
<p>思考：这样建出的树会不会是森林，会不会不是二叉树？</p>
</blockquote>
<h3 id="找出矩阵中一片1相连的最大矩形"><a href="#找出矩阵中一片1相连的最大矩形" class="headerlink" title="找出矩阵中一片1相连的最大矩形"></a>找出矩阵中一片1相连的最大矩形</h3><p>矩阵中的数只会是0或1，求矩阵中一片1形成的最大长方形区域的面积。</p>
<p>此题可借鉴在直方图中找最大矩形的方法。首先一个数组可以对应一个直方图，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_rectangle_area.png" alt> </p>
<p>接着，遍历数组，以当前遍历元素值为杆子的高并尝试向左右移动这根杆子（约定杆子不能出黄色区域）：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_rectangle_area1.png" alt> </p>
<p>如上图，0号杆子向左右移动一格都会使杆子出界（黄色区域），因此0号杆子的活动面积是<code>4x1=4</code>（杆长x能活动的格子数）；1号杆子向左、向右都只能移动一格，因此其活动面积是<code>2x3=6</code>；2号杆子的活动面积是<code>3x1=3</code>；3号杆子的活动面积是<code>1x5=5</code>；4号杆子的活动面积是<code>6x1=6</code>。因此该直方图中最大矩形面积就是所有杆子的活动面积中最大的那个，即6。</p>
<p>如果现在给你一个矩阵，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>你能否将其中相连的一片1看成直方图中的黄色区域，如此的话求矩阵由一片1形成的最大矩形区域就是求直方图中最大矩形面积了。</p>
<p>所以对于输入的矩形，我们只要遍历每一行，以该行作为直方图的x轴，求出直方图的最大矩形面积，再比较所有行对应的最大矩形面积就能得出整个矩阵的一片1形成的最大矩形区域了。</p>
<p>以上面的矩阵为例，第一行、第三行、最后一行对应的直方图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_rectangle_area2.png" alt> </p>
<p>分别可以用数组<code>[0,0,0,0,1]</code>、<code>[1,0,0,0,3]</code>、<code>[4,2,3,1,6]</code>来表示，那么此题关键的点就是遍历每一行并求出以该行为x轴的直方图的数组表示之后，如何得出此直方图的最大矩形面积。下面就使用单调栈来解决此问题：</p>
<p>以<code>[4,2,3,1,6]</code>的求解过程为例，使用一个栈底到栈顶单调递增的栈将数组中的数的下标作为该数的代表依次压栈（数的下标-&gt;数值），首先能压的是<code>0-&gt;4</code>，接着准备压<code>1-&gt;2</code>，发现<code>2</code>比栈顶的<code>4</code>小，压人后会违反栈底到栈顶单调递增的约定，因此弹出<code>0-&gt;4</code>并记录0号杆子的活动面积（<code>0-&gt;4</code>弹出后栈为空，说明0号杆子左移到x轴的-1就跑出黄色区域了，由于是<code>1-&gt;2</code>让它弹出的，所以0号杆子右移到x轴的1就出界了，因此0号杆子只能在x轴上的0位置上活动，活动面积是<code>4x1=4</code>，称这个记录的过程为<strong>结算</strong>）。由于弹出<code>0-&gt;4</code>之后栈空了，所以可以压入<code>1-&gt;2</code>、<code>2-&gt;3</code>，接着准备压<code>3-&gt;1</code>时发现<code>1</code>比栈顶<code>3</code>小，因此结算<code>2-&gt;3</code>（由于弹出<code>2-&gt;3</code>之后栈顶为<code>1-&gt;2</code>，因此2号杆子左移到x轴1位置时出界了，由于是<code>3-&gt;1</code>让其弹出的，所以2号杆子右移到x轴3位置就出界了，因此2号杆子的活动面积是<code>3x1=3</code>）。接着再准备压<code>3-&gt;1</code>，发现<code>1</code>比栈顶<code>1-&gt;2</code>的<code>2</code>小，因此结算<code>1-&gt;2</code>（弹出<code>1-&gt;2</code>后栈空，因此1号杆子左移到x轴-1时才出界，<code>3-&gt;1</code>让其出界的，因此右移到3时才出界，活动面积为<code>2x3=6</code>）……</p>
<p>所有数压完之后，栈肯定不为空，那么栈中剩下的还需要结算，因此依次弹出栈顶进行结算，比如<code>[4,2,3,1,6]</code>压完之后，栈中还剩<code>3-&gt;1,4-&gt;6</code>，因此弹出<code>4-&gt;6</code>并结算（由于<code>4-&gt;6</code>不是因为一个比<code>6</code>小的数要进来而让它弹出的，所以4号杆子右移到x轴<code>arr.length=5</code>位置才出界，由于弹出后栈不空且栈顶为<code>3-&gt;1</code>，所以左移到x轴的3位置上才出界的，所以活动面积为<code>6x1=6</code>；同样的方法结算<code>3-&gt;1</code>……直到栈中的都被结算完，整个过程结束。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRectangleArea</span><span class="params">(<span class="keyword">int</span> matrix[][])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> maxArea = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">            arr[j] = matrix[i][j] == <span class="number">1</span> ? arr[j]+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        maxArea = Math.max(maxArea, maxRecAreaOfThRow(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRecAreaOfThRow</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = Integer.MIN_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; arr[i] &lt; arr[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftBorder = stack.empty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            maxArea = Math.max(maxArea, arr[index] * (i - leftBorder - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> rightBorder = arr.length;</span><br><span class="line">        <span class="keyword">int</span> leftBorder = stack.empty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        maxArea = Math.max(maxArea, arr[index] * (rightBorder - leftBorder - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[][] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(maxRectangleArea(matrix));<span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="烽火相望"><a href="#烽火相望" class="headerlink" title="烽火相望"></a>烽火相望</h3><p>【网易原题】给你一个数组，数组中的每个数代表一座山的高度，这个数组代表将数组中的数从头到尾连接而成的环形山脉。比如数组<code>[2,1,3,4,5]</code>形成的环形山脉如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications.png" alt> </p>
<p>其中蓝色的圆圈就代表一座山，圈中的数字代表这座山的高度。现在在每座山的山顶都点燃烽火，假设你处在其中的一个山峰上，要想看到另一座山峰的烽火需满足以下两个条件中的一个：</p>
<ul>
<li>你想看的山峰在环形路径上与你所在的山峰相邻。比如你在山峰A上，那么你能够看到B和E上的烽火。</li>
<li>如果你想看的山峰和你所在的山峰不相邻，那么你可以沿环形路径顺时针看这座山也可以沿环形路径逆时针看这座山，只要你放眼望去沿途经过的山峰高度小于你所在的山峰和目标山峰，那么也能看到。比如C想看E，那么可以通过C-&gt;B-&gt;A-&gt;E的方式看，也可以通过C-&gt;D-&gt;E的方式看。前者由于经过的山峰的高度1和2比C的高度3和E的高度5都小，因此能看到；但后者经过的山峰D的高度4大于C的高度3，因此C在通过C-&gt;D-&gt;E这个方向看E的时候视线就被山峰D给挡住了。</li>
</ul>
<p>问：所有山峰中，能互相看到烽火的两两山峰的对数。以<code>[2,1,3,4,5]</code>为例，能互相看见的有：<code>2,1</code>,<code>1,3</code>,<code>3,4</code>,<code>4,5</code>,<code>5,2</code>,<code>2,3</code>,<code>3,5</code>，共7对。</p>
<p>此题分一下两种情况</p>
<h4 id="1、数组中无重复的数"><a href="#1、数组中无重复的数" class="headerlink" title="1、数组中无重复的数"></a>1、数组中无重复的数</h4><p>这种情况下，答案可以直接通过公式<code>2*N-3</code>可以求得（其中<code>N</code>为数组长度），证明如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications1.png" alt> </p>
<p>假设A是在山峰中最高，B在所有山峰中第二高。那么环形路径上介于A和B之间的任意一座山峰（比如K），逆时针方向在到达A之前或到达A时一定会遇到第一座比它高的山峰，记这座山峰和K是一对；顺时针方向，在到达B之前或到达B时，一定会遇到第一个比K高的山峰，记这座山峰和K是一对。也就是说对于除A,B之外的所有山峰，都能找到两对符合标准的，这算下来就是<code>(N-2)*2</code>了，最后AB也算一对，总数是<code>(N-2)*2+1=2N-3</code>。</p>
<p>但如果数组中有重复的数就不能采用上述的方法了</p>
<h4 id="2、数组中可能有重复的数"><a href="#2、数组中可能有重复的数" class="headerlink" title="2、数组中可能有重复的数"></a>2、数组中可能有重复的数</h4><blockquote>
<p>利用单调栈</p>
</blockquote>
<p>首先找出数组中最大数第一次出现的位置，记为<code>M</code>。从这个数开始遍历数组并依次压栈（栈底到栈底从大到小的单调栈），以如下的环形山脉为例：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications2.png" alt> </p>
<p>从M开始压栈，同时附带一个计数器：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications3.png" alt> </p>
<p>当压入5时，违反单调栈约定因此结算4（4左边第一个比它高的是9，右边第一个比它高的是5，因此能和4配对的有两对）；接着再压入5、压入4，重点来了：连续两次再压入4该如何处理：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications4.png" alt> </p>
<p>这是数组中有重复的数时，如何使用单调栈解决此题的关键：如果压入的元素与栈顶元素相同，将栈顶元素的<strong>计数器加1</strong>，那么再压入两个4之后栈中情况：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications5.png" alt> </p>
<p>然后压入9，导致弹出并结算4。那么<strong>如何结算计数器大于1的数据</strong>呢？首先，这3座高度相同的山峰两两配对能够组成<code>C(3,2)=3</code>对，此外其中的每座山峰左边离它最近的比它高的是5、右边离它近的比它大的是9，因此这3座山峰每座都能和<code>5、9</code>配对，即<code>3*2=6</code>，因此结算结果为<code>3+6=9</code>……</p>
<p>如果数据压完了，那就从栈顶弹出数据进行结算，直到结算栈底上一个元素之前（栈底元素是最大值），弹出数据的结算逻辑都是<code>C(K,2)+K*2</code>（其中K是该数据的计数器数值）。</p>
<p>倒数第二条数据的结算逻辑有点复杂，如图，以结算4为例：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/comunications6.png" alt> </p>
<p>如果K的数值大于1，那么这6座高度为4的山峰结算逻辑还是上述公式。但如果K为1，那么结算公式就是<code>C(K,2)+K*1</code>了。</p>
<p>最后对于最大值M的结算，假设其计数器的值为K，如果K=1，那么结算结果为0；如果K&gt;1，那么结算结果为<code>C(K,2)</code>。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Record</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.times = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">comunications</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index of first max value</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        maxIndex = arr[maxIndex] &lt; arr[i] ? i : maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Record&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="keyword">new</span> Record(arr[maxIndex]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = nextIndex(arr, maxIndex);</span><br><span class="line">    <span class="keyword">while</span> (index != maxIndex) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; arr[index] &gt; stack.peek().value) &#123;</span><br><span class="line">            Record record = stack.pop();</span><br><span class="line">            res += getInternalPairs(record.times) + record.times * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] == stack.peek().value) &#123;</span><br><span class="line">            stack.peek().times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Record(arr[index]));</span><br><span class="line">        &#125;</span><br><span class="line">        index = nextIndex(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        Record record = stack.pop();</span><br><span class="line">        res += getInternalPairs(record.times);</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</span><br><span class="line">            res += record.times;</span><br><span class="line">            <span class="keyword">if</span> (stack.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += record.times;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += stack.peek().times &gt; <span class="number">1</span> ? record.times : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C(K,2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInternalPairs</span><span class="params">(<span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (times * (times - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &lt; arr.length - <span class="number">1</span> ? index + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    System.out.println(comunications(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p>搜索二叉树的定义：对于一棵二叉树中的任意子树，其左子树上的所有数值小于头结点的数值，其右子树上所有的数值大于头结点的数值，并且树中不存在数值相同的结点。也称二叉查找树。</p>
<h3 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树/AVL树"></a>平衡二叉树/AVL树</h3><h4 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h4><p>经典的平衡二叉树结构：在满足搜索二叉树的前提条件下，对于一棵二叉树中的任意子树，其左子树和其右子树的高度相差不超过1。</p>
<h3 id="典型搜索二叉树——AVL树、红黑树、SBT树的原理"><a href="#典型搜索二叉树——AVL树、红黑树、SBT树的原理" class="headerlink" title="典型搜索二叉树——AVL树、红黑树、SBT树的原理"></a>典型搜索二叉树——AVL树、红黑树、SBT树的原理</h3><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>AVL树是一种具有严苛平衡性的搜索二叉树。什么叫做严苛平衡性呢？那就是<strong>所有子树的左子树和右子树的高度相差不超过1</strong>。弊端是，每次发现因为插入、删除操作破坏了这种严苛的平衡性之后，都需要作出相应的调整以使其恢复平衡，调整较为频繁。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是每个节点都带有颜色属性的搜索二叉树，颜色或红色或黑色。在搜索二叉树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p>
<ul>
<li>性质1. 节点是红色或黑色。</li>
<li>性质2. 根节点是黑色。</li>
<li>性质3 每个叶节点（NIL节点，空节点）是黑色的。</li>
<li>性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>这些约束强制了红黑树的关键性质: <strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>。结果是这个树<strong>大致上是平衡</strong>的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>要知道为什么这些特性确保了这个结果，注意到<strong>性质4导致了路径不能有两个毗连的红色节点</strong>就足够了。<strong>最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点</strong>。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<h4 id="SBT树"><a href="#SBT树" class="headerlink" title="SBT树"></a>SBT树</h4><p>它是由中国广东中山纪念中学的陈启峰发明的。陈启峰于2006年底完成论文《Size Balanced Tree》，并在2007年的全国青少年信息学奥林匹克竞赛冬令营中发表。<strong>相比红黑树、AVL树等自平衡二叉查找树，SBT更易于实现</strong>。<strong>据陈启峰在论文中称，SBT是“目前为止速度最快的高级二叉搜索树”</strong>。<strong>SBT能在O(log n)的时间内完成所有二叉搜索树(BST)的相关操作</strong>，而与普通二叉搜索树相比，SBT仅仅加入了简洁的核心操作Maintain。由于SBT赖以保持平衡的是size域而不是其他“无用”的域，它可以很方便地实现动态顺序统计中的select和rank操作。</p>
<p><strong>SBT树的性质</strong>是：对于数中任意结点，以该结点为根节点的子树的结点个数不能比以该结点的叔叔结点为根节点的子树的结点个数大。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/sbt_tree.png" alt> </p>
<blockquote>
<p>由于红黑树的实现较为复杂，因此现在工程中大多使用SBT树作为平衡二叉树的实现。</p>
</blockquote>
<h3 id="旋转——Rebalance"><a href="#旋转——Rebalance" class="headerlink" title="旋转——Rebalance"></a>旋转——Rebalance</h3><p>左旋：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/red_black_tree.png" alt> </p>
<p>右旋：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/red_black_tree1.png" alt> </p>
<p>每种平衡二叉树都有自己的一套在插入、删除等操作改变树结构而破坏既定平衡性时的应对措施（但都是左旋操作和右旋操作的组合），以AVL数为例（有四种平衡调整操作，其中的数字只是结点代号而非结点数值）：</p>
<ul>
<li><p><code>LL</code>调整：2号结点的左孩子的左孩子导致整个树不平衡，2号结点右旋一次</p>
<p>  <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/ll_adjust.png" alt> </p>
</li>
</ul>
<ul>
<li><p><code>RR</code>调整：3号结点的右孩子的右孩子导致树不平衡，3号结点左旋一次：</p>
<p>  <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rr_adjust.png" alt> </p>
</li>
<li><p><code>LR</code>调整：先左后右</p>
<p>  <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/lr_adjust.png" alt> </p>
</li>
<li><p><code>RL</code>调整：先右后左：</p>
<p>  <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rl_adjust.png" alt> </p>
</li>
</ul>
<p>红黑树的调整也是类似的，只不过调整方案更多。面试中一般不会让你手写红黑树（若有兴趣可参见文末附录），但我们一定能说清这些查找二叉树的性质，以及调整平衡的基本操作，再就是这些结构的使用。</p>
<h3 id="Java中红黑树的使用"><a href="#Java中红黑树的使用" class="headerlink" title="Java中红黑树的使用"></a>Java中红黑树的使用</h3><p>Java中红黑树的实现有<code>TreeSet</code>和<code>TreeMap</code>，前者结点存储的是单一数据，而后者存储的是``的形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">    treeMap.put(<span class="number">5</span>, <span class="string">"tom"</span>);</span><br><span class="line">    treeMap.put(<span class="number">11</span>, <span class="string">"jack"</span>);</span><br><span class="line">    treeMap.put(<span class="number">30</span>,<span class="string">"tony"</span>);</span><br><span class="line">    treeMap.put(<span class="number">18</span>, <span class="string">"alice"</span>);</span><br><span class="line">    treeMap.put(<span class="number">25</span>, <span class="string">"jerry"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//红黑树中最右边的结点</span></span><br><span class="line">    System.out.println(treeMap.lastEntry());</span><br><span class="line">    System.out.println(treeMap.lastKey());</span><br><span class="line">    <span class="comment">//红黑树最左边的结点</span></span><br><span class="line">    System.out.println(treeMap.firstKey());</span><br><span class="line">    <span class="comment">//如果有13这个key，那么返回这条记录，否则返回树中比13大的key中最小的那一个</span></span><br><span class="line">    System.out.println(treeMap.ceilingEntry(<span class="number">13</span>));</span><br><span class="line">    <span class="comment">//如果有21这个key，那么返回这条记录，否则返回树中比21小的key中最大的那一个</span></span><br><span class="line">    System.out.println(treeMap.floorEntry(<span class="number">21</span>));</span><br><span class="line">    <span class="comment">//比11大的key中，最小的那一个</span></span><br><span class="line">    System.out.println(treeMap.higherKey(<span class="number">11</span>));</span><br><span class="line">    <span class="comment">//比25小的key中，最大的那一个</span></span><br><span class="line">    System.out.println(treeMap.lowerKey(<span class="number">25</span>));</span><br><span class="line">    <span class="comment">//遍历红黑树，是按key有序遍历的</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; record : treeMap.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"age:"</span>+record.getKey()+<span class="string">",name:"</span>+record.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TreeMap</code>的优势是<code>key</code>在其中是有序组织的，因此增加、删除、查找<code>key</code>的时间复杂度均为<code>log(2,N)</code>。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="The-Skyline-Problem"><a href="#The-Skyline-Problem" class="headerlink" title="The Skyline Problem"></a>The Skyline Problem</h4><p>水平面上有 <em>N</em> 座大楼，每座大楼都是矩阵的形状，可以用一个三元组表示 <code>(start, end, height)</code>，分别代表其在x轴上的起点，终点和高度。大楼之间从远处看可能会重叠，求出 <em>N</em> 座大楼的外轮廓线。</p>
<p>外轮廓线的表示方法为若干三元组，每个三元组包含三个数字 (start, end, height)，代表这段轮廓的起始位置，终止位置和高度。</p>
<p>给出三座大楼：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skyline.png" alt> </p>
<p>外轮廓线为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong>：</p>
<ol>
<li>将一座楼的表示<code>[start,end,height]</code>拆分成左右两个边界（边界包含：所处下标、边界高度、是楼的左边界还是右边界），比如<code>[1,3,3]</code>就可以拆分成<code>[1,3,true]</code>和<code>[3,3,false]</code>的形式（<code>true</code>代表左边界、<code>false</code>代表右边界）。</li>
<li>将每座楼都拆分成两个边界，然后对边界按照边界所处的下标进行排序。比如<code>[[1,3,3],[2,4,4],[5,6,1]</code>拆分之后为<code>[[1,3,true],[3,3,false],[2,4,true],[,4,4,false],[5,1,true],[6,1,false]]</code>，排序后为<code>[[1,3,true],[2,4,true],[3,3,false],[4,4,false],[5,1,true],[6,1,false]]</code></li>
<li>将边界排序后，遍历每个边界的高度并依次加入到一棵<code>TreeMap</code>红黑树中（记为<code>countOfH</code>），以该高度出现的次数作为键值（第一次添加的高度键值为1），如果遍历过程中有重复的边界高度添加，要判断它是左边界还是右边界，前者直接将该高度在红黑树中的键值加1，后者则减1。以步骤2中排序后的边界数组为例，首先判断<code>countOfH</code>是否添加过边界<code>[1,3,true]</code>的高度<code>3</code>，发现没有，于是<code>put(3,1)</code>；接着对<code>[2,4,true]</code>，<code>put[4,1]</code>；然后尝试添加<code>[3,3,false]</code>的<code>3</code>，发现<code>countOfH</code>中添加过<code>3</code>，而<code>[3,3,false]</code>是右边界，因此将<code>countOfH.get(3)</code>的次数减1，当<code>countOfH</code>中的记录的键值为0时直接移除，于是移除高度为3的这一条记录；……</li>
</ol>
<p>对于遍历过程经过的每一个边界，我们还需要一棵<code>TreeMap</code>红黑树（记为<code>maxHOfPos</code>）来记录对我们后续求外轮廓线有用的信息，也就是每个边界所处下标的最大建筑高度：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skyline1.png" alt> </p>
<p>这里有个细节要注意一下，那就是如果添加某个边界之后，<code>countOfH</code>树为空了，那么该边界所处下标的建筑高度要记为0，表示一片相邻建筑的结束，比如上图中下标为4和6的边界。这也是为了后续求外轮廓线提供判断的依据。</p>
<ol start="4">
<li><p>遍历<code>maxHOfPos</code>中的记录，构造整个外轮廓线数组：</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skyline2.png" alt> </p>
</li>
</ol>
<p>起初没有遍历边界时，记<code>start=0,height=0</code>，接着遍历边界，如果边界高度<code>curHeight!=height</code>如上图中的<code>1-&gt;2：height=0,curHeight=3</code>，那么记<code>start=1,height=3</code>表示第一条组外轮廓线的<code>start</code>和<code>height</code>，接下来就是确定它的<code>end</code>了。确定了一条轮廓线的<code>start</code>和<code>height</code>之后会有两种情况：下一组轮廓线和这一组是挨着的（如上图<code>2-&gt;3</code>）、下一组轮廓线和这一组是相隔的（如上图中<code>3-&gt;4</code>）。因此在遍历到边界<code>[index:2,H:4]</code>时，发现<code>curHeight=4 != height=3</code>，于是可以确定轮廓线<code>start:1,heigth:3</code>的<code>end:2</code>。确定一条轮廓线后就要更新一下<code>start=2,heigth=4</code>表示下一组轮廓线的起始下标和高度，接着遍历到边界<code>[index:3,H:4]</code>，发现<code>curHeight=4=height</code>于是跳过；接着遍历到边界<code>[index:4,H:0]</code>，发现<code>curHeight=0</code>，根据步骤3中的逻辑可知一片相邻的建筑到此结束了，因此轮廓线<code>start:2,height:4</code>的<code>end=4</code>。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.lintcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T131_The_SkylineProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Border</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isLeft;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Border</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> height, <span class="keyword">boolean</span> isLeft)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">            <span class="keyword">this</span>.isLeft = isLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Border border)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.index != border.index) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.index - border.index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isLeft != border.isLeft) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.isLeft ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buildings: A list of lists of integers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Find the outline of those buildings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; buildingOutline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">        <span class="comment">//1、split one building to two borders and sort by border's index</span></span><br><span class="line">        Border[] borders = <span class="keyword">new</span> Border[buildings.length * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] oneBuilding = buildings[i];</span><br><span class="line">            borders[i * <span class="number">2</span>] = <span class="keyword">new</span> Border(oneBuilding[<span class="number">0</span>], oneBuilding[<span class="number">2</span>], <span class="keyword">true</span>);</span><br><span class="line">            borders[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="keyword">new</span> Border(oneBuilding[<span class="number">1</span>], oneBuilding[<span class="number">2</span>], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(borders);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、traversal borders and record the max height of each index</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//key-&gt;height   value-&gt;the count of the height</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; countOfH = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//key-&gt;index    value-&gt;the max height of the index</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; maxHOfPos = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; borders.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = borders[i].height;</span><br><span class="line">            <span class="keyword">if</span> (!countOfH.containsKey(height)) &#123;</span><br><span class="line">                countOfH.put(height, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> count = countOfH.get(height);</span><br><span class="line">                <span class="keyword">if</span> (borders[i].isLeft) &#123;</span><br><span class="line">                    countOfH.put(height, count + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    countOfH.put(height, count - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (countOfH.get(height) == <span class="number">0</span>) &#123;</span><br><span class="line">                        countOfH.remove(height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (countOfH.isEmpty()) &#123;</span><br><span class="line">                maxHOfPos.put(borders[i].index, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//lastKey() return the maxHeight in countOfH RedBlackTree-&gt;log(2,N)</span></span><br><span class="line">                maxHOfPos.put(borders[i].index, countOfH.lastKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、draw the buildings outline according to the maxHOfPos</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : maxHOfPos.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curPosition = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> curMaxHeight = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (height != curMaxHeight) &#123;</span><br><span class="line">                <span class="comment">//if the height don't be reset to 0，the curPosition is the end</span></span><br><span class="line">                <span class="keyword">if</span> (height != <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; record = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    record.add(start);</span><br><span class="line">                    record.add(curPosition);<span class="comment">//end</span></span><br><span class="line">                    record.add(height);</span><br><span class="line"></span><br><span class="line">                    res.add(record);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//reset the height and start</span></span><br><span class="line">                height = curMaxHeight;</span><br><span class="line">                start = curPosition;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] buildings = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> T131_The_SkylineProblem().buildingOutline(buildings));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list.png" alt> </p>
<p>跳表有着和红黑树、SBT树相同的功能，都能实现在<code>O(log(2,N))</code>内实现对数据的增删改查操作。但跳表不是以二叉树为原型的，其设计细节如下：</p>
<p>记该结构为<code>SkipList</code>，该结构中可以包含有很多结点（<code>SkipListNode</code>），每个结点代表一个被添加到该结构的数据项。当实例化<code>SkipList</code>时，该对象就会自带一个<code>SkipListNode</code>（不代表任何数据项的头结点）。</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>当你向其中添加数据之前，首先会抛硬币，将第一次出现正面朝上时硬币被抛出的次数作为该数据的层数（<code>level</code>，<strong>最小为1</strong>），接着将数据和其层数封装成一个<code>SkipListNode</code>添加到<code>SkipList</code>中。结构初始化时，其头结点的层数为0，但每次添加数据后都会更新头结点的层数为所添数据中层数最大的。比如实例化一个<code>SkipList</code>后向其中添加一条层数为<code>3</code>的数据<code>7</code>：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list1.png" alt> </p>
<p>这时如果再添加一条层数为<code>2</code>的数据<code>5</code>呢？首先游标<code>curNode</code>会从<code>head</code>的最高层出发往右走，走到数据项为7的结点，发现<code>7&gt;5</code>，于是又退回来走向下一层：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list2.png" alt> </p>
<p>接着再尝试往右走，还是发现<code>7&gt;5</code>，于是还是准备走向下一层，但此时发现<code>curNode</code>所在层数<code>2</code>是数据项<code>5</code>的最高层，于是先建出数据项<code>5</code>的第二层，<code>curNode</code>再走向下一层：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list3.png" alt> </p>
<p>同样的，<code>curNode</code>尝试往右走，但发现<code>7&gt;5</code>，<code>curNode</code>所在层为1，但数据<code>5</code>的第一层还没建，于是建出，<code>curNode</code>再往下走。当<code>curNode</code>走到<code>null</code>时，建出数据<code>5</code>根部的<code>null</code>：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list4.png" alt> </p>
<p>至此层数为2的数据项<code>5</code>的添加操作完毕。</p>
<p>那如果添加一个层数较高的数据项该如何处理呢？以添加层数为4的数据<code>10</code>为例：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list5.png" alt> </p>
<p>添加操作对应的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A stored structure.Its add,delete,update,find operation are log(2,N)</span></span><br><span class="line"><span class="comment"> *s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SkipListNode head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxLevel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PROBABILITY = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> SkipListNode(Integer.MIN_VALUE);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * the 0th level of each SkipListNode is null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.head.nextNodes.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.maxLevel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * nextNodes represent the all levels of a SkipListNode the element on</span></span><br><span class="line"><span class="comment">         * one index represent the successor SkipListNode on the indexth level</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ArrayList&lt;SkipListNode&gt; nextNodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SkipListNode</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">            <span class="keyword">this</span>.nextNodes = <span class="keyword">new</span> ArrayList&lt;SkipListNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * put a new data into the structure-&gt;log(2,N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!contains(newValue)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// generate the level</span></span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Math.random() &lt; PROBABILITY) &#123;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update max level</span></span><br><span class="line">            <span class="keyword">if</span> (level &gt; maxLevel) &#123;</span><br><span class="line">                <span class="keyword">int</span> increment = level - maxLevel;</span><br><span class="line">                <span class="keyword">while</span> (increment-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head.nextNodes.add(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                maxLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// encapsulate value</span></span><br><span class="line">            SkipListNode newNode = <span class="keyword">new</span> SkipListNode(newValue);</span><br><span class="line">            <span class="comment">// build all the levels of new node</span></span><br><span class="line">            SkipListNode cur = findInsertionOfTopLevel(newValue, level);</span><br><span class="line">            <span class="keyword">while</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.nextNodes.get(level) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newNode.nextNodes.add(<span class="number">0</span>, cur.nextNodes.get(level));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    newNode.nextNodes.add(<span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cur.nextNodes.set(level, newNode);</span><br><span class="line">                level--;</span><br><span class="line">                cur = findNextInsertion(cur, newValue, level);</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.nextNodes.add(<span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find the insertion point of the newNode's top level from head's maxLevel</span></span><br><span class="line"><span class="comment">     * by going right or down</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue newNode's value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level    newNode's top level</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SkipListNode <span class="title">findInsertionOfTopLevel</span><span class="params">(<span class="keyword">int</span> newValue, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curLevel = <span class="keyword">this</span>.maxLevel;</span><br><span class="line">        SkipListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (curLevel &gt;= level) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.nextNodes.get(curLevel) != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; cur.nextNodes.get(curLevel).value &lt; newValue) &#123;</span><br><span class="line">                <span class="comment">// go right</span></span><br><span class="line">                cur = cur.nextNodes.get(curLevel);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// go down</span></span><br><span class="line">                curLevel--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find the next insertion from cur node by going right on the level</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SkipListNode <span class="title">findNextInsertion</span><span class="params">(SkipListNode cur, <span class="keyword">int</span> newValue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur.nextNodes.get(level) != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; cur.nextNodes.get(level).value &lt; newValue) &#123;</span><br><span class="line">            cur = cur.nextNodes.get(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * check whether a value exists-&gt;log(2,N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SkipListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> curLevel = maxLevel;</span><br><span class="line">        <span class="keyword">while</span> (curLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.nextNodes.get(curLevel) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.nextNodes.get(curLevel).value == value) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.nextNodes.get(curLevel).value &lt; value) &#123;</span><br><span class="line">                    cur = cur.nextNodes.get(curLevel);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    curLevel--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curLevel--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SkipList skipList = <span class="keyword">new</span> SkipList();</span><br><span class="line">        skipList.add(<span class="number">1</span>);</span><br><span class="line">        skipList.add(<span class="number">2</span>);</span><br><span class="line">        skipList.add(<span class="number">3</span>);</span><br><span class="line">        skipList.add(<span class="number">4</span>);</span><br><span class="line">        skipList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//mark a break point here to check the memory structure of skipList</span></span><br><span class="line">        System.out.println(skipList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><p>查找数据项的操作和添加数据项的步骤类似，也是游标<code>curNode</code>从<code>head</code>的最高层出发，每次先尝试向右走来到<code>nextNode</code>，如果<code>nextNode</code>封装的数据大于查找的目标<code>target</code>或<code>nextNode</code>为空，那么<code>curNode</code>回退并向下走；如果<code>nextNode</code>封装的数据小于<code>target</code>，那么<code>curNode</code>继续向右走，直到<code>curNode</code>走到的结点数据与<code>target</code>相同表示找到了，否则<code>curNode</code>走到了某一结点的根部<code>null</code>，那么说明结构中不存在该数据。<code>-&gt;contains()</code></p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>了解添加数据的过程之后，删除数据其实就是将逻辑倒过来：解除该数据结点的前后引用关系。下图是我在写好上述<code>add()</code>方法后，向其中放入<code>1、2、3、4、5</code>后形成的结构：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list6.png" alt> </p>
<p>如果此时删除数据<code>3</code>：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/skip_list7.png" alt> </p>
<p>首先应该从<code>head</code>的最高层出发，通过向右或向下找到数据3的最高层（如图<code>2-&gt;3-&gt;5-&gt;6-&gt;7</code>），将该层移除整体结构并处理好该层上，其前后结点的关系。同样的逻辑，将数据<code>3</code>剩下的层移除。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * delete skipListNode by the value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if exists</span></span><br><span class="line">    <span class="keyword">if</span> (contains(value)) &#123;</span><br><span class="line">        <span class="comment">//find the node and its level</span></span><br><span class="line">        SkipListNode deletedNode = head;</span><br><span class="line">        <span class="keyword">int</span> deletedLevels = maxLevel;</span><br><span class="line">        <span class="comment">//because exists,so must can find</span></span><br><span class="line">        <span class="keyword">while</span> (deletedLevels &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deletedNode.nextNodes.get(deletedLevels) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (deletedNode.nextNodes.get(deletedLevels).value == value) &#123;</span><br><span class="line">                    deletedNode = deletedNode.nextNodes.get(deletedLevels);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deletedNode.nextNodes.get(deletedLevels).value &lt; value) &#123;</span><br><span class="line">                    deletedNode = deletedNode.nextNodes.get(deletedLevels);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    deletedLevels--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deletedLevels--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//release the node and adjust the reference</span></span><br><span class="line">        <span class="keyword">while</span> (deletedLevels &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SkipListNode pre = findInsertionOfTopLevel(value, deletedLevels);</span><br><span class="line">            <span class="keyword">if</span> (deletedNode.nextNodes.get(deletedLevels) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.nextNodes.set(deletedLevels, deletedNode.nextNodes.get(deletedLevels));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.nextNodes.set(deletedLevels, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletedLevels--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SkipList skipList = <span class="keyword">new</span> SkipList();</span><br><span class="line">    skipList.add(<span class="number">1</span>);</span><br><span class="line">    skipList.add(<span class="number">2</span>);</span><br><span class="line">    skipList.add(<span class="number">3</span>);</span><br><span class="line">    skipList.add(<span class="number">4</span>);</span><br><span class="line">    skipList.add(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//mark a break point here to check the memory structure of skipList</span></span><br><span class="line">    skipList.delete(<span class="number">3</span>);</span><br><span class="line">    System.out.println(skipList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h3><p>需要遍历跳表中的数据时，我们可以根据每个数据的层数至少为1的特点（每个结点的第一层引用的是比该结点数据大的结点中数据最小的结点）。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SkipListNode cur;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipListIterator</span><span class="params">(SkipList skipList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cur = skipList.head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur.nextNodes.get(<span class="number">1</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = cur.nextNodes.get(<span class="number">1</span>).value;</span><br><span class="line">        cur = cur.nextNodes.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SkipListIterator iterator = <span class="keyword">new</span> SkipListIterator(<span class="keyword">this</span>);</span><br><span class="line">    String res = <span class="string">"[ "</span>;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        res += iterator.next()+<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">"]"</span>;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SkipList skipList = <span class="keyword">new</span> SkipList();</span><br><span class="line">    skipList.add(<span class="number">1</span>);</span><br><span class="line">    skipList.add(<span class="number">2</span>);</span><br><span class="line">    skipList.add(<span class="number">3</span>);</span><br><span class="line">    skipList.add(<span class="number">4</span>);</span><br><span class="line">    skipList.add(<span class="number">5</span>);</span><br><span class="line">    System.out.println(skipList);</span><br><span class="line">    skipList.delete(<span class="number">3</span>);</span><br><span class="line">    System.out.println(skipList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>左神算法进阶</category>
        <category>经典结构</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 垃圾回收</title>
    <url>/2020/03/12/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="本节常见面试题"><a href="#本节常见面试题" class="headerlink" title="本节常见面试题"></a>本节常见面试题</h3><p>问题答案在文中都有提到</p><ul>
<li>如何判断对象是否死亡（两种方法）。</li>
<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>
<li>如何判断一个常量是废弃常量</li>
<li>如何判断一个类是无用的类</li>
<li>垃圾收集有哪些算法，各自的特点？</li>
<li>HotSpot 为什么要分为新生代和老年代？</li>
<li>常见的垃圾回收器有哪些？</li>
<li>介绍一下 CMS,G1 收集器。</li>
<li>Minor Gc 和 Full GC 有什么不同呢？</li>
</ul><a id="more"></a>

<h3 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h3><p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/29176325.png" alt></p>
<p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1  揭开 JVM 内存分配与回收的神秘面纱"></a>1  揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p><strong>堆空间的基本结构：</strong></p>
<div align="center">  
<img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/2019-3堆结构.png" width="400px">
</div>


<p>上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/%E5%A0%86%E5%86%85%E5%AD%98.png" alt="堆内存常见分配策略 "></p>
<h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p>
<p>在测试之前我们先来看看 <strong>Minor GC 和 Full GC 有什么不同呢？</strong></p>
<ul>
<li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>
<li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>
</ul>
<blockquote>
<p><a href="https://github.com/Snailclimb/JavaGuide/issues/664" target="_blank" rel="noopener">issue#664 </a> :<strong><a href="https://github.com/guang19" target="_blank" rel="noopener">guang19</a></strong> 补充：个人在网上查阅相关资料的时候发现如题所说的观点。有的文章说 Full GC与Major GC一样是属于对老年代的GC，也有的文章说 Full GC 是对整个堆区的GC，所以这点需要各位同学自行分辨Full GC语义。见: <a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">知乎讨论</a></p>
</blockquote>
<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] allocation1, allocation2;</span><br><span class="line">		allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">		<span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以下方式运行：<br><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/25178350.png" alt></p>
<p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/10317146.png" alt></p>
<p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p>
<p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/28954286.png" alt></p>
<p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></table></figure>
<p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/28128785.png" alt></p>
<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">		allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加  1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<blockquote>
<p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>
<p><strong>动态年龄计算的代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(<span class="keyword">size_t</span> survivor_capacity) &#123;</span><br><span class="line">	<span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"> total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"> <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line"> age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672" target="_blank" rel="noopener">issue672</a>)：<strong>关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。</strong><br>如果你去Oracle的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p>
<p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.</strong></p>
</blockquote>
<h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/11034259.png" alt></p>
<h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">		ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">		objA.instance = objB;</span><br><span class="line">		objB.instance = objA;</span><br><span class="line">		objA = <span class="keyword">null</span>;</span><br><span class="line">		objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/72762049.png" alt="可达性分析算法 "></p>
<h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="2.4 不可达的对象并非“非死不可”"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h3 id="2-5-如何判断一个常量是废弃常量"><a href="#2-5-如何判断一个常量是废弃常量" class="headerlink" title="2.5 如何判断一个常量是废弃常量"></a>2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>
<p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>
<p>注意：我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd" target="_blank" rel="noopener">可能是把 Java 内存区域讲的最清楚的一篇文章 </a> 也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>
<h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt="垃圾收集算法分类"></p>
<h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>
</ol>
<img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/63707281.png" alt="公众号" width="500px">

<h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/90984624.png" alt="公众号" width="500px">

<h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/94057049.png" alt="标记-整理算法 "></p>
<h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p>
<p>根据上面的对分代收集算法的介绍回答。</p>
<h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器分类"></p>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/46873026.png" alt=" Serial 收集器 "></p>
<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
<h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>
<p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/22018368.png" alt="ParNew 收集器 "></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
</li>
<li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p>
</li>
</ul>
<h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 <strong>那么它有什么特别之处呢？</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseParallelGC</span> </span><br><span class="line"></span><br><span class="line">    使用 <span class="selector-tag">Parallel</span> 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseParallelOldGC</span></span><br><span class="line"></span><br><span class="line">    使用 <span class="selector-tag">Parallel</span> 收集器+ 老年代并行</span><br></pre></td></tr></table></figure>

<p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/22018368.png" alt="Parallel Scavenge 收集器 "></p>
<h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p> <strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</li>
</ul>
<p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/82825079.png" alt="CMS 垃圾收集器 "></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>
<li><a href="https://my.oschina.net/hosee/blog/644618" target="_blank" rel="noopener">https://my.oschina.net/hosee/blog/644618</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Gc</category>
      </categories>
  </entry>
  <entry>
    <title>Jvm 内存区域</title>
    <url>/2020/03/12/Jvm-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Java-内存区域详解"><a href="#Java-内存区域详解" class="headerlink" title="Java 内存区域详解"></a>Java 内存区域详解</h1><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><h2 id="写在前面-常见面试题"><a href="#写在前面-常见面试题" class="headerlink" title="写在前面 (常见面试题)"></a>写在前面 (常见面试题)</h2><h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><ul>
<li><strong>介绍下 Java 内存区域（运行时数据区）</strong></li>
<li><strong>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li>
<li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li>
</ul><h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><ul>
<li><strong>String 类和常量池</strong></li>
<li><strong>8 种基本类型的包装类和常量池</strong></li>
</ul><a id="more"></a>


<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>
<h2 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。</p>
<p><strong>JDK 1.8 之前：</strong></p>
<div align="center">  
<img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/JVM运行时数据区域.png" width="600px">
</div>

<p><strong>JDK 1.8 ：</strong></p>
<div align="center">  
<img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/Java运行时数据区域JDK1.8.png" width="600px">
</div>

<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</strong></p>
<ul>
<li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" alt></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" alt></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加  1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<blockquote>
<p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>
<p><strong>动态年龄计算的代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(<span class="keyword">size_t</span> survivor_capacity) &#123;</span><br><span class="line">	<span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">  uint age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<p>堆这里最容易出现的就是  OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>
<ol>
<li><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li>
<li>……</li>
</ol>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h4 id="2-5-1-方法区和永久代的关系"><a href="#2-5-1-方法区和永久代的关系" class="headerlink" title="2.5.1 方法区和永久代的关系"></a>2.5.1 方法区和永久代的关系</h4><blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<h4 id="2-5-2-常用参数"><a href="#2-5-2-常用参数" class="headerlink" title="2.5.2 常用参数"></a>2.5.2 常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>

<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h4 id="2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><ol>
<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。<blockquote>
<p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
</li>
</ol>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。  </p>
<ol start="2">
<li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。  </p>
</li>
<li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong> </p>
<p><img src="http://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/26038433.png" alt><br>——图片来源：<a href="https://blog.csdn.net/wangbiao007/article/details/78545189" target="_blank" rel="noopener">https://blog.csdn.net/wangbiao007/article/details/78545189</a></p>
<h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="三-HotSpot-虚拟机对象探秘"><a href="#三-HotSpot-虚拟机对象探秘" class="headerlink" title="三 HotSpot 虚拟机对象探秘"></a>三 HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。<br><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt></p>
<h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt></p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ol>
<li><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt></p>
</li>
<li><p><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt></p>
<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h2 id="四-重点补充内容"><a href="#四-重点补充内容" class="headerlink" title="四  重点补充内容"></a>四  重点补充内容</h2><h3 id="4-1-String-类和常量池"><a href="#4-1-String-类和常量池" class="headerlink" title="4.1 String 类和常量池"></a>4.1 String 类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;<span class="comment">//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>这两种不同的创建方法是有差别的。</p>
<ul>
<li>第一种方式是在常量池中拿对象；</li>
<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>
</ul>
<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
<p>再给大家一个图应该更容易理解，图片来源：<a href="https://www.journaldev.com/797/what-is-java-string-pool" target="_blank" rel="noopener">https://www.journaldev.com/797/what-is-java-string-pool</a>：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/String-Pool-Java1-450x249.png" alt></p>
<p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>
<ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串拼接:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"str"</span>;</span><br><span class="line">String str2 = <span class="string">"ing"</span>;</span><br><span class="line">		 </span><br><span class="line">String str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象	  </span></span><br><span class="line">String str5 = <span class="string">"string"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/jvm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A02.png" alt></p>
<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>
<h3 id="4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>
<p><strong>验证：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-8-种基本类型的包装类和常量池"><a href="#4-3-8-种基本类型的包装类和常量池" class="headerlink" title="4.3 8 种基本类型的包装类和常量池"></a>4.3 8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href="https://github.com/Snailclimb/JavaGuide/issues/461" target="_blank" rel="noopener">参见issue/461</a>）性能和资源之间的权衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;         </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">static</span> &#123;             </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)                 </span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);         </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p><strong>Integer 缓存源代码：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong></p>
<ol>
<li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>
<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>
<p><strong>Integer 比较更丰富的一个例子:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">i1</span>=<span class="keyword">i2</span>   <span class="keyword">true</span></span><br><span class="line"><span class="keyword">i1</span>=<span class="keyword">i2</span>+<span class="keyword">i3</span>   <span class="keyword">true</span></span><br><span class="line"><span class="keyword">i1</span>=<span class="keyword">i4</span>   <span class="keyword">false</span></span><br><span class="line"><span class="keyword">i4</span>=<span class="keyword">i5</span>   <span class="keyword">false</span></span><br><span class="line"><span class="keyword">i4</span>=<span class="keyword">i5</span>+<span class="keyword">i6</span>   <span class="keyword">true</span></span><br><span class="line"><span class="number">40</span>=<span class="keyword">i5</span>+<span class="keyword">i6</span>   <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>
<li>《实战 java 虚拟机》</li>
<li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a></li>
<li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="noopener">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li>
<li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou" target="_blank" rel="noopener">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li>
<li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen" target="_blank" rel="noopener">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li>
<li>深入解析String#intern<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Jvm</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法笔记进阶-经典题目</title>
    <url>/2020/03/11/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6-%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="求和为aim的最长子数组长度"><a href="#求和为aim的最长子数组长度" class="headerlink" title="求和为aim的最长子数组长度"></a>求和为aim的最长子数组长度</h2><p>举例：数组<code>[7,3,2,1,1,7,-6,-1,7]</code>中，和为<code>7</code>的最长子数组长度为4。（子数组：数组中任意个连续的数组成的数组）</p><p>大前提：如果我们求出以数组中每个数结尾的所有子数组中和为aim的子数组，那么答案一定就在其中。</p><p>规律：对于数组<code>[i,……,k,k+1,……,j]</code>，如果要求aim为800，而我们知道从<code>i</code>累加到<code>j</code>的累加和为2000，那么从<code>i</code>开始向后累加，如果累加到<code>k</code>时累加和才达到1200，那么<code>k+1~j</code>就是整个数组中累加和为800的最长子数组。</p><a id="more"></a>


<p>步骤：以<code>[7,3,2,1,1,7,-6,-3,7]</code>、<code>aim=7</code>为例，</p>
<ul>
<li>首先将<code>(0,-1)</code>放入<code>HashMap</code>中，代表0这个累加和在还没有遍历时就出现了。<code>-&gt;(0,-1)</code></li>
<li>接着每遍历一个数就将该位置形成的累加和存入<code>HashMap</code>，比如<code>arr[0]=7</code>，0位置上形成的累加和为前一个位置形成的累加和<code>0</code>加上本位置上的<code>7</code>，因此将<code>(7,0)</code>放入<code>HashMap</code>中表示0位置上第一次形成累加和为<code>7</code>，然后将该位置上的累加和减去<code>aim</code>，即<code>7-7=0</code>，找第一次形成累加和为0的位置，即<code>-1</code>，因此以下标为0结尾的子数组中和为aim的最长子数组为<code>0~0</code>，即<code>7</code>一个元素，记最大长度<code>maxLength=1</code>。<code>-&gt;(7,0)</code></li>
<li>接着来到<code>arr[1]=3</code>，1位置上形成的累加和为<code>7+3=10</code>，<code>HashMap</code>中没有<code>key</code>为<code>10</code>的记录，因此放入<code>(10,1)</code>表示1位置上最早形成累加和为10，然后将该位置上的累加和减去<code>aim</code>即<code>10-7=3</code>，到<code>HashMap</code>中找有没有<code>key</code>为<code>3</code>的记录（有没有哪个位置最早形成累加和为3），发现没有，因此以下标为1结尾的子数组中没有累加和为<code>aim</code>的。<code>-&gt;(10,1)</code></li>
<li>接着来到<code>arr[2]=2</code>，2位置上形成的累加和为<code>10+2=12</code>，<code>HashMap</code>中没有<code>key</code>为<code>12</code>的记录，因此放入<code>(12,2)</code>，<code>sum-aim=12-7=5</code>，到<code>HashMap</code>中找有没有<code>key</code>为<code>5</code>的记录，发现没有，因此以下标为2结尾的子数组中没有累加和为<code>aim</code>的。<code>-&gt;(12,2)</code></li>
<li>来到<code>arr[3]=1</code>，放入<code>(13,3)</code>，<code>sum-aim=5</code>，以下标为3结尾的子数组没有累加和为aim的。<code>-&gt;(13,3)</code></li>
<li>来到<code>arr[4]=1</code>，放入<code>(14,4)</code>，<code>sum-aim=7</code>，发现<code>HashMap</code>中有<code>key=7</code>的记录 <code>(7,0)</code>，即在0位置上累加和就能达到7了，因此<code>1~4</code>是以下标为4结尾的子数组中累积和为<code>7</code>的最长子数组，更新<code>maxLength=4</code>。<code>-&gt;(14,4)</code></li>
<li>来到<code>arr[5]=7</code>，放入<code>(21,5)</code>，<code>sum-aim=14</code>，<code>HashMap</code>中有<code>(14,4)</code>，因此<code>5~5</code>是本轮的最长子数组，但<code>maxLength=4&gt;1</code>，因此不更新。<code>-&gt;(21,5)</code></li>
<li>来到<code>arr[6]=-6</code>，放入<code>15,6</code>，没有符合的子数组。<code>-&gt;(15,6)</code></li>
<li>来到<code>arr[7]=-1</code>，累加和为<code>15+(-1)=14</code>，但 <code>HashMap</code>中有<code>key=14</code>的记录，因此不放入<code>(14,7)</code>（<code>HashMap</code>中保存的是某累加和第一次出现的位置，而14这个了累加和最早在4下标上就出现了）。<code>sum-aim=7</code>，<code>HashMap</code>中有<code>(7,0)</code>，因此本轮最长子数组为<code>1~7</code>，因此更新<code>maxLength=7</code>。</li>
<li>来到<code>arr[8]=7</code>，累加和为21，存在key为21的记录，因此不放入（21，7）。<code>sum-aim=14</code>，本轮最长子数组为<code>5~8</code>，长度为4，不更新<code>maxLength</code>。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key-&gt;accumulate sum   value-&gt;index</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        curSum += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (!hashMap.containsKey(curSum)) &#123;</span><br><span class="line">            hashMap.put(curSum, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> gap = curSum - aim;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(gap)) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = hashMap.get(gap);</span><br><span class="line">            maxLength = Math.max(maxLength, i - index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>, -<span class="number">6</span>, -<span class="number">1</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> aim = <span class="number">7</span>;</span><br><span class="line">    System.out.println(maxLength(arr, aim));<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="求奇数个数和偶数个数相同的最长子数组长度"><a href="#求奇数个数和偶数个数相同的最长子数组长度" class="headerlink" title="求奇数个数和偶数个数相同的最长子数组长度"></a>求奇数个数和偶数个数相同的最长子数组长度</h4><blockquote>
<p>将奇数置为1，偶数置为-1，就转化成了求和为0的最长子数组长度</p>
</blockquote>
<h4 id="求数值为1的个数和数值为2的个数相同的最长子数组（数组只含0、1、2三种元素）"><a href="#求数值为1的个数和数值为2的个数相同的最长子数组（数组只含0、1、2三种元素）" class="headerlink" title="求数值为1的个数和数值为2的个数相同的最长子数组（数组只含0、1、2三种元素）"></a>求数值为1的个数和数值为2的个数相同的最长子数组（数组只含0、1、2三种元素）</h4><blockquote>
<p>将2置为-1，就转化成了求和为0的最长子数组长度</p>
</blockquote>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="求任意划分数组的方案中，划分后，异或和为0的子数组最多有多少个"><a href="#求任意划分数组的方案中，划分后，异或和为0的子数组最多有多少个" class="headerlink" title="求任意划分数组的方案中，划分后，异或和为0的子数组最多有多少个"></a>求任意划分数组的方案中，划分后，异或和为0的子数组最多有多少个</h4><p>举例：给你一个数组<code>[1,2,3,0,2,3,1,0]</code>，你应该划分为<code>[1,2,3],[0],[2,3,1],[0]</code>，答案是4。</p>
<p><strong>大前提</strong>：如果我们求出了以数组中每个数为结尾的所有子数组中，任意划分后，异或和为0的子数组最多有多少个，那么答案一定就在其中。</p>
<p><strong>规律</strong>：异或运算符合交换律和结合律。<code>0^N=N</code>，<code>N^N=0</code>。</p>
<p><strong>可能性分析</strong>：对于一个数组<code>[i，……，j，m，……，n,k]</code>，假设进行符合题意的最优划分后形成多个子数组后，k作为整个数组的末尾元素必定也是最后一个子数组的末尾元素。最后一个子数组只会有两种情况：异或和不为0、异或和为0。</p>
<ul>
<li>如果是前者，那么最后一个子数组即使去掉k这个元素，其异或和也不会为0，否则最优划分会将最后一个子数组划分为两个子数组，其中k单独为一个子数组。比如最后一个子数组是<code>indexOf(m)~indexOf(k)</code>，其异或和不为0，那么<code>dp[indexOf(k)]=dp[indexOf(k)-1]</code>，表示数组<code>0~indexOf(k)</code>的解和其子数组<code>0~(indexOf(k)-1)</code>的解是一样的。<code>-&gt;case 1</code></li>
<li>如果是后者，那么最后一个子数组中不可能存在以k为结尾的更小的异或和为0的子数组。比如最后一个子数组是<code>indexOf(m)~indexOf(k)</code>，其异或和为0，那么<code>dp[indexOf(k)]=dp[indexOf(m)-1]+1</code>，表示数组<code>0~indexOf(k)</code>的解=子数组<code>0~(indexOf(m)-1)</code>的解+1。<code>-&gt;case 2</code></li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArrs</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> curXorSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        curXorSum ^= arr[i];</span><br><span class="line">        <span class="comment">//case 1，之前没有出现过这个异或和，那么该位置上的dp等于前一个位置的dp</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(curXorSum)) &#123;</span><br><span class="line">            dp[i] = i &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//case 2，之前出现过这个异或和，那么之前这个异或和出现的位置到当前位置形成的子数组异或和为0</span></span><br><span class="line">            <span class="keyword">int</span> index = map.get(curXorSum);</span><br><span class="line">            dp[i] = index &gt; <span class="number">0</span> ? dp[index] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最近出现的异或和都记录下来，因为要划分出最多的异或和为0的子数组</span></span><br><span class="line">        map.put(curXorSum, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个位置的dp就是整个问题的解</span></span><br><span class="line">    <span class="keyword">return</span> dp[dp.length -<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    System.out.println(maxSubArrs(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高度套路的二叉树信息收集问题"><a href="#高度套路的二叉树信息收集问题" class="headerlink" title="高度套路的二叉树信息收集问题"></a>高度套路的二叉树信息收集问题</h2><h3 id="求一棵二叉树的最大搜索二叉子树的结点个数"><a href="#求一棵二叉树的最大搜索二叉子树的结点个数" class="headerlink" title="求一棵二叉树的最大搜索二叉子树的结点个数"></a>求一棵二叉树的最大搜索二叉子树的结点个数</h3><blockquote>
<p>最大搜索二叉子树指该二叉树的子树中，是搜索二叉树且结点个数最多的。</p>
</blockquote>
<p>这类题一般都有一个<strong>大前提</strong>：<strong>假设对于以树中的任意结点为头结点的子树，我们都能求得其最大搜索二叉子树的结点个数，那么答案一定就在其中</strong>。</p>
<p>而对于以任意结点为头结点的子树，其最大搜索二叉子树的求解分为三种情况（<strong>列出可能性</strong>）：</p>
<ul>
<li>整棵树的最大搜索二叉子树存在于左子树中。这要求其左子树中存在最大搜索二叉子树，而其右子树不存在。</li>
<li>整棵树的最大搜索二叉子树存在于右子树中。这要求其右子树中存在最大搜索二叉子树，而其左子树不存在。</li>
<li>最整棵二叉树的最大搜索二叉子树就是其本身。这需要其左子树就是一棵搜索二叉子树且左子树的最大值结点比头结点小、其右子树就是一棵搜索二叉子树且右子树的最小值结点比头结点大。</li>
</ul>
<p>要想区分这三种情况，我们需要收集的信息：</p>
<ul>
<li>子树中是否存在最大搜索二叉树</li>
<li>子树的头结点</li>
<li>子树的最大值结点</li>
<li>子树的最小值结点</li>
</ul>
<p>因此我们就可以开始我们的高度套路了：</p>
<ol>
<li>将要从子树收集的信息封装成一个<code>ReturnData</code>，代表处理完这一棵子树要向上级返回的信息。</li>
<li>假设我利用子过程收集到了子树的信息，接下来根据子树的信息和分析问题时列出的情况加工出当前这棵树要为上级提供的所有信息，并返回给上级（<strong>整合信息</strong>）。</li>
<li>确定<code>base case</code>，子过程到子树为空时，停。</li>
</ol>
<p>根据上面高度套路的分析，可以写出解决这类问题高度相似的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">int</span> size, Node head, <span class="keyword">int</span> max, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="number">0</span>, <span class="keyword">null</span>, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ReturnData leftInfo = process(root.left);</span><br><span class="line">    ReturnData rightInfo = process(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//case 1</span></span><br><span class="line">    <span class="keyword">int</span> leftSize = leftInfo.size;</span><br><span class="line">    <span class="comment">//case 2</span></span><br><span class="line">    <span class="keyword">int</span> rightSize = rightInfo.size;</span><br><span class="line">    <span class="keyword">int</span> selfSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo.head == root.left &amp;&amp; rightInfo.head == root.right</span><br><span class="line">        &amp;&amp; leftInfo.max &lt; root.data &amp;&amp; rightInfo.min &gt; root.data) &#123;</span><br><span class="line">        <span class="comment">//case 3</span></span><br><span class="line">        selfSize = leftInfo.size + rightInfo.size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSize = Math.max(Math.max(leftSize, rightSize), selfSize);</span><br><span class="line">    Node maxHead = leftSize &gt; rightSize ? leftInfo.head : </span><br><span class="line">    				selfSize &gt; rightSize ? root : rightInfo.head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(maxSize, maxHead, </span><br><span class="line">                          Math.max(Math.max(leftInfo.max, rightInfo.max), root.data), </span><br><span class="line">                          Math.min(Math.min(leftInfo.min, rightInfo.min), root.data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    root.left = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    root.right = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    root.left.left = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">    root.left.left.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    root.left.left.right = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    System.out.println(process(root).size);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求一棵二叉树的最远距离"><a href="#求一棵二叉树的最远距离" class="headerlink" title="求一棵二叉树的最远距离"></a>求一棵二叉树的最远距离</h3><p>如果在二叉树中，小明从结点A出发，既可以往上走到达它的父结点，又可以往下走到达它的子结点，那么小明从结点A走到结点B最少要经过的结点个数（包括A和B）叫做A到B的距离，任意两结点所形成的距离中，最大的叫做树的最大距离。</p>
<p><strong>高度套路化</strong>：</p>
<p>大前提：如果对于以该树的任意结点作为头结点的子树中，如果我们能够求得所有这些子树的最大距离，那么答案就在其中。</p>
<p>对于该树的任意子树，其最大距离的求解分为以下三种情况：</p>
<ul>
<li>该树的最大距离是左子树的最大距离。</li>
<li>该树的最大距离是右子树的最大距离。</li>
<li>该树的最大距离是从左子树的最深的那个结点经过该树的头结点走到右子树的最深的那个结点。</li>
</ul>
<p>要从子树收集的信息：</p>
<ul>
<li>子树的最大距离</li>
<li>子树的深度</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxDistance;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">int</span> maxDistance, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxDistance = maxDistance;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData leftInfo = process(root.left);</span><br><span class="line">    ReturnData rightInfo = process(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//case 1</span></span><br><span class="line">    <span class="keyword">int</span> leftMaxDistance = leftInfo.maxDistance;</span><br><span class="line">    <span class="comment">//case 2</span></span><br><span class="line">    <span class="keyword">int</span> rightMaxDistance = rightInfo.maxDistance;</span><br><span class="line">    <span class="comment">//case 3</span></span><br><span class="line">    <span class="keyword">int</span> includeHeadDistance = leftInfo.height + <span class="number">1</span> + rightInfo.height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = Math.max(Math.max(leftMaxDistance, rightMaxDistance), includeHeadDistance);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(max, Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    root.left = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    root.right = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    root.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">    root.left.left = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">    root.left.left.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    root.left.left.right = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    System.out.println(process(root).maxDistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高度套路化：列出可能性-&gt;从子过程收集的信息中整合出本过程要返回的信息-&gt;返回</p>
<h3 id="舞会最大活跃度"><a href="#舞会最大活跃度" class="headerlink" title="舞会最大活跃度"></a>舞会最大活跃度</h3><p>一个公司的上下级关系是一棵多叉树，这个公司要举办晚会，你作为组织者已经摸清了大家的心理：<strong>一个员工的直</strong><br><strong>接上级如果到场，这个员工肯定不会来</strong>。每个员工都有一个活跃度的值（值越大，晚会上越活跃），<strong>你可以给某个员工发邀请函以决定谁来</strong>，怎么让舞会的气氛最活跃？返回最大的活跃值。</p>
<p>举例：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_happy.png" alt> </p>
<p>如果邀请A来，那么其直接下属BCD一定不会来，你可以邀请EFGHJKL中的任意几个来，如果都邀请，那么舞会最大活跃度为<code>A(2)+E(9)+F(11)+G(2)+H(4)+J(7)+K(13)+L(5)</code>；但如果选择不邀请A来，那么你可以邀请其直接下属BCD中任意几个来，比如邀请B而不邀请CD，那么B的直接下属E一定不回来，但CD的直接下属你可以选择性邀请。</p>
<p><strong>大前提</strong>：如果你知道每个员工来舞会或不来舞会对舞会活跃值的影响，那么舞会最大活跃值就容易得知了。比如是否邀请A来取决于：B来或不来两种情况中选择对舞会活跃值增益最大的那个+C来或不来两种情况中选择对舞会活跃值增益最大的那个+D来或不来两种情况中选择对舞会活跃值增益最大的那个；同理，对于任意一名员工，是否邀请他来都是用此种决策。</p>
<p><strong>列出可能性</strong>：来或不来。</p>
<p><strong>子过程要收集的信息</strong>：返回子员工来对舞会活跃值的增益值和不来对舞会的增益值中的较大值。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> happy;</span><br><span class="line">    List&lt;Node&gt; subs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> happy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.happy = happy;</span><br><span class="line">        <span class="keyword">this</span>.subs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxHappy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">int</span> maxHappy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxHappy = maxHappy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.subs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(root.happy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//case 1:go</span></span><br><span class="line">    <span class="keyword">int</span> go_Happy = root.happy;</span><br><span class="line">    <span class="comment">//case 2:don't go</span></span><br><span class="line">    <span class="keyword">int</span> unGo_Happy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node sub : root.subs) &#123;</span><br><span class="line">        unGo_Happy += process(sub).maxHappy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(Math.max(go_Happy, unGo_Happy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPartyHappy</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(root).maxHappy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Node A = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    Node B = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">    Node C = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    Node D = <span class="keyword">new</span> Node(<span class="number">24</span>);</span><br><span class="line">    B.subs.add(<span class="keyword">new</span> Node(<span class="number">9</span>));</span><br><span class="line">    C.subs.addAll(Arrays.asList(<span class="keyword">new</span> Node(<span class="number">11</span>),<span class="keyword">new</span> Node(<span class="number">2</span>),<span class="keyword">new</span> Node(<span class="number">4</span>),<span class="keyword">new</span> Node(<span class="number">7</span>)));</span><br><span class="line">    D.subs.addAll(Arrays.asList(<span class="keyword">new</span> Node(<span class="number">13</span>), <span class="keyword">new</span> Node(<span class="number">5</span>)));</span><br><span class="line">    A.subs.addAll(Arrays.asList(B, C, D));</span><br><span class="line">    System.out.println(maxPartyHappy(A));<span class="comment">//57</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求一个数学表达式的值"><a href="#求一个数学表达式的值" class="headerlink" title="求一个数学表达式的值"></a>求一个数学表达式的值</h2><p>给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号，返回公式的计算结果。</p>
<p>举例：<code>str=&quot;48*((70-65)-43)+8*1&quot;</code>，返回-1816。<code>str=&quot;3+1*4&quot;</code>，返回7。 <code>str=&quot;3+(1*4)&quot;</code>，返回7。</p>
<p>说明：</p>
<ol>
<li>可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查。</li>
<li>如果是负数，就需要用括号括起来，比如<code>&quot;4*(-3)&quot;</code>。但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如<code>&quot;-3*4&quot;和&quot;(-3*4)&quot;</code>都是合法的。</li>
<li>不用考虑计算过程中会发生溢出的情况</li>
</ol>
<p>最优解分析：此题的难度在于如何处理表达式中的括号，可以借助一个栈。但如果仅仅靠一个栈，代码量会显得纷多繁杂。如果我们将式中包含左右括号的子表达式的计算单独抽出来作为一个过程（记为<code>process</code>），那么该过程可以被复用，如果我们将整个表达式中所有包含左右括号的子表达式当做一个数值，那么原始问题就转化为计算不含括号的表达式了。</p>
<p>以表达式<code>3+2*5-(7+2)*3</code>为例分析解题步骤：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/postfix_expression.png" alt> </p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String exp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(exp.toCharArray(), <span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exp   expression</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the start index of expression</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int[], include two elements:the result and the endIndex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] process(<span class="keyword">char</span>[] exp, <span class="keyword">int</span> index) &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList que = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">//下一个要往队尾放的数</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//黑盒process返回的结果</span></span><br><span class="line">    <span class="keyword">int</span> sub[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; exp.length &amp;&amp; exp[index] != <span class="string">')'</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exp[index] &gt;= <span class="string">'0'</span> &amp;&amp; exp[index] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + exp[index] - <span class="string">'0'</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp[index] != <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="comment">// +、-、*、/</span></span><br><span class="line">            addNum(num, que);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            que.addLast(String.valueOf(exp[index]));</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// '('</span></span><br><span class="line">            sub = process(exp, index + <span class="number">1</span>);</span><br><span class="line">            num = sub[<span class="number">0</span>];</span><br><span class="line">            index = sub[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addNum(num, que);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;getSum(que), index&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(LinkedList&lt;String&gt; que)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.valueOf(que.pollFirst());</span><br><span class="line">        res += add ? num : -num;</span><br><span class="line">        <span class="keyword">if</span> (!que.isEmpty()) &#123;</span><br><span class="line">            add = que.pollFirst().equals(<span class="string">"+"</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num, LinkedList&lt;String&gt; que)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!que.isEmpty()) &#123;</span><br><span class="line">        String element = que.pollLast();</span><br><span class="line">        <span class="keyword">if</span> (element.equals(<span class="string">"+"</span>) || element.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            que.addLast(element);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// * or /</span></span><br><span class="line">            Integer preNum = Integer.valueOf(que.pollLast());</span><br><span class="line">            num = element.equals(<span class="string">"*"</span>) ? (preNum * num) : (preNum / num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    que.addLast(String.valueOf(num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String exp = <span class="string">"48*((70-65)-43)+8*1"</span>;</span><br><span class="line">    System.out.println(getValue(exp));</span><br><span class="line">    System.out.println(-<span class="number">48</span>*<span class="number">38</span>+<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求异或和最大的子数组"><a href="#求异或和最大的子数组" class="headerlink" title="求异或和最大的子数组"></a>求异或和最大的子数组</h2><p>给你一个数组，让你找出所有子数组的异或和中，最大的是多少。</p>
<h3 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h3><p>遍历数组中的每个数，求出以该数结尾所有子数组的异或和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NumTrie</span></span>&#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        TrieNode[] nexts;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">            nexts = <span class="keyword">new</span> TrieNode[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> path = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.nexts[path] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.nexts[path] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nexts[path];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * find the max value of xor(0,k-1)^xor(0,i)-&gt; the max value of xor(k,i)</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> num -&gt; xor(0,i)</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxXor</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> path = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果是符号位，那么尽量和它相同（这样异或出来就是正数），如果是数值位那么尽量和它相反</span></span><br><span class="line">            <span class="keyword">int</span> bestPath = i == <span class="number">31</span> ? path : (path ^ <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果贪心路径不存在，就只能走另一条路</span></span><br><span class="line">            bestPath = cur.nexts[bestPath] != <span class="keyword">null</span> ? bestPath : (bestPath ^ <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//记录该位上异或的结果</span></span><br><span class="line">            res |= (bestPath ^ path) &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">            cur = cur.nexts[bestPath];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxXorSubArray</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxXorSum = Integer.MIN_VALUE;</span><br><span class="line">    NumTrie numTrie = <span class="keyword">new</span> NumTrie();</span><br><span class="line">    <span class="comment">//没有数时异或和为0，这个也要加到前缀数中，否则第一次到前缀树找bestPath会报空指针</span></span><br><span class="line">    numTrie.addNum(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> xorZeroToI = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        xorZeroToI ^= arr[i];</span><br><span class="line">        maxXorSum = Math.max(maxXorSum, numTrie.maxXor(xorZeroToI));</span><br><span class="line">        numTrie.addNum(xorZeroToI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxXorSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(maxXorSubArray(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为<code>O(N^3)</code></p>
<h3 id="优化暴力解"><a href="#优化暴力解" class="headerlink" title="优化暴力解"></a>优化暴力解</h3><p>观察暴力解，以 <code>{1, 2, 3, 4, 1, 2, 0}</code>为例，当我计算以<code>4</code>结尾的所有子数组的异或和时，我会先计算子数组<code>{4}</code>的，然后计算<code>{3,4}</code>的，然后计算<code>{2,3,4}</code>的，也就是说每次都是从头异或到尾，之前的计算的结果并没有为之后的计算过程加速。于是，我想着，当我计算<code>{3,4}</code>的时候，将<code>3^4</code>的结果临时保存一下，在下次的<code>{2,3,4}</code>的计算时复用一下，再保存一下<code>2^3^4</code>的结果，在下次的<code>{1,2,3,4}</code>的计算又可以复用一下。于是暴力解就被优化成了下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//以i结尾的最大异或和</span></span><br><span class="line">        <span class="keyword">int</span> maxXorSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            temp ^= arr[j];</span><br><span class="line">            maxXorSum = Math.max(maxXorSum, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整体的最大异或和</span></span><br><span class="line">        res = Math.max(res, maxXorSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    System.out.println(solution2(arr));<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时时间复杂度降为了<code>O(N^2)</code></p>
<h3 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h3><p>然而使用前缀树结构能够做到时间复杂度<code>O(N)</code>。</p>
<p>解题思路：将以<code>i</code>结尾的所有子数组的最大异或和的求解限制在<code>O(1)</code>。</p>
<p>解题技巧：</p>
<ol>
<li><p>对于子数组<code>0~i</code>（i是合法下标）和<code>0~i</code>之间的下标<code>k</code>(k大于等于0，小于等于i)，<code>k~i</code>的异或和<code>xor(k,i)</code>、<code>0~i</code>的异或和<code>xor(0,i)</code>、<code>0~k-1</code>之间的异或和<code>xor(0,k-1)</code>三者之间存在如下关系：<code>xor(k,i)=xor(0,i) ^ xor(o,k-1)</code>（<code>A^B=C -&gt; B=C^A</code>），因此求<code>xor(k,i)</code>的最大值可以转化成求<code>xor(0,i) ^ xor(o,k-1)</code>的最大值（<strong>这个思路很重要</strong>，后续步骤就是根据这个来的）。</p>
</li>
<li><p>遍历数组，将以首元素开头，以当前遍历元素结尾的子数组的异或和的32位二进制数放入前缀树结构中（每一位作为一个字符，且字符非0即1）。遍历结束后，所有<code>0~i</code>的异或和就存放在前缀树中了。比如：遍历<code>{1, 2, 3, 4, 1, 2, 0}</code>形成的前缀树如下：</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_xor.png" alt> </p>
</li>
<li><p>假设遍历数组建立前缀树的过程中，遍历到<code>4</code>这个数来了，将<code>0 100</code>放入其中，由于之前还遍历过<code>1,2,3</code>，所以<code>xor(0,0)</code>、<code>xor(0,1)</code>、<code>xor(0,2)</code>也是在前缀树中的。如果此时要求<code>xor(k,3)</code>的最大值（k在下标0和3之间且包括0和3），可以将其转化为求<code>xor(0,3) ^ xor(0,k-1)</code>，而我们已知<code>xor(0,3)=0 100</code>，所以<code>xor(0,k-1)</code>的求解就变成了关键。</p>
<p> <code>xor(0,k-1)</code>的求解：此时游标<code>cur</code>从前缀树的根结点走向叶子结点，<code>cur</code>沿途经过的二进制位连在一起就是<code>xor(0,k-1)</code>，要求每次选择要经过哪个二进制位时，尽可能使之与<code>xor(0,3)</code>的异或结果更大：</p>
<p> <img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_xor1.png" alt> </p>
</li>
</ol>
<p>这个求解过程就是在<strong>贪心</strong>（如果是符号位，那么尽可能让异或结果为0，如果是数值位，那么尽可能让异或结果为1），前缀树里只放着<code>xor(0,0)、xor(0,1)、xor(0,2)、xor(0,3)</code>，而<code>xor(0,k-1)</code>只能从中取值，这个从根节点一步步试探走到叶子结点的过程就是在贪，哪一条路径对应的<code>xor</code>使得<code>xor ^ xor(0,3)</code>最大。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NumTrie</span></span>&#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        TrieNode[] nexts;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">            nexts = <span class="keyword">new</span> TrieNode[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> path = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.nexts[path] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.nexts[path] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nexts[path];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * find the max value of xor(0,k-1)^xor(0,i)-&gt; the max value of xor(k,i)</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> num -&gt; xor(0,i)</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxXor</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> path = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果是符号位，那么尽量和它相同（这样异或出来就是正数），如果是数值位那么尽量和它相反</span></span><br><span class="line">            <span class="keyword">int</span> bestPath = i == <span class="number">31</span> ? path : (path ^ <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果贪心路径不存在，就只能走另一条路</span></span><br><span class="line">            bestPath = cur.nexts[bestPath] != <span class="keyword">null</span> ? bestPath : (bestPath ^ <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//记录该位上异或的结果</span></span><br><span class="line">            res |= (bestPath ^ path) &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">            cur = cur.nexts[bestPath];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxXorSubArray</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxXorSum = <span class="number">0</span>;</span><br><span class="line">    NumTrie numTrie = <span class="keyword">new</span> NumTrie();</span><br><span class="line">    <span class="comment">//一个数自己异或自己异或和为0，这个也要加到前缀数中，否则第一次到前缀树找bestPath会报空指针</span></span><br><span class="line">    numTrie.addNum(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> xorZeroToI = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        xorZeroToI ^= arr[i];</span><br><span class="line">        maxXorSum = Math.max(maxXorSum, numTrie.maxXor(xorZeroToI));</span><br><span class="line">        numTrie.addNum(xorZeroToI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxXorSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(maxXorSubArray(arr));<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求和为aim的最长子数组（都大于0）"><a href="#求和为aim的最长子数组（都大于0）" class="headerlink" title="求和为aim的最长子数组（都大于0）"></a>求和为aim的最长子数组（都大于0）</h2><p>基础篇中有过相同的题，只不过这里的数组元素值为正数，而基础篇中的可正可负可0。</p>
<p>基础篇中的做法是用一个哈希表记录子数组和出现的最早的位置。而此题由于数据特殊性（都是正数）可以在额外空间复杂度<code>O(1)</code>，时间复杂度<code>O(N)</code>内完成。</p>
<p>使用一个窗口，用L表示窗口的左边界、R表示窗口的右边界，用sum表示窗口内元素之和（初始为0）。起初，L和R都停在-1位置上，接下来每次都要将L向右扩一步或将R向右扩一步，具体扩哪个视情况而定：</p>
<ul>
<li>如果`sum，那么R往右边扩</li>
<li>如果<code>sum=aim</code>，那么记录窗口内元素个数，L往右边扩</li>
<li>如果<code>sum&gt;aim</code>，那么L往右边扩</li>
</ul>
<p>直到R扩到<code>arr.length</code>越界，那么此时窗口内元素之和必定小于aim，整个过程可以结束。答案就是所有<code>sum=aim</code>情况下窗口内元素最多时的个数。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组元素均为正数，求和为aim的最长子数组的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aimMaxSubArray</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R= -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (R != arr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; aim) &#123;</span><br><span class="line">            R++;</span><br><span class="line">            <span class="keyword">if</span> (R &lt; arr.length) &#123;</span><br><span class="line">                sum += arr[R];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == aim) &#123;</span><br><span class="line">            len = Math.max(len, R - L);</span><br><span class="line">            sum -= arr[++L];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum -= arr[++L];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    System.out.println(aimMaxSubArray(arr,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考：为什么这个流程得到的答案是正确的呢？也就是说，为什么窗口向右滑动的过程中，不会错过和为aim的最长子数组？我们可以来证明一下：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_length_aim_arr.png" alt> </p>
<p>假设，椭圆区域就是和为aim的最长子数组，如果L来到了椭圆区域的左边界L2，那么R的位置有两种情况：在椭圆区域内比如R1，在椭圆区域外比如R2。如果是前者，由于窗口<code>L2~R1</code>是肯定小于<code>aim</code>的（元素都是正数），因此在R从R1右移到椭圆区域右边界过程中，L是始终在L2上的，显然不会错过正确答案；如果是后者，窗口<code>L2~R2</code>的<code>sum</code>明显超过了<code>aim</code>，因此这种情况是不可能存在的。而L在L2左边的位置上，比如L1时，R更不可能越过椭圆区域来到了R2，因为窗口是始终保持<code>sum&lt;=aim</code>的。</p>
<h2 id="求和小于等于aim的最长子数组（有正有负有0）"><a href="#求和小于等于aim的最长子数组（有正有负有0）" class="headerlink" title="求和小于等于aim的最长子数组（有正有负有0）"></a>求和小于等于aim的最长子数组（有正有负有0）</h2><p>如果使用暴力枚举，枚举出以每个元素开头的子数组，那么答案一定就在其中（<code>O(N^3)</code>）。但这里介绍一种时间复杂度<code>O(N)</code>的解。</p>
<p>首先从尾到头遍历一遍数组，生成两个辅助数组<code>min_sum</code>和<code>min_sum_index</code>作为求解时的辅助信息。<code>min_sum</code>表示以某个元素开头的所有子数组中和最小为多少，<code>min_sum_index</code>则对应保存该最小和子数组的结束下标。</p>
<p>举例：对于<code>[100,200,7,-6]</code>。</p>
<ol>
<li>首先遍历3位置上的<code>-6</code>，以<code>-6</code>开头的子数组只有<code>[-6]</code>，因此<code>min_sum[3] = -6, min_sum_index[3] = 3</code>（<code>[-6]</code>的尾元素<code>-6</code>在原数组中的下标是<code>3</code>）。</li>
<li>接着遍历到2位置上的<code>7</code>，以<code>7</code>开头的最小和子数组是<code>[7,-6]</code>，因此<code>min_sum[2] = 7-6 = 1, min_sum_index[2]=3</code>。（<code>[7,-6]</code>的尾元素<code>-6</code>在原数组中的下标是<code>3</code>）。</li>
<li>接着遍历到1位置上的<code>200</code>，有<code>min_sum[1] = 200, min_sum_index[1] = 1</code>。</li>
<li>接着遍历到0位置上的<code>100</code>，有<code>min_sum[0] = 100, min_sum_index[0] = 0</code>。</li>
</ol>
<p>那么遍历完数组，生成两个辅助数组之后，就可以开始正式的求解流程了：</p>
<p>使用一个窗口，L表示窗口的左边界，R表示窗口的右边界，<code>sum</code>表示窗口内元素之和。</p>
<ul>
<li>L从头到尾依次来到数组中的每个元素，每次L来到其中一个元素上时，都尝试向右扩R，R扩到不能扩时，窗口大小<code>R-L</code>即为以该元素开头的、和小于等于aim的最长子数组的长度。</li>
<li>L起初来到首元素，R起初也停在首元素，<code>sum=0</code>。</li>
<li>R向右扩一次的逻辑是：如果<code>sum + min_sum[L] &lt;= aim</code>，那么R就扩到<code>min_sum_index[L] + 1</code>的位置，并更新<code>sum</code>。</li>
<li>R扩到不能扩时，记录<code>R-L</code>，L去往下一个元素，并更新<code>sum</code>。</li>
<li>如果L来到一个元素后，<code>sum &gt; aim</code>，说明以该元素开头的、和小于等于aim的最长子数组的长度，比当前的窗口大小<code>R-L</code>还要小，那么以该元素开头的子数组不在正确答案的考虑范围之内（因为上一个元素形成的最大窗口大于当前元素能形成的最大窗口，并且前者已经被记录过了），L直接去往一下个元素并更新<code>sum</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/max_length_aim_arr1.png" alt> </p>
<p>示例代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">int</span> lessOrEqualAim(<span class="built_in">int</span> arr[], <span class="built_in">int</span> aim) &#123;</span><br><span class="line">    <span class="built_in">int</span> min_sum[] = new <span class="built_in">int</span>[arr.length];</span><br><span class="line">    <span class="built_in">int</span> min_sum_index[] = new <span class="built_in">int</span>[arr.length];</span><br><span class="line">    min_sum[arr.length<span class="number">-1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    min_sum_index[arr.length<span class="number">-1</span>] = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_sum[i + <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            min_sum[i] = arr[i] + min_sum[i + <span class="number">1</span>];</span><br><span class="line">            min_sum_index[i] = min_sum_index[i + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min_sum[i] = arr[i];</span><br><span class="line">            min_sum_index[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> R = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> L = <span class="number">0</span>; L &lt; arr.length; L++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; arr.length &amp;&amp; sum + min_sum[R] &lt;= aim) &#123;</span><br><span class="line">            sum += min_sum[R];</span><br><span class="line">            R = min_sum_index[R] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(maxLen, R - L);</span><br><span class="line">        sum -= R == L ? <span class="number">0</span> : arr[L];</span><br><span class="line">        R = Math.max(R, L + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">    <span class="built_in">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    System.<span class="keyword">out</span>.println(lessOrEqualAim(arr,<span class="number">3</span>));<span class="comment">//8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>19-27</code>行是实现的难点，首先19行是L从头到尾来到数组中的每个元素，然后<code>20-23</code>的<code>while</code>是尝试让R扩直到R扩不动为止，<code>24</code>行当R扩不动时就可以记录以当前L位置上的元素开头的、和小于等于aim的最长子数组长度，最后在进入下一次<code>for</code>循环、L右移一步之前，<code>sum</code>的更新有两种情况：</p>
<ol>
<li><code>29</code>行的<code>while</code>执行了，<code>R</code>扩出去了，因此<code>sum</code>直接减去当前L上的元素即可。</li>
<li><code>29</code>行的<code>while</code>压根就没执行，<code>R</code>一步都没扩出去且和<code>L</code>在同一位置上，也就是说此刻窗口内没有元素（只有当R&gt;L时，窗口才包含从L开始到R之前的元素），<code>sum=0</code>，L和R应该同时来到下一个元素，<code>sum</code>仍为0，所以<code>sum</code>不必减去<code>arr[L]</code>（只有当L右移导致一个元素从窗口出去时才需要减<code>arr[L]</code>）。</li>
</ol>
<p>最后<code>26</code>行也是为了保证如果L在右移的过程中，R一直都扩不出去，那么在L右移到R上R仍旧扩不出去时，接下来R应该和L同时右移一个位置。</p>
<blockquote>
<p>此方法能够做到<code>O(N)</code>时间复杂度的关键点是：舍去无效情况。比如L在右移一步更新<code>sum</code>之后，如果发现<code>sum &gt; aim</code>，显然以当前L开头的、和小于等于aim的最长子数组肯定小于当前的<code>R-L</code>，而在上一步就记录了<code>R-(L-1)</code>，以当前L开头的满足条件的子数组可以忽略掉（因为一定小于<code>R-(L-1)</code>），而不必让R回退到当前L重新来扩R。</p>
<p>这样L和R都只右移而不回退，所以时间复杂度就是遍历了一遍数组。</p>
</blockquote>
<h2 id="环形单链表的约瑟夫问题"><a href="#环形单链表的约瑟夫问题" class="headerlink" title="环形单链表的约瑟夫问题"></a>环形单链表的约瑟夫问题</h2><p>据说著名犹太历史学家Josephus有过以下故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整个自杀过程。</p>
<blockquote>
<p><strong>输入</strong>：一个环形单向链表的头节点head和报数的值m。</p>
<p><strong>返回</strong>：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。</p>
<p><strong>进阶</strong>：如果链表节点数为N，想在时间复杂度为O(N)时完成原问题的要求，该怎么实现？</p>
</blockquote>
<p>暴力方法：从头结点开始数，从1数到m，数到m时删除结点，再从下一个结点开始数……如此要删除（n-1）个结点，并且每次删除之前要数m个数，因此时间复杂度为<code>O(NxM)</code></p>
<p>这里介绍一种<code>O(N)</code>的方法。</p>
<p>首先介绍一个函数：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/joseph_circle.png" alt> </p>
<p>如果从头结点开始，为每个结点依次编号1、2、3、……，比如环形链表有3个结点，每次报数到7时杀人：</p>
<table>
<thead>
<tr>
<th align="left">结点编号</th>
<th align="left">报数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">杀人</td>
</tr>
</tbody></table>
<p>那么在杀人之前，结点编号和报数有如下对应关系（x轴代表此刻报数报到哪儿了，y轴则对应是几号结点报的，n是结点数量）：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/joseph_circle1.png" alt> </p>
<p>假设每次杀人后，都从下一结点重新编号、重新报数，比如环形链表有9个结点，报数到7就杀人，那么杀人之前结点的旧编号和杀人重新编号后结点的新编号有如下关系：</p>
<table>
<thead>
<tr>
<th align="left">旧编号</th>
<th align="left">新编号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">被杀，从下一结点开始重新编号</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">2</td>
</tr>
</tbody></table>
<p>如果链表结点数为n，报数到m杀人，那么结点的新旧编号对应关系如下（其中<code>s</code>为报数为m的结点编号）：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/joseph_circle2.png" alt> </p>
<p>这个图也可以由基本函数<code>y = (x - 1) % n + 1</code>向左平移s个单位长度变换而来：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/joseph_circle3.png" alt> </p>
<p>即<code>y = (x - 1 + s) % n + 1</code>。</p>
<p>现在我们有了如下两个公式：</p>
<ol>
<li><code>结点编号 = (报数 - 1) % n + 1</code></li>
<li><code>旧编号 = (新编号 - 1 + s) % n +1</code>，其中<code>s</code>为报数为m的结点编号</li>
</ol>
<p>由1式可得<code>s = (m - 1) % n + 1</code>，带入2式可得</p>
<ol start="3">
<li><code>旧编号 = (新编号 - 1 + (m - 1) % n + 1) % n + 1 = (新编号 + m - 1) % n + 1</code>，其中<code>m</code>和<code>n</code>由输入参数决定。</li>
</ol>
<p>现在我们有了等式3，就可以在已知一个结点在另一个结点被杀之后的新编号的情况下，求出该结点的旧编号。也就是说，假设现在杀到了第<code>n-1</code>个结点，杀完之后只剩下最后一个结点了（天选结点），重新编号后天选结点肯定是1号，那么第<code>n-1</code>个被杀结点被杀之前天选结点的编号我们就可以通过等式3求出来，通过这个结果我们又能求得天选结点在第<code>n-2</code>个被杀结点被杀之前的编号，……，依次往回推就能还原一个结点都没死时天选结点的编号，这样我们就能从输入的链表中找到该结点，直接将其后继指针指向自己然后返回即可。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">aliveNode</span><span class="params">(Node head, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    Node cur = head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != head) &#123;</span><br><span class="line">        tmp++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第n-1次杀人前还有两个结点，杀完之后天选结点的新编号为1</span></span><br><span class="line">    <span class="comment">//通过递归调用getAlive推出所有结点存活时，天选结点的编号</span></span><br><span class="line">    <span class="keyword">int</span> nodeNumber = getAlive(<span class="number">1</span>, m, <span class="number">2</span>, tmp);</span><br><span class="line"></span><br><span class="line">    cur = head;</span><br><span class="line">    tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != nodeNumber) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = cur;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旧编号 = (新编号 + m - 1) % n + 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newNumber 新编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n         旧编号对应的存活的结点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len       结点总个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAlive</span><span class="params">(<span class="keyword">int</span> newNumber, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == len) &#123;</span><br><span class="line">        <span class="keyword">return</span> (newNumber + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算出新编号对应的旧编号，将该旧编号作为下一次计算的新编号</span></span><br><span class="line">    <span class="keyword">return</span> getAlive((newNumber + m - <span class="number">1</span>) % n + <span class="number">1</span>, m, n + <span class="number">1</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="string">'a'</span>);</span><br><span class="line">    head.next = <span class="keyword">new</span> Node(<span class="string">'b'</span>);</span><br><span class="line">    head.next.next = <span class="keyword">new</span> Node(<span class="string">'c'</span>);</span><br><span class="line">    head.next.next.next = <span class="keyword">new</span> Node(<span class="string">'d'</span>);</span><br><span class="line">    head.next.next.next.next = <span class="keyword">new</span> Node(<span class="string">'e'</span>);</span><br><span class="line">    head.next.next.next.next.next = head;</span><br><span class="line"></span><br><span class="line">    System.out.println(aliveNode(head, <span class="number">3</span>).data);<span class="comment">//d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>左神算法进阶</category>
        <category>经典题目</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法笔记进阶-经典算法</title>
    <url>/2020/03/11/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6-%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><h3 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h3><p>Manacher算法是由题目“求字符串中最长回文子串的长度”而来。比如<code>abcdcb</code>的最长回文子串为<code>bcdcb</code>，其长度为5。</p><p>我们可以遍历字符串中的每个字符，当遍历到某个字符时就比较一下其左边相邻的字符和其右边相邻的字符是否相同，如果相同则继续比较其右边的右边和其左边的左边是否相同，如果相同则继续比较……，我们暂且称这个过程为向外“扩”。当“扩”不动时，经过的所有字符组成的子串就是以当前遍历字符为中心的最长回文子串。</p><a id="more"></a>

<p>我们每次遍历都能得到一个最长回文子串的长度，使用一个全局变量保存最大的那个，遍历完后就能得到此题的解。但分析这种方法的时间复杂度：当来到第一个字符时，只能扩其本身即1个；来到第二个字符时，最多扩两个；……；来到字符串中间那个字符时，最多扩<code>(n-1)/2+1</code>个；因此时间复杂度为<code>1+2+……+(n-1)/2+1</code>即<code>O(N^2)</code>。但Manacher算法却能做到<code>O(N)</code>。</p>
<p>Manacher算法中定义了如下几个概念：</p>
<ul>
<li>回文半径：串中某个字符最多能向外扩的字符个数称为该字符的回文半径。比如<code>abcdcb</code>中字符<code>d</code>，能扩一个<code>c</code>，还能再扩一个<code>b</code>，再扩就到字符串右边界了，再算上字符本身，字符<code>d</code>的回文半径是3。</li>
<li>回文半径数组<code>pArr</code>：长度和字符串长度一样，保存串中每个字符的回文半径。比如<code>charArr=&quot;abcdcb&quot;</code>，其中<code>charArr[0]=&#39;a&#39;</code>一个都扩不了，但算上其本身有<code>pArr[0]=1</code>；而<code>charArr[3]=&#39;d&#39;</code>最多扩2个，算上其本身有<code>pArr[3]=3</code>。</li>
<li>最右回文右边界<code>R</code>：遍历过程中，“扩”这一操作扩到的最右的字符的下标。比如<code>charArr=“abcdcb”</code>，当遍历到<code>a</code>时，只能扩<code>a</code>本身，向外扩不动，所以<code>R=0</code>；当遍历到<code>b</code>时，也只能扩<code>b</code>本身，所以更新<code>R=1</code>；但当遍历到<code>d</code>时，能向外扩两个字符到<code>charArr[5]=b</code>，所以<code>R</code>更新为5。</li>
<li>最右回文右边界对应的回文中心<code>C</code>：<code>C</code>与<code>R</code>是对应的、同时更新的。比如<code>abcdcb</code>遍历到<code>d</code>时，<code>R=5</code>，<code>C</code>就是<code>charArr[3]=&#39;d&#39;</code>的下标<code>3</code>。</li>
</ul>
<p>处理回文子串长度为偶数的问题：上面拿<code>abcdcb</code>来举例，其中<code>bcdcb</code>属于一个回文子串，但如果回文子串长度为偶数呢？像<code>cabbac</code>，按照上面定义的“扩”的逻辑岂不是每个字符的回文半径都是0，但事实上<code>cabbac</code>的最长回文子串的长度是6。因为我们上面“扩”的逻辑默认是将回文子串当做奇数长度的串来看的，因此我们在使用Manacher算法之前还需要将字符串处理一下，这里有一个小技巧，那就是将字符串的首尾和每个字符之间加上一个特殊符号，这样就能将输入的串统一转为奇数长度的串了。比如<code>abba</code>处理过后为<code>#a#b#b#a</code>，这样的话就有<code>charArr[4]=&#39;#&#39;</code>的回文半径为4，也即原串的最大回文子串长度为4。相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] manacherString(String str)&#123;</span><br><span class="line">  <span class="keyword">char</span>[] source = str.toCharArray();</span><br><span class="line">  <span class="keyword">char</span> chs[] = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">    chs[i] = i % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">'#'</span> : source[i / <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来分析，BFPRT算法是如何利用遍历过程中计算的<code>pArr</code>、<code>R</code>、<code>C</code>来为后续字符的回文半径的求解加速的。</p>
<p>首先，情况1是，遍历到的字符下标<code>cur</code>在<code>R</code>的右边（起初另<code>R=-1</code>），这种情况下该字符的最大回文半径<code>pArr[cur]</code>的求解无法加速，只能一步步向外扩来求解。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/manacher.png" alt> </p>
<p>情况2是，遍历到的字符下标<code>cur</code>在<code>R</code>的左边，这时<code>pArr[cur]</code>的求解过程可以利用之前遍历的字符回文半径信息来加速。分别做<code>cur</code>、<code>R</code>关于<code>C</code>的对称点<code>cur&#39;</code>和<code>L</code>：</p>
<ul>
<li>如果从<code>cur&#39;</code>向外扩的最大范围的左边界没有超过<code>L</code>，那么<code>pArr[cur]=pArr[cur&#39;]</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/manacher1.png" alt> </p>
<p>证明如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/manacher2.png" alt> </p>
<p>由于之前遍历过<code>cur&#39;</code>位置上的字符，所以该位置上能扩的步数我们是有记录的（<code>pArr[cur&#39;]</code>），也就是说<code>cur&#39;+pArr[cur&#39;]</code>处的字符<code>y&#39;</code>是不等于<code>cur&#39;-pArr[cur&#39;]</code>处的字符<code>x&#39;</code>的。根据<code>R</code>和<code>C</code>的定义，整个<code>L</code>到<code>R</code>范围的字符是关于<code>C</code>对称的，也就是说<code>cur</code>能扩出的最大回文子串和<code>cur&#39;</code>能扩出的最大回文子串相同，因此可以直接得出<code>pArr[cur]=pArr[cur&#39;]</code>。</p>
<ul>
<li>如果从<code>cur&#39;</code>向外扩的最大范围的左边界超过了<code>L</code>，那么<code>pArr[cur]=R-cur+1</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/manacher3.png" alt> </p>
<p>证明如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/manacher4.png" alt> </p>
<p><code>R</code>右边一个字符<code>x</code>，<code>x</code>关于<code>cur</code>对称的字符<code>y</code>，<code>x,y</code>关于<code>C</code>对称的字符<code>x&#39;,y&#39;</code>。根据<code>C,R</code>的定义有<code>x!=x&#39;</code>；由于<code>x&#39;,y&#39;</code>在以<code>cur&#39;</code>为中心的回文子串内且关于<code>cur&#39;</code>对称，所以有<code>x&#39;=y&#39;</code>，可推出<code>x!=y&#39;</code>；又<code>y,y&#39;</code>关于<code>C</code>对称，且在<code>L,R</code>内，所以有<code>y=y&#39;</code>。综上所述，有<code>x!=y</code>，因此<code>cur</code>的回文半径为<code>R-cur+1</code>。</p>
<ul>
<li>以<code>cur&#39;</code>为中心向外扩的最大范围的左边界正好是<code>L</code>，那么<code>pArr[cur] &gt;= （R-cur+1）</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/manacher5.png" alt> </p>
<p>这种情况下，<code>cur&#39;</code>能扩的范围是<code>cur&#39;-L</code>，因此对应有<code>cur</code>能扩的范围是<code>R-cur</code>。但<code>cur</code>能否扩的更大则取决于<code>x</code>和<code>y</code>是否相等。而我们所能得到的前提条件只有<code>x!=x&#39;</code>、<code>y=y&#39;</code>、<code>x&#39;!=y&#39;</code>，无法推导出<code>x,y</code>的关系，只知道<code>cur</code>的回文半径最小为<code>R-cur+1</code>（算上其本身），需要继续尝试向外扩以求解<code>pArr[cur]</code>。</p>
<p>综上所述，<code>pArr[cur]</code>的计算有四种情况：暴力扩、等于<code>pArr[cur&#39;]</code>、等于<code>R-cur+1</code>、从<code>R-cur+1</code>继续向外扩。使用此算法求解原始问题的过程就是遍历串中的每个字符，每个字符都尝试向外扩到最大并更新<code>R</code>（只增不减），每次<code>R</code>增加的量就是此次能扩的字符个数，而<code>R</code>到达串尾时问题的解就能确定了，因此时间复杂度就是每次扩操作检查的次数总和，也就是<code>R</code>的变化范围（<code>-1~2N</code>，因为处理串时向串中添加了<code>N+1</code>个<code>#</code>字符），即<code>O(1+2N)=O(N)</code>。</p>
<p>整体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPalindromeLength</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> charArr[] = manacherString(str);</span><br><span class="line">  <span class="keyword">int</span> pArr[] = <span class="keyword">new</span> <span class="keyword">int</span>[charArr.length];</span><br><span class="line">  <span class="keyword">int</span> R = -<span class="number">1</span>, C = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArr.length; i++) &#123;</span><br><span class="line">    pArr[i] = i &gt; R ? <span class="number">1</span> : Math.min(pArr[C * <span class="number">2</span> - i], R - i);</span><br><span class="line">    <span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]]) &#123;</span><br><span class="line">        pArr[i]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (R &lt; i + pArr[i]) &#123;</span><br><span class="line">      R = i + pArr[i]-<span class="number">1</span>;</span><br><span class="line">      C = i;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, pArr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(maxPalindromeLength(<span class="string">"zxabcdcbayq"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将四种情况的分支处理浓缩到了<code>7~14</code>行。其中第<code>7</code>行是确定加速信息：如果当前遍历字符在<code>R</code>右边，先算上其本身有<code>pArr[i]=1</code>，后面检查如果能扩再直接<code>pArr[i]++</code>即可；否则，当前字符的<code>pArr[i]</code>要么是<code>pArr[i&#39;]</code>（<code>i</code>关于<code>C</code>对称的下标<code>i&#39;</code>的推导公式为<code>2*C-i</code>），要么是<code>R-i+1</code>，要么是<code>&gt;=R-i+1</code>，可以先将<code>pArr[i]</code>的值置为这三种情况中最小的那一个，后面再检查如果能扩再直接<code>pArr[i]++</code>即可。</p>
<p>最后得到的<code>max</code>是处理之后的串（<code>length=2N+1</code>）的最长回文子串的半径，<code>max-1</code>刚好为原串中最长回文子串的长度。</p>
<h3 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h3><p>给你一个字符串，要求添加尽可能少的字符使其成为一个回文字符串。</p>
<blockquote>
<p>思路：当<code>R</code>第一次到达串尾时，做<code>R</code>关于<code>C</code>的对称点<code>L</code>，将<code>L</code>之前的字符串逆序就是结果。</p>
</blockquote>
<h2 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h2><p>题目：给你一个整型数组，返回其中第K小的数。</p>
<p>这道题可以利用荷兰国旗改进的<code>partition</code>和随机快排的思想：随机选出一个数，将数组以该数作比较划分为<code>&lt;,=,&gt;</code>三个部分，则<code>=</code>部分的数是数组中第几小的数不难得知，接着对<code>&lt;</code>（如果第K小的数在<code>&lt;</code>部分）或<code>&gt;</code>（如果第K小的数在<code>&gt;</code>部分）部分的数递归该过程，直到<code>=</code>部分的数正好是整个数组中第K小的数。这种做法不难求得时间复杂度的数学期望为<code>O(NlogN)</code>（以2为底）。但这毕竟是数学期望，在实际工程中的表现可能会有偏差，而BFPRT算法能够做到时间复杂度就是<code>O(NlogN)</code>。</p>
<p>BFPRT算法首先将数组按5个元素一组划分成<code>N/5</code>个小部分（最后不足5个元素自成一个部分），再这些小部分的内部进行排序，然后将每个小部分的中位数取出来再排序得到中位数：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/bfprt.png" alt> </p>
<p>BFPRT求解此题的步骤和开头所说的步骤大体类似，但是“随机选出一个的作为比较的那个数”这一步替换为上图所示最终选出来的那个数。</p>
<p><code>O(NlogN)</code>的证明，为什么每一轮<code>partition</code>中的随机选数改为BFPRT定义的选数逻辑之后，此题的时间复杂度就彻底变为<code>O(NlogN)</code>了呢？下面分析一下这个算法的步骤：</p>
<p>BFPRT算法，接收一个数组和一个K值，返回数组中的一个数</p>
<ol>
<li>数组被划分为了<code>N/5</code>个小部分，每个部分的5个数排序需要<code>O(1)</code>，所有部分排完需要<code>O(N/5)=O(N)</code></li>
<li>取出每个小部分的中位数，一共有<code>N/5</code>个，递归调用BFPRT算法得到这些数中第<code>(N/5)/2</code>小的数（即这些数的中位数），记为<code>pivot</code></li>
<li>以<code>pivot</code>作为比较，将整个数组划分为<code>pivot</code>三个区域</li>
<li>判断第K小的数在哪个区域，如果在<code>=</code>区域则直接返回<code>pivot</code>，如果在<code>&lt;</code>或<code>&gt;</code>区域，则将这个区域的数递归调用BFPRT算法</li>
<li><code>base case</code>：在某次递归调用BFPRT算法时发现这个区域只有一个数，那么这个数就是我们要找的数。</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinKthNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="keyword">null</span> || K &gt; arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] copyArr = Arrays.copyOf(arr, arr.length);</span><br><span class="line">  <span class="keyword">return</span> bfprt(copyArr, <span class="number">0</span>, arr.length - <span class="number">1</span>, K - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfprt</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[begin];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> pivot = medianOfMedians(arr, begin, end);</span><br><span class="line">  <span class="keyword">int</span>[] pivotRange = partition(arr, begin, end, pivot);</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= pivotRange[<span class="number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[i];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; pivotRange[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> bfprt(arr, begin, pivotRange[<span class="number">0</span>] - <span class="number">1</span>, i);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bfprt(arr, pivotRange[<span class="number">1</span>] + <span class="number">1</span>, end, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">medianOfMedians</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> offset = num % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>[] medians = <span class="keyword">new</span> <span class="keyword">int</span>[num / <span class="number">5</span> + offset];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; medians.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> beginI = begin + i * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> endI = beginI + <span class="number">4</span>;</span><br><span class="line">    medians[i] = getMedian(arr, beginI, Math.min(endI, end));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bfprt(medians, <span class="number">0</span>, medians.length - <span class="number">1</span>, medians.length / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMedian</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  insertionSort(arr, begin, end);</span><br><span class="line">  <span class="keyword">int</span> sum = end + begin;</span><br><span class="line">  <span class="keyword">int</span> mid = (sum / <span class="number">2</span>) + (sum % <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = begin + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; begin; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> pivot) &#123;</span><br><span class="line">  <span class="keyword">int</span> L = begin - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> R = end + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> cur = begin;</span><br><span class="line">  <span class="keyword">while</span> (cur != R) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[cur] &gt; pivot) &#123;</span><br><span class="line">      swap(arr, cur, --R);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &lt; pivot) &#123;</span><br><span class="line">      swap(arr, cur++, ++L);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;L + <span class="number">1</span>, R - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  System.out.println(getMinKthNum(arr,<span class="number">13</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为<code>O(NlogN)</code>（底数为2）的证明，分析<code>bfprt</code>的执行步骤（假设<code>bfprt</code>的时间复杂度为<code>T(N)</code>）：</p>
<ol>
<li>首先数组5个5个一小组并内部排序，对5个数排序为<code>O(1)</code>，所有小组排好序为<code>O(N/5)=O(N)</code></li>
<li>由步骤1的每个小组抽出中位数组成一个中位数小组，共有<code>N/5</code>个数，递归调用<code>bfprt</code>求出这<code>N/5</code>个数中第<code>(N/5)/2</code>小的数（即中位数）为<code>T(N/5)</code>，记为<code>pivot</code></li>
<li>对步骤2求出的<code>pivot</code>作为比较将数组分为小于、等于、大于三个区域，由于<code>pivot</code>是中位数小组中的中位数，所以中位数小组中有<code>N/5/2=N/10</code>个数比<code>pivot</code>小，这<code>N/10</code>个数分别又是步骤1中某小组的中位数，可推导出至少有<code>3N/10</code>个数比<code>pivot</code>小，也即最多有<code>7N/10</code>个数比<code>pivot</code>大。也就是说，大于区域（或小于）最大包含<code>7N/10</code>个数、最少包含<code>3N/10</code>个数，那么如果第<code>i</code>大的数不在等于区域时，无论是递归<code>bfprt</code>处理小于区域还是大于区域，最坏情况下子过程的规模最大为<code>7N/10</code>，即<code>T(7N/10)</code></li>
</ol>
<p>综上所述，<code>bfprt</code>的<code>T(N)</code>存在推导公式：<code>T(N/5)+T(7N/10)+O(N)</code>。根据 <strong>基础篇</strong> 中所介绍的Master公式可以求得<code>bfprt</code>的时间复杂度就是<code>O(NlogN)</code>（以2为底）。</p>
<h2 id="morris遍历二叉树"><a href="#morris遍历二叉树" class="headerlink" title="morris遍历二叉树"></a>morris遍历二叉树</h2><blockquote>
<p>关于二叉树先序、中序、后序遍历的递归和非递归版本在【直通BAT算法（基础篇）】中有讲到，但这6种遍历算法的时间复杂度都需要<code>O(H)</code>（其中<code>H</code>为树高）的额外空间复杂度，因为二叉树遍历过程中只能向下查找孩子节点而无法回溯父结点，因此这些算法借助栈来保存要回溯的父节点（递归的实质是系统帮我们压栈），并且栈要保证至少能容纳下<code>H</code>个元素（比如遍历到叶子结点时回溯父节点，要保证其所有父节点在栈中）。而morris遍历则能做到时间复杂度仍为<code>O(N)</code>的情况下额外空间复杂度只需<code>O(1)</code>。</p>
</blockquote>
<h3 id="遍历规则"><a href="#遍历规则" class="headerlink" title="遍历规则"></a>遍历规则</h3><p>首先在介绍morris遍历之前，我们先把先序、中序、后序定义的规则抛之脑后，比如先序遍历在拿到一棵树之后先遍历头结点然后是左子树最后是右子树，并且在遍历过程中对于子树的遍历仍是这样。</p>
<p>忘掉这些遍历规则之后，我们来看一下morris遍历定义的标准：</p>
<ol>
<li>定义一个遍历指针<code>cur</code>，该指针首先指向头结点</li>
<li>判断<code>cur</code>的左子树是否存在<ul>
<li>如果<code>cur</code>的左孩子为空，说明<code>cur</code>的左子树不存在，那么<code>cur</code>右移来到<code>cur.right</code></li>
<li>如果<code>cur</code>的左孩子不为空，说明<code>cur</code>的左子树存在，找出该左子树的最右结点，记为<code>mostRight</code><ul>
<li>如果，<code>mostRight</code>的右孩子为空，那就让其指向<code>cur</code>（<code>mostRight.right=cur</code>），并左移<code>cur</code>（<code>cur=cur.left</code>）</li>
<li>如果<code>mostRight</code>的右孩子不空，那么让<code>cur</code>右移（<code>cur=cur.right</code>），并将<code>mostRight</code>的右孩子置空</li>
</ul>
</li>
</ul>
</li>
<li>经过步骤2之后，如果<code>cur</code>不为空，那么继续对<code>cur</code>进行步骤2，否则遍历结束。</li>
</ol>
<p>下图所示举例演示morris遍历的整个过程：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/morris.png" alt> </p>
<h3 id="先序、中序序列"><a href="#先序、中序序列" class="headerlink" title="先序、中序序列"></a>先序、中序序列</h3><p>遍历完成后对<code>cur</code>进过的节点序列稍作处理就很容易得到该二叉树的先序、中序序列：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/morris1.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderByMorris</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.data+<span class="string">" "</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node mostRight = cur.left;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(cur.data+<span class="string">" "</span>);</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mediumOrderByMorris</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.data+<span class="string">" "</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node mostRight = cur.left;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(cur.data+<span class="string">" "</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">    root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    root.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    root.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">    root.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">    preOrderByMorris(root);</span><br><span class="line">    mediumOrderByMorris(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里值得注意的是：<strong>morris遍历会来到一个左孩子不为空的结点两次</strong>，而其它结点只会经过一次。因此使用morris遍历打印先序序列时，如果来到的结点无左孩子，那么直接打印即可（这种结点只会经过一次），否则如果来到的结点的左子树的最右结点的右孩子为空才打印（这是第一次来到该结点的时机），这样也就忽略了<code>cur</code>经过的结点序列中第二次出现的结点；而使用morris遍历打印中序序列时，如果来到的结点无左孩子，那么直接打印（这种结点只会经过一次，左中右，没了左，直接打印中），否则如果来到的结点的左子树的最右结点不为空时才打印（这是第二次来到该结点的时机），这样也就忽略了<code>cur</code>经过的结点序列中第一次出现的重复结点。 </p>
<h3 id="后序序列"><a href="#后序序列" class="headerlink" title="后序序列"></a>后序序列</h3><p>使用morris遍历得到二叉树的后序序列就没那么容易了，因为对于树种的非叶结点，morris遍历最多会经过它两次，而我们后序遍历实在第三次来到该结点时打印该结点的。因此要想得到后序序列，仅仅改变在morris遍历时打印结点的时机是无法做到的。</p>
<p>但其实，在morris遍历过程中，如果在每次遇到第二次经过的结点时，将该结点的左子树的右边界上的结点从下到上打印，最后再将整个树的右边界从下到上打印，最终就是这个数的后序序列：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/morris2.png" alt> </p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/morris3.png" alt> </p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/morris4.png" alt> </p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/morris5.png" alt> </p>
<p>其中无非就是在morris遍历中在第二次经过的结点的时机执行一下打印操作。而从下到上打印一棵树的右边界，可以将该右边界上的结点看做以<code>right</code>指针为后继指针的链表，将其反转<code>reverse</code>然后打印，最后恢复成原始结构即可。示例代码如下（其中容易犯错的地方是<code>18</code>行和<code>19</code>行的代码不能调换）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderByMorris</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node mostRight = cur.left;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                printRightEdge(cur.left);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printRightEdge(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRightEdge</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reverse the right edge</span></span><br><span class="line">    Node cur = root;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = cur.right;</span><br><span class="line">        cur.right = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print </span></span><br><span class="line">    cur = pre;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(cur.data + <span class="string">" "</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//recover</span></span><br><span class="line">    cur = pre;</span><br><span class="line">    pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = cur.right;</span><br><span class="line">        cur.right = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">    root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    root.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    root.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">    root.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">    posOrderByMorris(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>因为morris遍历中，只有左孩子非空的结点才会经过两次而其它结点只会经过一次，也就是说遍历的次数小于<code>2N</code>，因此使用morris遍历得到先序、中序序列的时间复杂度自然也是<code>O(1)</code>；但产生后序序列的时间复杂度还要算上<code>printRightEdge</code>的时间复杂度，但是你会发现整个遍历的过程中，所有的<code>printRightEdge</code>加起来也只是遍历并打印了<code>N</code>个结点：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/morris6.png" alt> </p>
<p>因此时间复杂度仍然为<code>O(N)</code>。</p>
<blockquote>
<p>morris遍历结点的顺序不是先序、中序、后序，而是按照自己的一套标准来决定接下来要遍历哪个结点。</p>
<p>morris遍历的独特之处就是充分利用了叶子结点的无效引用（引用指向的是空，但该引用变量仍然占内存），从而实现了<code>O(1)</code>的时间复杂度。</p>
</blockquote>
]]></content>
      <categories>
        <category>左神算法进阶</category>
        <category>经典算法</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法班笔记-哈希</title>
    <url>/2020/03/10/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%8F%AD%E7%AC%94%E8%AE%B0-%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/hash.png" alt> </p><blockquote>
<p> 百科：<strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的<strong>数字</strong>“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将输入域中的数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。</p>
</blockquote><a id="more"></a>

<h3 id="哈希函数的性质"><a href="#哈希函数的性质" class="headerlink" title="哈希函数的性质"></a>哈希函数的性质</h3><p>哈希函数的输入域可以是非常大的范围，比如，任意一个字符串，但是输出域是固定的范围（一定位数的bit），假设为S，并具有如下性质：</p>
<ol>
<li>典型的哈希函数都有无限的输入值域。</li>
<li>当给哈希函数传入相同的输入值时，返回值一样。</li>
<li>当给哈希函数传入不同的输入值时，返回值可能一样，也可能不一样，这时当然的，因为输出域统一是S，所以会有不同的输入值对应在S中的一个元素上（这种情况称为 <strong>哈希冲突</strong>）。</li>
<li>最重要的性质是很多不同的输入值所得到的返回值会均匀分布在S上。</li>
</ol>
<p>前3点性质是哈希函数的基础，第4点是评价一个哈希函数优劣的关键，不同输入值所得到的所有返回值越均匀地分布在S上，哈希函数越优秀，并且这种均匀分布与输入值出现的规律无关。比如，“aaa1”、“aaa2”、“aaa3”三个输入值比较类似，但经过优秀的哈希函数计算后得到的结果应该相差非常大。</p>
<h3 id="哈希函数的经典实现"><a href="#哈希函数的经典实现" class="headerlink" title="哈希函数的经典实现"></a>哈希函数的经典实现</h3><blockquote>
<p>参考文献：<a href="http://www.alloyteam.com/2017/05/hash-functions-introduction/" target="_blank" rel="noopener">哈希函数的介绍</a></p>
</blockquote>
<p>比如使用MD5对“test”和“test1”两个字符串哈希的结果如下（哈希结果为128个bit，数据范围为<code>0~(2^128)-1</code>，通常转换为32个16进制数显示）：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test	</span>098f6bcd4621d373cade4e832627b4f6</span><br><span class="line">test1 5a105e8b9d40e1329780d62ea2265d8a</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><blockquote>
<p>百科：<strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<a href="https://zh.wikipedia.org/wiki/鍵" target="_blank" rel="noopener">键</a>（Key）而直接访问在内存存储位置的<a href="https://zh.wikipedia.org/wiki/数据结构" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射</a>到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<a href="https://zh.wikipedia.org/wiki/散列函数" target="_blank" rel="noopener">散列函数</a>，存放记录的数组称做<strong>散列表</strong>。</p>
</blockquote>
<h3 id="哈希表的经典实现"><a href="#哈希表的经典实现" class="headerlink" title="哈希表的经典实现"></a>哈希表的经典实现</h3><p>哈希表初始会有一个大小，比如16，表中每个元素都可以通过数组下标（0<del>15）访问。每个元素可以看做一个桶，当要往表里放数据时，将要存放的数据的键值通过哈希函数计算出的哈希值模上16，结果正好对应0</del>15，将这条数据放入对应下标的桶中。</p>
<p>那么当数据量超过16时，势必会存在哈希冲突（两条数据经哈希计算后放入同一个桶中），这时的解决方案就是将后一条入桶的数据作为后继结点链入到桶中已有的数据之后，如此，每个桶中存放的就是一个链表。那么这就是哈希表的经典结构：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/hash1.png" alt> </p>
<p>当数据量较少时，哈希表的增删改查操作的时间复杂度都是<code>O(N)</code>的。因为根据一个键值就能定位一个桶，即使存在哈希冲突（桶里不只一条数据），但只要哈希函数优秀，数据量几乎均分在每个桶上（这样很少有哈希冲突，即使有，一个桶里也只会有很少的几条数据），那就在遍历一下桶里的链表比较键值进一步定位数据即可（反正链表很短）。</p>
<h3 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h3><p>如果哈希表大小为16，对于样本规模N（要存储的数据数量）来说，如果N较小，那么根据哈希函数的散列特性，每个桶会均分这N条数据，这样落到每个桶的数据量也较小，不会影响哈希表的存取效率（这是由桶的链表长度决定的，因为存数据要往链表尾追加首先就要遍历得到尾结点，取数据要遍历链表比较键值）；但如果N较大，那么每个桶里都有<code>N/16</code>条数据，存取效率就变成<code>O(N)</code>了。因此哈希表哈需要一个扩容机制，当表中某个桶的数据量超过一个阀值时（<code>O(1)</code>到<code>O(N)</code>的转变，这需要一个算法来权衡），需要将哈希表扩容（一般是成倍的）。</p>
<p>扩容步骤是，创建一个新的较大的哈希表（假如大小为m），将原哈希表中的数据取出，将键值的哈希值模上m，放入新表对应的桶中，这个过程也叫<code>rehash</code>。</p>
<p>如此的话，那么原来的<code>O(N)</code>就变成了<code>O(log(m/16,N))</code>，比如扩容成5倍那就是<code>O(log(5,N))</code>（以5为底，N的对数）。当这个底数较大的时候就会将N的对数压得非常低而和<code>O(1)</code>非常接近了，并且实际工程中基本是当成<code>O(1)</code>来用的。</p>
<p>你也许会说<code>rehash</code>很费时，会导致哈希表性能降低，这一点是可以侧面避免的。比如扩容时将倍数提高一些，那么<code>rehash</code>的次数就会很少，平衡到整个哈希表的使用来看，影响就甚微了。或者可以进行<strong>离线扩容</strong>，当需要扩容时，原哈希表还是供用户使用，在另外的内存中执行<code>rehash</code>，完成之后再将新表替换原表，这样的话对于用户来说，他是感觉不到<code>rehash</code>带来的麻烦的。</p>
<h3 id="哈希表的JVM实现"><a href="#哈希表的JVM实现" class="headerlink" title="哈希表的JVM实现"></a>哈希表的JVM实现</h3><p>在<code>Java</code>中，哈希表的实现是每个桶中放的是一棵<strong>红黑树</strong>而非链表，因为红黑树的查找效率很高，也是对哈希冲突带来的性能问题的一个优化。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64B。现在想要实现一种网页过滤系统，可以根据网页的URL判断该网页是否在黑名单上，请设计该系统。</p>
<p>要求如下：</p>
<ol>
<li>该系统允许有万分之一以下的判断失误率。</li>
<li>使用的额外空间不要超过30GB。</li>
</ol>
<p>如果将这100亿个URL通过数据库或哈希表保存起来，就可以对每条URL进行查询，但是每个URL有64B，数量是100亿个，所以至少需要640GB的空间，不满足要求2。</p>
<blockquote>
<p>如果面试者遇到网页黑名单系统、垃圾邮件过滤系统，爬虫的网页判重系统等题目，又看到系统容忍一定程度的失误率，但是对空间要求比较严格，那么很可能是面试官希望面试者具备布隆过滤器的知识。一个布隆过滤器精确地代表一个集合，并可以精确判断一个元素是否在集合中。注意，只是精确代表和精确判断，到底有多精确呢？则完全在于你具体的设计，但想做到完全正确是不可能的。布隆过滤器的优势就在于使用很少的空间就可以将准确率做到很高的程度。该结构由<code>Burton Howard Bloom</code>于1970年提出。</p>
</blockquote>
<p>那么什么是布隆过滤器呢？</p>
<p>假设有一个长度为<code>m</code>的bit类型的数组，即数组的每个位置只占一个bit，如果我们所知，每一个bit只有0和1两种状态，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/bloom.png" alt> </p>
<p>再假设一共有<code>k</code>个哈希函数，这些函数的输出域S都大于或等于m，并且这些哈希函数都足够优秀且彼此之间相互独立（将一个哈希函数的计算结果乘以6除以7得出的新哈希函数和原函数就是相互独立的）。那么对同一个输入对象（假设是一个字符串，记为URL），经过k个哈希函数算出来的结果也是独立的。可能相同，也可能不同，但彼此独立。对算出来的每一个结果都对m取余（%m），然后在bit array 上把相应位置设置为1（我们形象的称为涂黑）。如图所示</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/url_search.png" alt> </p>
<p>我们把bit类型的数组记为<code>bitMap</code>。至此，一个输入对象对<code>bitMap</code>的影响过程就结束了，也就是<code>bitMap</code>的一些位置会被涂黑。接下来按照该方法，处理所有的输入对象（黑名单中的100亿个URL）。每个对象都可能把<code>bitMap</code>中的一些白位置涂黑，也可能遇到已经涂黑的位置，遇到已经涂黑的位置让其继续为黑即可。处理完所有的输入对象后，可能<code>bitMap</code>中已经有相当多的位置被涂黑。至此，一个布隆过滤器生成完毕，这个布隆过滤器代表之前所有输入对象组成的集合。</p>
<p>那么在检查阶段时，如何检查一个对象是否是之前的某一个输入对象呢（判断一个URL是否是黑名单中的URL）？假设一个对象为a，想检查它是否是之前的输入对象，就把a通过k个哈希函数算出k个值，然后把k个值都取余（%m），就得到在[0,m-1]范围伤的k个值。接下来在<code>bitMap</code>上看这些位置是不是都为黑。如果有一个不为黑，说明a一定不再这个集合里。如果都为黑，说明a在这个集合里，但可能误判。</p>
<p>再解释具体一点，如果a的确是输入对象 ，那么在生成布隆过滤器时，<code>bitMap</code>中相应的k个位置一定已经涂黑了，所以在检查阶段，a一定不会被漏过，这个不会产生误判。会产生误判的是，a明明不是输入对象，但如果在生成布隆过滤器的阶段因为输入对象过多，而<code>bitMap</code>过小，则会导致<code>bitMap</code>绝大多数的位置都已经变黑。那么在检查a时，可能a对应的k个位置都是黑的，从而错误地认为a是输入对象（即是黑名单中的URL）。通俗地说，布隆过滤器的失误类型是“宁可错杀三千，绝不放过一个”。</p>
<p>布隆过滤器到底该怎么生成呢？只需记住下列三个公式即可：</p>
<ul>
<li>对于输入的数据量n（这里是100亿）和失误率p（这里是万分之一），布隆过滤器的大小m：<code>m = - (n*lnp)/(ln2*ln2)</code>，计算结果向上取整（这道题m=19.19n，向上取整为20n，即需要2000亿个bit，也就是25GB）</li>
<li>需要的哈希函数的个数k：<code>k = ln2 * m/n = 0.7 * m/n</code>（这道题<code>k = 0.7 * 20n/n = 14</code>）</li>
<li>由于前两步都进行了向上取整，那么由前两步确定的布隆过滤器的真正失误率p：<code>p = (1 - e^(-nk/m))^k</code></li>
</ul>
<h2 id="一致性哈希算法的基本原理"><a href="#一致性哈希算法的基本原理" class="headerlink" title="一致性哈希算法的基本原理"></a>一致性哈希算法的基本原理</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>工程师常使用服务器集群来设计和实现数据缓存，以下是常见的策略：</p>
<ol>
<li>无论是添加、查询还是珊瑚数据，都先将数据的id通过哈希函数换成一个哈希值，记为key</li>
<li>如果目前机器有N台，则计算<code>key%N</code>的值，这个值就是该数据所属的机器编号，无论是添加、删除还是查询操作，都只在这台机器上进行。</li>
</ol>
<p>请分析这种缓存策略可能带来的问题，并提出改进的方案。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>题目中描述的缓存从策略的潜在问题是，如果增加或删除机器时（N变化）代价会很高，所有的数据都不得不根据id重新计算一遍哈希值，并将哈希值对新的机器数进行取模啊哦做。然后进行大规模的数据迁移。</p>
<p>为了解决这些问题，下面介绍一下一致性哈希算法，这时一种很好的数据缓存设计方案。我们假设数据的id通过哈希函数转换成的哈希值范围是2^32，也就是0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形，那么一个数据id在计算出哈希值之后认为对应到环中的一个位置上，如图所示</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/consistent_hash.png" alt> </p>
<p>接下来想象有三台机器也处在这样一个环中，这三台机器在环中的位置根据机器id（主机名或者主机IP，是主机唯一的就行）设计算出的哈希值对2^32取模对应到环上。那么一条数据如何确定归属哪台机器呢？我们可以在该数据对应环上的位置顺时针寻找离该位置最近的机器，将数据归属于该机器上：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/consistent_hash1.png" alt> </p>
<p>这样的话，如果删除<code>machine2</code>节点，则只需将<code>machine2</code>上的数据迁移到<code>machine3</code>上即可，而不必大动干戈迁移所有数据。当添加节点的时候，也只需将新增节点到逆时针方向新增节点前一个节点这之间的数据迁移给新增节点即可。</p>
<p>但这时还是存在如下两个问题：</p>
<ul>
<li>机器较少时，通过机器id哈希将机器对应到环上之后，几个机器可能没有均分环</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/consistent_hash2.png" alt> </p>
<p>那么这样会导致负载不均。</p>
<ul>
<li>增加机器时，可能会打破现有的平衡：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/consistent_hash3.png" alt> </p>
<p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。具体做法：比如对于<code>machine1</code>的IP<code>192.168.25.132</code>（或机器名），计算出<code>192.168.25.132-1</code>、<code>192.168.25.132-2</code>、<code>192.168.25.132-3</code>、<code>192.168.25.132-4</code>的哈希值，然后对应到环上，其他的机器也是如此，这样的话节点数就变多了，根据哈希函数的性质，平衡性自然会变好：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/consistent_hash5.png" alt> </p>
<p>此时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，比如上图的查找表。当某一条数据计算出归属于<code>m2-1</code>时再根据查找表的跳转，数据将最终归属于实际的m1节点。</p>
<blockquote>
<p>基于一致性哈希的原理有很多种具体的实现，包括Chord算法、KAD算法等，有兴趣的话可以进一步学习。</p>
</blockquote>
<h2 id="RandomPool"><a href="#RandomPool" class="headerlink" title="RandomPool"></a>RandomPool</h2><p>设计一种结构，在该结构中有如下三个功能：</p>
<ul>
<li>inserrt(key)：将某个key加入到该结构中，做到不重复加入。</li>
<li>delete(key)：将原本在结构中的某个key移除。</li>
<li>getRandom()：等概率随机返回结构中的任何一个key。</li>
</ul>
<p>要求：insert、delete和getRandom方法的时间复杂度都是<code>O(1)</code></p>
<blockquote>
<p>思路：使用两个哈希表和一个变量<code>size</code>，一个表存放某<code>key</code>的标号，另一个表根据根据标号取某个<code>key</code>。<code>size</code>用来记录结构中的数据量。加入<code>key</code>时，将<code>size</code>作为该<code>key</code>的标号加入到两表中；删除<code>key</code>时，将标号最大的<code>key</code>替换它并将<code>size--</code>；随机取<code>key</code>时，将<code>size</code>范围内的随机数作为标号取<code>key</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Object, Integer&gt; keySignMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Object&gt; signKeyMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.keySignMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.signKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不重复添加</span></span><br><span class="line">        <span class="keyword">if</span> (keySignMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keySignMap.put(key, size);</span><br><span class="line">        signKeyMap.put(size, key);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keySignMap.containsKey(key)) &#123;</span><br><span class="line">            Object lastKey = signKeyMap.get(--size);</span><br><span class="line">            <span class="keyword">int</span> deleteSign = keySignMap.get(key);</span><br><span class="line">            keySignMap.put(lastKey, deleteSign);</span><br><span class="line">            signKeyMap.put(deleteSign, lastKey);</span><br><span class="line">            keySignMap.remove(key);</span><br><span class="line">            signKeyMap.remove(lastKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> signKeyMap.get((<span class="keyword">int</span>) (Math.random() * size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>有时我们对编写的算法进行测试时，会采用自己编造几个简单数据进行测试。然而别人测试时可能会将大数量级的数据输入进而测试算法的准确性和健壮性，如果这时出错，面对庞大的数据量我们将无从查起（是在操作哪一个数据时出了错，算法没有如期起作用）。当然我们不可能对这样一个大数据进行断点调试，去一步一步的分析错误点在哪。这时 <strong>对数器</strong> 就粉墨登场了，<strong>对数器</strong> 就是通过随机制造出几乎所有可能的简短样本作为算法的输入样本对算法进行测试，这样大量不同的样本从大概率上保证了算法的准确性，当有样本测试未通过时又能打印该简短样本对错误原因进行分析。</p>
<h3 id="对数器的使用"><a href="#对数器的使用" class="headerlink" title="对数器的使用"></a>对数器的使用</h3><ol>
<li>对于你想测试的算法</li>
<li>实现功能与该算法相同但绝对正确、复杂度不好的算法</li>
<li>准备大量随机的简短样本的</li>
<li>实现比对的方法：对于每一个样本，比对该算法和第二步中算法的执行结果以判断该算法的正确性</li>
<li>如果有一个样本比对出错则打印该样本</li>
<li>当样本数量很多时比对测试依然正确，可以确定算法a已经正确</li>
</ol>
<p>对数器使用案例——对自写的插入排序进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.有一个自写的算法，但不知其健壮性（是否会有特殊情况使程序异常中断甚至崩溃）和正确性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==NULL || length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> || arr[j] &lt;= arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、实现一个功能相同、绝对正确但复杂度不好的算法（这里摘取大家熟知的冒泡排序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、实现一个能够产生随机简短样本的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateSample</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        arr[i] = rand() % <span class="number">100</span>-rand()%<span class="number">100</span>;<span class="comment">//控制元素在-100~100之间，考虑到零正负三种情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、实现一个比对测试算法和正确算法运算结果的方法</span></span><br><span class="line"><span class="function">bool <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span> arr1[],<span class="keyword">int</span> arr2[],<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1 != NULL &amp;&amp; arr2 != NULL) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travels</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        printf(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> source[], <span class="keyword">int</span> target[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        target[i] = source[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    <span class="keyword">int</span> testTimes=<span class="number">10000</span>;       </span><br><span class="line">    <span class="comment">//循环产生100000个样本进行测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = rand() % <span class="number">10</span>;   <span class="comment">//控制每个样本的长度在10以内，便于出错时分析样本（因为简短）</span></span><br><span class="line">        <span class="keyword">int</span> arr[length];</span><br><span class="line">        generateSample(arr, length);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//不要改变原始样本，在复制样本上改动</span></span><br><span class="line">        <span class="keyword">int</span> arr1[length], arr2[length];</span><br><span class="line">        copy(arr, arr1, length);</span><br><span class="line">        copy(arr, arr2, length);</span><br><span class="line">        bubbleSort(arr1,length);</span><br><span class="line">        insertionSort(arr2, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        travels(arr, length);</span></span><br><span class="line"><span class="comment">//        travels(arr1, length);</span></span><br><span class="line"></span><br><span class="line">      	<span class="comment">//5、比对两个算法，只要有一个样本没通过就终止，并打印原始样本</span></span><br><span class="line">        <span class="keyword">if</span> (!isEqual(arr1, arr2, length)) &#123;</span><br><span class="line">            printf(<span class="string">"test fail!the sample is: "</span>);</span><br><span class="line">            travels(arr, length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  	<span class="comment">//6、测试全部通过，该算法大概率上正确</span></span><br><span class="line">    printf(<span class="string">"nice!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h2><p>有时我们不确定二叉树中是否有指针连空了或者连错了，这时需要将二叉树具有层次感地打印出来，下面就提供了这样一个工具。你可以将你的头逆时针旋转90度看打印结果。<code>v</code>表示该结点的头结点是左下方距离该结点最近的一个结点，<code>^</code>表示该结点的头结点是左上方距离该结点最近的一个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.algorithmdemo.recursive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">		<span class="keyword">public</span> Node left;</span><br><span class="line">		<span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Binary Tree:"</span>);</span><br><span class="line">		printInOrder(head, <span class="number">0</span>, <span class="string">"H"</span>, <span class="number">17</span>);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		printInOrder(head.right, height + <span class="number">1</span>, <span class="string">"v"</span>, len);</span><br><span class="line">		String val = to + head.value + to;</span><br><span class="line">		<span class="keyword">int</span> lenM = val.length();</span><br><span class="line">		<span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">		val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">		System.out.println(getSpace(height * len) + val);</span><br><span class="line">		printInOrder(head.left, height + <span class="number">1</span>, <span class="string">"^"</span>, len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		String space = <span class="string">" "</span>;</span><br><span class="line">		StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">			buf.append(space);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> buf.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.left = <span class="keyword">new</span> Node(-<span class="number">222222222</span>);</span><br><span class="line">		head.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">		head.left.left = <span class="keyword">new</span> Node(Integer.MIN_VALUE);</span><br><span class="line">		head.right.left = <span class="keyword">new</span> Node(<span class="number">55555555</span>);</span><br><span class="line">		head.right.right = <span class="keyword">new</span> Node(<span class="number">66</span>);</span><br><span class="line">		head.left.left.right = <span class="keyword">new</span> Node(<span class="number">777</span>);</span><br><span class="line">		printTree(head);</span><br><span class="line"></span><br><span class="line">		head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">		head.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">		head.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">		head.right.left = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">		head.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">		head.left.left.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">		printTree(head);</span><br><span class="line"></span><br><span class="line">		head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.left = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.right = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.left.left = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.right.left = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.right.right = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		head.left.left.right = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">		printTree(head);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>左神算法</category>
        <category>哈希</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法班笔记-递归和动态规划</title>
    <url>/2020/03/10/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%8F%AD%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="递归和动态规划"><a href="#递归和动态规划" class="headerlink" title="递归和动态规划"></a>递归和动态规划</h1><h2 id="递归的实质和Master公式"><a href="#递归的实质和Master公式" class="headerlink" title="递归的实质和Master公式"></a>递归的实质和Master公式</h2><h3 id="递归的实质"><a href="#递归的实质" class="headerlink" title="递归的实质"></a>递归的实质</h3><p>递归的实质就是系统在帮我们压栈。首先让我们来看一个递归求阶乘的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> n*fun(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课上老师一般告诉我们递归就是函数自己调用自己。但这听起来很玄学。事实上，在函数执行过程中如果调用了其他函数，那么当前函数的执行状态（执行到了第几行，有几个变量，各个变量的值是什么等等）会被保存起来压进栈（先进后出的存储结构，一般称为函数调用栈）中，转而执行子过程（调用的其他函数，当然也可以是当前函数）。若子过程中又调用了函数，那么调用前子过程的执行状态也会被保存起来压进栈中，转而执行子过程的子过程……以此类推，直到有一个子过程没有调用函数、能顺序执行完毕时会从函数调用栈依次弹出栈顶被保存起来的未执行完的函数（恢复现场）继续执行，直到函数调用栈中的函数都执行完毕，整个递归过程结束。</p><a id="more"></a>



<p>例如，在<code>main</code>中执行<code>fun(3)</code>，其递归过程如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/factorial.png" alt> </p>
<p>很多时候我们分析递归时都喜欢在心中模拟代码执行，去追溯、还原整个递归调用过程。但事实上没有必要这样做，因为每相邻的两个步骤执行的逻辑都是相同的，因此我们只需要分析第一步到第二步是如何执行的以及递归的终点在哪里就可以了。</p>
<blockquote>
<p>一切的递归算法都可以转化为非递归，因为我们完全可以自己压栈。只是说递归的写法更加简洁。在实际工程中，递归的使用是极少的，因为递归创建子函数的开销很大并且存在安全问题（stack overflow）。</p>
</blockquote>
<h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><p>包含递归的算法的时间复杂度有时很难通过算法表面分析出来， 比如 <strong>归并排序</strong>。这时Master公式就粉墨登场了，当某递归算法的时间复杂度符合<code>T(n)=aT(n/b)+O(n^d)</code>形式时可以直接求出该算法的直接复杂度：</p>
<ul>
<li>当（以b为底a的对数）<code>log(b,a) &gt; d</code>时，时间复杂度为<code>O(n^log(b,a))</code></li>
<li>当<code>log(b,a) = d</code>时，时间复杂度为<code>O(n^d * logn)</code></li>
<li>当<code>log(b,a) &lt; d</code>时，时间复杂度为<code>O(n^d)</code></li>
</ul>
<blockquote>
<p>其中，<code>n</code>为样本规模，<code>n/b</code>为子过程的样本规模（暗含子过程的样本规模必须相同，且相加之和等于总样本规模），<code>a</code>为子过程的执行次数，<code>O(n^d)</code>为除子过程之后的操作的时间复杂度。</p>
<p>以归并排序为例，函数本体先对左右两半部分进行归并排序，样本规模被分为了左右各<code>n/2</code>即<code>b=2</code>，左右各归并排序了一次，子过程执行次数为<code>2</code>即<code>a=2</code>，并入操作的时间复杂度为<code>O(n+n)=O(n)</code>即<code>d=1</code>，因此<code>T(n)=2T(n/2)+O(n)</code>，符合<code>log(b,a)=d=1</code>，因此<strong>归并排序的时间复杂度</strong>为<code>O(n^1*logn)=O(nlogn)</code></p>
</blockquote>
<p><strong>暴力递归</strong>：</p>
<ol>
<li>把问题转化为规模缩小了的同类问题的子问题</li>
<li>有明确的不需要继续进行递归的条件(base case)</li>
<li>有当得到了子问题的结果之后的决策过程</li>
<li>不记录每一个子问题的解</li>
</ol>
<p><strong>动态规划</strong>：</p>
<ol>
<li>从暴力递归中来</li>
<li>将每一个子问题的解记录下来，<strong>避免重复计算</strong></li>
<li>把暴力递归的过程，抽象成了状态表达</li>
<li>并且存在化简状态表达，使其更加简洁的可能</li>
</ol>
<p><strong>P和NP</strong></p>
<p>P指的是我明确地知道怎么算，计算的流程很清楚；而NP问题指的是我不知道怎么算，但我知道怎么尝试（暴力递归）。</p>
<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><h3 id="n-问题"><a href="#n-问题" class="headerlink" title="n!问题"></a>n!问题</h3><p>我们知道<code>n!</code>的定义，可以根据定义直接求解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFactorial_1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; n++)&#123;</span><br><span class="line">    res*=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我们可以这样想，如果知道<code>(n-1)!</code>，那通过<code>(n-1)! * n</code>不就得出<code>n!</code>了吗？于是我们就有了如下的尝试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFactorial_2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> getFactorial_2(n-<span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n!<code>的状态依赖</code>(n-1)!<code>，</code>(n-1)!<code>依赖</code>(n-2)!<code>，就这样依赖下去，直到</code>n=1<code>这个突破口，然后回溯，你会发现整个过程就回到了</code>1 * 2 * 3 * …… * (n-1) * n`的计算过程。</p>
<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><p>该问题最基础的一个模型就是，一个竹竿上放了2个圆盘，需要先将最上面的那个移到辅助竹竿上，然后将最底下的圆盘移到目标竹竿，最后把辅助竹竿上的圆盘移回目标竹竿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String source,String target,String auxiliary,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"move 1 disk from "</span> + source + <span class="string">" to "</span> + target);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//尝试把前n-1个圆盘暂时放到辅助竹竿-&gt;子问题</span></span><br><span class="line">        process(source, auxiliary, target, n - <span class="number">1</span>);</span><br><span class="line">      	<span class="comment">//将底下最大的圆盘移到目标竹竿</span></span><br><span class="line">        System.out.println(<span class="string">"move 1 disk from "</span>+source+<span class="string">" to "</span>+target);</span><br><span class="line">      	<span class="comment">//再尝试将辅助竹竿上的圆盘移回到目标竹竿-&gt;子问题</span></span><br><span class="line">        process(auxiliary,target,source,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        process(<span class="string">"Left"</span>, <span class="string">"Right"</span>, <span class="string">"Help"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Master公式计算得<code>T(N) = T(N-1)+1+T(N-1)</code>，时间复杂度为<code>O(2^N)</code></p>
<h3 id="打印一个字符串的所有子序列"><a href="#打印一个字符串的所有子序列" class="headerlink" title="打印一个字符串的所有子序列"></a>打印一个字符串的所有子序列</h3><blockquote>
<p>字符串的子序列和子串有着不同的定义。子串指串中相邻的任意个字符组成的串，而子序列可以是串中任意个不同字符组成的串。</p>
</blockquote>
<p>尝试：开始时，令子序列为空串，扔给递归方法。首先来到字符串的第一个字符上，这时会有两个决策：将这个字符加到子序列和不加到子序列。这两个决策会产生两个不同的子序列，将这两个子序列作为这一级收集的信息扔给子过程，子过程来到字符串的第二个字符上，对上级传来的子序列又有两个决策，……这样最终能将所有子序列组合穷举出来：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/allSubSequences.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印字符串的所有子序列-递归方式</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str	目标字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index	当前子过程来到了哪个字符的决策上（要还是不要）</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> res	上级扔给本级的子序列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllSubSequences</span><span class="params">(String str,<span class="keyword">int</span> index,String res)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//base case ： 当本级子过程来到的位置到达串末尾，则直接打印</span></span><br><span class="line">  <span class="keyword">if</span>(index == str.length()) &#123;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//决策是否要index位置上的字符</span></span><br><span class="line">  printAllSubSequences(str, index+<span class="number">1</span>, res+str.charAt(index));</span><br><span class="line">  printAllSubSequences(str, index+<span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  printAllSubSequences(<span class="string">"abc"</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印一个字符串的所有全排列结果"><a href="#打印一个字符串的所有全排列结果" class="headerlink" title="打印一个字符串的所有全排列结果"></a>打印一个字符串的所有全排列结果</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/allPermutations.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 本级任务：将index之后（包括index）位置上的字符和index上的字符交换，将产生的所有结果扔给下一级</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index	</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllPermutations</span><span class="params">(<span class="keyword">char</span>[] chs,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//base case</span></span><br><span class="line">  <span class="keyword">if</span>(index == chs.length-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(chs);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; chs.length; j++) &#123;</span><br><span class="line">    swap(chs,index,j);</span><br><span class="line">    printAllPermutations(chs, index+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chs,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> temp = chs[i];</span><br><span class="line">  chs[i] = chs[j];</span><br><span class="line">  chs[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  printAllPermutations(<span class="string">"abc"</span>.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="母牛生牛问题"><a href="#母牛生牛问题" class="headerlink" title="母牛生牛问题"></a>母牛生牛问题</h3><p>母牛每年生一只母牛，新出生的母牛成长三年后也能每年生一只母牛，假设不会死。求N年后，母牛的数量。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/cow_problem.png" alt> </p>
<p>那么求第n年母牛的数量，按照此公式顺序计算即可，但这是<code>O(N)</code>的时间复杂度，存在<code>O(logN)</code>的算法（放到进阶篇中讨论）。</p>
<h2 id="暴力递归改为动态规划"><a href="#暴力递归改为动态规划" class="headerlink" title="暴力递归改为动态规划"></a>暴力递归改为动态规划</h2><p>为什么要改动态规划？有什么意义？</p>
<p>动态规划由暴力递归而来，是对暴力递归中的重复计算的一个优化，策略是空间换时间。</p>
<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>给你一个二维数组，二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向右或者向下。沿途经过的数字要累加起来。返回最小的路径和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从矩阵matrix的(i,j)位置走到右下角元素，返回最小沿途元素和。每个位置只能向右或向下</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 最小路径和</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span> matrix[][], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果(i,j)就是右下角的元素</span></span><br><span class="line">  <span class="keyword">if</span> (i == matrix.length - <span class="number">1</span> &amp;&amp; j == matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> matrix[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果(i,j)在右边界上，只能向下走</span></span><br><span class="line">  <span class="keyword">if</span> (j == matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> matrix[i][j] + minPathSum(matrix, i + <span class="number">1</span>, j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果(i,j)在下边界上，只能向右走</span></span><br><span class="line">  <span class="keyword">if</span> (i == matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> matrix[i][j] + minPathSum(matrix, i, j + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是上述三种情况，那么(i,j)就有向下和向右两种决策，取决策结果最小的那个</span></span><br><span class="line">  <span class="keyword">int</span> left = minPathSum(matrix, i, j + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> down = minPathSum(matrix, i + <span class="number">1</span>, j);</span><br><span class="line">  <span class="keyword">return</span> matrix[i][j] + Math.min(left,down );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> matrix[][] = &#123; </span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, </span><br><span class="line">    &#123; <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125; </span><br><span class="line">  &#125;;</span><br><span class="line">  System.out.println(minPathSum(matrix, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">//14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据尝试版本改动态规划"><a href="#根据尝试版本改动态规划" class="headerlink" title="根据尝试版本改动态规划"></a>根据尝试版本改动态规划</h4><p>上述暴力递归的缺陷在于有些子过程是重复的。比如<code>minPathSum(matrix,0,1)</code>和<code>minPathSum(matrix,1,0)</code>都会依赖子过程<code>minPathSum(matrix,1,1)</code>的状态（执行结果），那么在计算<code>minPathSum(matrix,0,0)</code>时势必会导致<code>minPathSum(matrix,1,1)</code>的重复计算。那我们能否通过对子过程计算结果进行缓存，在再次需要时直接使用，从而实现对整个过程的一个优化呢。</p>
<p>由暴力递归改动态规划的核心就是将每个子过程的计算结果进行一个记录，从而达到空间换时间的目的。那么<code>minPath(int matrix[][],int i,int j)</code>中变量<code>i</code>和<code>j</code>的不同取值将导致<code>i*j</code>种结果，我们将这些结果保存在一个<code>i*j</code>的表中，不就达到动态规划的目的了吗？</p>
<p>观察上述代码可知，右下角、右边界、下边界这些位置上的元素是不需要尝试的（只有一种走法，不存在决策问题），因此我们可以直接将这些位置上的结果先算出来：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mini_path.png" alt> </p>
<p>而其它位置上的元素的走法则依赖右方相邻位置（i，j+1）走到右下角的最小路径和和下方相邻位置（i+1，j）走到右下角的最小路径和的大小比较，基于此来做一个向右走还是向左走的决策。但由于右边界、下边界位置上的结果我们已经计算出来了，因此对于其它位置上的结果也就不难确定了：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mini_path1.png" alt> </p>
<p>我们从<code>base case</code>开始，倒着推出了所有子过程的计算结果，并且没有重复计算。最后<code>minPathSum(matrix,0,0)</code>也迎刃而解了。</p>
<blockquote>
<p>这就是动态规划，它不是凭空想出来的。首先我们尝试着解决这个问题，写出了暴力递归。再由暴力递归中的变量的变化范围建立一张对应的结果记录表，以<code>base case</code>作为突破口确定能够直接确定的结果，最后解决普遍情况对应的结果。</p>
</blockquote>
<h3 id="一个数是否是数组中任意个数的和"><a href="#一个数是否是数组中任意个数的和" class="headerlink" title="一个数是否是数组中任意个数的和"></a>一个数是否是数组中任意个数的和</h3><p>给你一个数组arr，和一个整数aim。如果可以任意选择arr中的数字，能不能累加得到aim，返回true或者false。</p>
<blockquote>
<p>此题的思路跟求解一个字符串的所有子序列的思路一致，穷举出数组中所有任意个数相加的不同结果。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/is_sum.png" alt> </p>
<h4 id="暴力递归版本"><a href="#暴力递归版本" class="headerlink" title="暴力递归版本"></a>暴力递归版本</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择任意个arr中的元素相加是否能得到aim</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum 上级扔给我的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   决策来到了下标为i的元素上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> aim, <span class="keyword">int</span> sum,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//决策完毕</span></span><br><span class="line">  <span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum == aim;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//决策来到了arr[i]：加上arr[i]或不加上。将结果扔给下一级</span></span><br><span class="line">  <span class="keyword">return</span> isSum(arr, aim, sum + arr[i], i + <span class="number">1</span>) || isSum(arr, aim, sum, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  System.out.println(isSum(arr, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  System.out.println(isSum(arr, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  System.out.println(isSum(arr, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="暴力递归改动态规划（高度套路）"><a href="#暴力递归改动态规划（高度套路）" class="headerlink" title="暴力递归改动态规划（高度套路）"></a>暴力递归改动态规划（高度套路）</h4><ol>
<li>首先看递归函数的参数，找出变量。这里<code>arr</code>和<code>aim</code>是固定不变的，可变的只有<code>sum</code>和<code>i</code>。</li>
<li>对应变量的变化范围建立一张表保存不同子过程的结果，这里<code>i</code>的变化范围是<code>0~arr.length-1</code>即<code>0~2</code>，而<code>sum</code>的变化范围是<code>0~数组元素总和</code>，即<code>0~6</code>。因此需要建一张<code>3*7</code>的表。</li>
<li>从<code>base case</code>入手，计算可直接计算的子过程，以<code>isSum(5,0,0)</code>的计算为例，其子过程中“是否+3”的决策之后的结果是可以确定的：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/is_sum1.png" alt> </p>
<ol start="4">
<li>按照递归函数中<code>base case</code>下的尝试过程，推出其它子过程的计算结果，这里以<code>i=1,sum=1</code>的推导为例：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/is_sum2.png" alt> </p>
<h3 id="哪些暴力递归能改为动态规划"><a href="#哪些暴力递归能改为动态规划" class="headerlink" title="哪些暴力递归能改为动态规划"></a>哪些暴力递归能改为动态规划</h3><p>看过上述例题之后你会发现只要你能够写出尝试版本，那么改动态规划是高度套路的。但是不是所有的暴力递归都能够改动态规划呢？不是的，比如汉诺塔问题和N皇后问题，他们的每一步递归都是必须的，没有多余。这就涉及到了递归的有后效性和无后效性。</p>
<h4 id="有后效性和无后效性"><a href="#有后效性和无后效性" class="headerlink" title="有后效性和无后效性"></a>有后效性和无后效性</h4><p>无后效性是指对于递归中的某个子过程，其上级的决策对该级的后续决策没有任何影响。比如最小路径和问题中以下面的矩阵为例：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mini_path2.png" alt> </p>
<p>对于（1，1）位置上的8，无论是通过<code>9-&gt;1-&gt;8</code>还是<code>9-&gt;4-&gt;8</code>来到这个<code>8</code>上的，这个<code>8</code>到右下角的最小路径和的计算过程不会改变。这就是无后效性。</p>
<blockquote>
<p>只有无后效性的暴力递归才能改动态规划。</p>
</blockquote>
]]></content>
      <categories>
        <category>左神算法</category>
        <category>递归和动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法班笔记-贪心策略</title>
    <url>/2020/03/10/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%8F%AD%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h1><h2 id="拼接最小字典序"><a href="#拼接最小字典序" class="headerlink" title="拼接最小字典序"></a>拼接最小字典序</h2><p>给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最低的字典序。</p><blockquote>
<p>此题很多人的想法是把数组按照字典序排序，然后从头到尾连接，形成的字符串就是所有拼接结果中字典序最小的那个。但这很容易证明是错的，比如<code>[ba,b]</code>的排序结果是<code>[b,ba]</code>，拼接结果是<code>bba</code>，但<code>bab</code>的字典序更小。</p>
<p>正确的策略是，将有序字符串数组从头到尾两两拼接时，应取两两拼接的拼接结果中字典序较小的那个。证明如下</p>
</blockquote><a id="more"></a>

<p>如果令<code>.</code>代表拼接符号，那么这里的命题是如果<code>str1.str2 &lt; str2.str2</code>且<code>str2.str3 &lt; str3.str2</code>，那么一定有<code>str1.str3 &lt; str3.str1</code>。这可以使用数学归纳法来证明。如果将<code>a~z</code>对应到<code>0~25</code>，比较两个字符串的字典序的过程，其实就比较两个26进制数大小的过程。<code>str1.str2</code>拼接的过程可以看做两个26进制数拼接的过程，若将两字符串解析成数字<code>int1</code>和<code>int2</code>，那么拼接就对应<code>int1 * 26^(str2的长度) + int2</code>，那么证明过程就变成了两个整数不等式递推另一个不等式了。</p>
<h2 id="金条和铜板"><a href="#金条和铜板" class="headerlink" title="金条和铜板"></a>金条和铜板</h2><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的 金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，怎么分最省铜板？</p>
<p>例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长度60的金条分成10和50，花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。但是如果， 先把长度60的金条分成30和30，花费60 再把长度30金条分成10和20，花费30 一共花费90铜板。</p>
<p>输入一个数组，返回分割的最小代价。</p>
<blockquote>
<p>贪心策略，将给定的数组中的元素扔进小根堆，每次从小根堆中先后弹出两个元素（如10和20），这两个元素的和（如30）就是某次分割得到这两个元素的花费，再将这个和扔进小根堆。直到小根堆中只有一个元素为止。（比如扔进30之后，弹出30、30，此次花费为30+30=60，再扔进60，堆中只有一个60了，结束，总花费30+60-=90）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> stzuoatic <span class="keyword">int</span> <span class="title">lessMoney</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//PriorityQueue是Java语言对堆结构的一个实现，默认将按自然顺序的最小元素放在堆顶</span></span><br><span class="line">  PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">    minHeap.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> curCost = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (minHeap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    curCost = minHeap.poll() + minHeap.poll();</span><br><span class="line">    res += curCost;</span><br><span class="line">    minHeap.add(curCost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">  System.out.println(lessMoney(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IPO"><a href="#IPO" class="headerlink" title="IPO"></a>IPO</h2><p>输入： 参数1：正数数组costs；参数2：正数数组profits；参数3：正数k；参数4：正数m。costs[i]表示i号项目的花费（成本），profits[i]表示i号项目做完后在扣除花费之后还能挣到的钱(利润)，k表示你不能并行，只能串行的最多做k个项目 m表示你初始的资金。</p>
<p>说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。</p>
<p>输出： 你最后获得的最大钱数。</p>
<blockquote>
<p>贪心策略：借助两个堆，一个是存放各个项目花费的小根堆、另一个是存放各个项目利润的大根堆。首先将所有项目放入小根堆而大根堆为空，对于手头上现有的资金（本金），将能做的项目（成本低于现有资金）从小根堆依次弹出并放入到大根堆，再弹出大根堆堆顶项目来完成，完成后根据利润更新本金。本金更新后，再将小根堆中能做的项目弹出加入到大根堆中，再弹出大根堆中的堆顶项目来做，重复此操作，直到某次本金更新和两个堆更新后大根堆无项目可做或者完成的项目个数已达k个为止。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">int</span> profit;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Project</span><span class="params">(<span class="keyword">int</span> cost, <span class="keyword">int</span> profit)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.cost = cost;</span><br><span class="line">      <span class="keyword">this</span>.profit = profit;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostHeap</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Project p1, Project p2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> p1.cost-p2.cost; <span class="comment">//升序，由此构造的堆将把花费最小项目的放到堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfitHeap</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Project p1, Project p2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> p2.profit-p1.profit;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> costs[], <span class="keyword">int</span> profits[], <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Project&gt; minCostHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MinCostHeap());</span><br><span class="line">    PriorityQueue&lt;Project&gt; maxProfitHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxProfitHeap());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">      Project project = <span class="keyword">new</span> Project(costs[i], profits[i]);</span><br><span class="line">      minCostHeap.add(project);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      <span class="comment">//unlock project</span></span><br><span class="line">      <span class="keyword">while</span> (minCostHeap.peek().cost &lt; m) &#123;</span><br><span class="line">        maxProfitHeap.add(minCostHeap.poll());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxProfitHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">      &#125;</span><br><span class="line">      m +=  maxProfitHeap.poll().profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="会议室项目宣讲"><a href="#会议室项目宣讲" class="headerlink" title="会议室项目宣讲"></a>会议室项目宣讲</h2><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数组，里面 是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。</p>
<blockquote>
<p>贪心策略：</p>
<p>1、开始时间最早的项目先安排。反例：开始时间最早，但持续时间占了一整天，其他项目无法安排。</p>
<p>2、持续时间最短的项目先安排。反例：这样安排会导致结束时间在此期间和开始时间在此期间的所有项目不能安排。</p>
<p>3、最优策略：最先结束的项目先安排。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MostEarlyEndComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Project p1, Project p2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> p1.end-p2.end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(Project projects[],<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sort by the end time</span></span><br><span class="line">    Arrays.sort(projects, <span class="keyword">new</span> MostEarlyEndComparator());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; projects.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentTime &lt;= projects[i].start) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        currentTime = projects[i].end;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经验：贪心策略相关的问题，累积经验就好，不必花费大量精力去证明。解题的时候要么找相似点，要么脑补策略然后用对数器、测试用例去证。</p>
]]></content>
      <categories>
        <category>左神算法</category>
        <category>贪心算法</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法班笔记-经典结构和算法</title>
    <url>/2020/03/10/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%8F%AD%E7%AC%94%E8%AE%B0-%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="经典结构和算法"><a href="#经典结构和算法" class="headerlink" title="经典结构和算法"></a>经典结构和算法</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法是由一个问题而引发的：对于一个字符串<code>str</code>（长度为N）和另一个字符串<code>match</code>（长度为M），如果<code>match</code>是<code>str</code>的子串，请返回其在<code>str</code>第一次出现时的首字母下标，若<code>match</code>不是<code>str</code>的子串则返回<code>-1</code>。</p><p>最简单的方法是将<code>str</code>从头开始遍历并与<code>match</code>逐次比较，若碰到了不匹配字母则终止此次遍历转而从<code>str</code>的第二个字符开始遍历并与<code>match</code>逐次比较，直到某一次的遍历每个字符都与<code>match</code>匹配否则返回<code>-1</code>。易知此种做法的时间复杂度为<code>O(N*M)</code>。</p><a id="more"></a>

<blockquote>
<p>KMP算法则给出求解该问题时间复杂度控制在<code>O(N)</code>的解法。</p>
</blockquote>
<p>首先该算法需要对应<code>match</code>创建一个与<code>match</code>长度相同的辅助数组<code>help[match.length]</code>，该数组元素表示<code>match</code>某个下标之前的子串的<strong>前后缀子串最大匹配长度</strong>。<strong>前缀子串</strong>表示一个串中以串首字符开头的不包含串尾字符的任意个连续字符，<strong>后缀子串</strong>则表示一个串中以串尾字符结尾的不包括串首字符的任意个连续字符。比如<code>abcd</code>的前缀子串可以是<code>a</code>、<code>ab</code>、<code>abc</code>，但不能是<code>abcd</code>，而<code>abcd</code>的后缀字串可以是<code>d</code>、<code>cd</code>、<code>bcd</code>，但不能是<code>abcd</code>。再来说一下<code>help</code>数组，对于<code>char match[]=&quot;abc1abc2&quot;</code>来说，有<code>help[7]=3</code>，因为<code>match[7]=&#39;2&#39;</code>，因此<code>match</code>下标在<code>7</code>之前的子串<code>abc1abc</code>的前缀子串和后缀子串相同的情况下，前缀子串的最大长度为3（即前缀字串和后缀字串都取<code>abc</code>）；又如<code>match=&quot;aaaab&quot;</code>，有<code>help[4]=3</code>（前缀子串和后缀子串最大匹配长度当两者为<code>aaa</code>时取得），相应的有<code>help[3]=2</code>、<code>help[2]=1</code>。</p>
<p>假设当要寻找的子串<code>match</code>的<code>help</code>数组找到之后（对于一个串的<code>help</code>数组的求法在介绍完<code>KMP</code>算法之后再详细说明）。就可以进行<code>KMP</code>算法求解此问题了。<code>KMP</code>算法的逻辑（结论）是，对于<code>str</code>的<code>i~(i+k)</code>部分（<code>i</code>、<code>i+k</code>均为<code>str</code>的合法下标）和<code>match</code>的<code>0~k</code>部分（<code>k</code>为<code>match</code>的合法下标），如果有<code>str[i]=match[0]</code>、<code>str[i+1]=match[1]</code>……<code>str[i+k-1]=match[k-1]</code>，但<code>str[i+k]!=[k]</code>，那么<code>str</code>的下标不用从<code>i+k</code>变为<code>i+1</code>重新比较，只需将子串<code>str[0]~str[i+k-1]</code>的最大匹配前缀子串的后一个字符<code>cn</code>重新与<code>str[i+k]</code>向后依次比较，后面如果又遇到了不匹配的字符重复此操作即可：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/kmp.png" alt></p>
<p>当遇到不匹配字符时，常规的做法是将<code>str</code>的遍历下标<code>sIndex</code>移到<code>i+1</code>的位置并将<code>match</code>的遍历下标<code>mIndex</code>移到<code>0</code>再依次比较，这种做法并没有利用上一轮的比较信息（对下一轮的比较没有任何优化）。而<code>KMP</code>算法则不是这样，当遇到不匹配的字符<code>str[i+k]</code>和<code>match[k]</code>时，<code>str</code>的遍历指针<code>sIndex=i+k</code>不用动，将<code>match</code>右滑并将其遍历指针<code>mIndex</code>打到子串<code>match[0]~match[k-1]</code>的最大匹配前缀子串的后一个下标<code>n</code>的位置。然后<code>sIndex</code>从<code>i+k</code>开始，<code>mIndex</code>从<code>n</code>开始，依次向后比较，若再遇到不匹配的数则重复此过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">length</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(*(str++)!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndexOf</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">char</span>* m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slen = length(str) , mlen = length(m);</span><br><span class="line">    <span class="keyword">if</span>(mlen &gt; slen)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> help[mlen];</span><br><span class="line">    getHelpArr(str,help);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;	<span class="comment">//sIndex,mIndex</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; slen &amp;&amp; j &lt; mlen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == m[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(help[j] != <span class="number">-1</span>)&#123;</span><br><span class="line">            j = help[j];    <span class="comment">//mIndex -&gt; cn's index</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;	<span class="comment">//the first char is not match,move the sIndex</span></span><br><span class="line">            i++;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == mlen ? i - mlen : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现<code>KMP</code>算法中<code>str</code>的遍历指针并没有回溯这个动作（只向后移动），当完成匹配时<code>sIndex</code>的移动次数小于<code>N</code>，否则<code>sIndex</code>移动到串尾也会终止循环，所以<code>while</code>对应的匹配过程的时间复杂度为<code>O(N)</code>(<code>if(help[j] != -1){ j = help[j] }</code>的执行次数只会是常数次，因此可以忽略)。</p>
<p>下面只要解决如何求解一个串的<code>help</code>数组，此问题就解决了。<code>help</code>数组要从前到后求解，直接求<code>help[n]</code>是很难有所头绪的。当串<code>match</code>长度<code>mlen=1</code>时，规定<code>help[0]=-1</code>。当<code>mlen=2</code>时，去掉<code>match[1]</code>之后只剩下<code>match[0]</code>，最大匹配子串长度为0（因为前缀子串不能包含串尾字符，后缀子串不能包含串首字符），即<code>help[1]=0</code>。当<code>mlen&gt;2</code>时，<code>help[n]</code>（n&gt;=2）都可以推算出来：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/kmp_next.png" alt></p>
<p>如上图所示，如果我们知道了<code>help[n-1]</code>，那么<code>help[n]</code>的求解有两种情况：如果<code>match[cn]=match[n-1]</code>，那么由a区域与b区域（a、b为子串<code>match[0~n-2]</code>的最大匹配前缀子串和后缀字串）相同可知<code>help[n]=help[n-1]+1</code>；如果<code>match[cn]!=match[n-1]</code>，那么求a区域中下一个能和b区域后缀子串中匹配的较大的一个，即a区域的最大匹配前缀字串<code>c区域</code>，将<code>match[n-1]</code>和c区域的后一个位置（<code>cn&#39;</code>）上的字符比较，如果相等则<code>help[n]</code>等于c区域的长度+1，而c区域的长度就是<code>help[cn]</code>（<code>help</code>数组的定义如此）；如果不等则将<code>cn</code>打到<code>cn&#39;</code>的位置继续和<code>match[n-1]</code>比较，直到<code>cn</code>被打到<code>0</code>为止（即<code>help[cn]=-1</code>为止），那么此时<code>help[n]=0</code>。</p>
<p>对应代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getHelpArr</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> help[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> slen = length(s);</span><br><span class="line">    help[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    help[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">2</span>;<span class="comment">//help数组从第三个元素开始的元素值需要依次推算</span></span><br><span class="line">    <span class="keyword">int</span> cn = <span class="number">0</span>;		<span class="comment">//推算help[2]时，help[1]=0，即s[1]之前的字符组成的串中不存在最大匹配前后子串，那么cn作为最大匹配前缀子串的后一个下标自然就是0了</span></span><br><span class="line">    <span class="keyword">while</span>(index &lt; slen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[index<span class="number">-1</span>] == s[cn])&#123;	<span class="comment">//if match[n-1] == match[cn]</span></span><br><span class="line">            help[index] = help[index<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">            cn++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(help[cn] == <span class="number">-1</span>)&#123;	<span class="comment">//cn reach 0</span></span><br><span class="line">            help[index]=<span class="number">0</span>;</span><br><span class="line">            index++;</span><br><span class="line">            cn++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cn = help[cn];	<span class="comment">//set cn to cn' and continue calculate help[index]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个求解<code>help</code>数组的过程的时间复杂度如何计算呢？仔细观察克制<code>while</code>循环中仅涉及到<code>index</code>和<code>cn</code>这两个变量的变化：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">第一个if分支</th>
<th align="left">第二个if分支</th>
<th align="left">第三个if分支</th>
</tr>
</thead>
<tbody><tr>
<td align="left">index</td>
<td align="left">增大</td>
<td align="left">增大</td>
<td align="left">不变</td>
</tr>
<tr>
<td align="left">index-cn</td>
<td align="left">不变</td>
<td align="left">不变</td>
<td align="left">增大</td>
</tr>
</tbody></table>
<p>可以发现<code>while</code>循环执行一次不是<code>index</code>增大就是<code>index-cn</code>增大，而<code>index &lt; slen</code>、<code>index - cn &lt; slen</code>，即<code>index</code>最多自增<code>M</code>（<code>match</code>串的长度）次 ，<code>index-cn</code>最多增加<code>M</code>次，如此<code>while</code>最多执行<code>M+M</code>次，即时间复杂为<code>O(2M)=O(M)</code>。</p>
<p>综上所述，使用<code>KMP</code>求解此问题的时间复杂度为<code>O(M)</code>（求解<code>match</code>的<code>help</code>数组的时间复杂度）+<code>O(N)</code>（匹配的时间复杂度）=<code>O(N)</code>（因为<code>N &gt; M</code>）。</p>
<h4 id="KMP算法的应用"><a href="#KMP算法的应用" class="headerlink" title="KMP算法的应用"></a>KMP算法的应用</h4><ol>
<li><p>判断一个二叉树是否是另一棵二叉树的子树（即某棵树的结构和数据状态和另一棵二叉树的子树样）。</p>
<p> 思路：如果这棵树的序列化串是另一棵树的序列化串的子串，那么前者必定是后者的子树。</p>
</li>
</ol>
<h3 id="前缀树（字典树）"><a href="#前缀树（字典树）" class="headerlink" title="前缀树（字典树）"></a>前缀树（字典树）</h3><p>前缀树是一种存储字符串的高效容器，基于此结构的操作有：</p>
<ul>
<li><code>insert</code>插入一个字符串到容器中</li>
<li><code>search</code>容器中是否存在某字符串，返回该字符串进入到容器的次数，没有则返回0</li>
<li><code>delete</code>将某个字符串进入到容器的次数减1</li>
<li><code>prefixNumber</code>返回所有插入操作中，以某个串为前缀的字符串出现的次数</li>
</ul>
<p>设计思路：该结构的重点实现在于存储。前缀树以字符为存储单位，将其存储在结点之间的树枝上而非结点上，如插入字符串<code>abc</code>之后前缀树如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/prefix_tree.png" alt></p>
<p>每次插入串都要从头结点开始，遍历串中的字符依次向下“铺路”，如上图中的<code>abc</code>3条路。对于每个结点而言，它可以向下铺<code>a~z</code>26条不同的路，假如来到某个结点后，它要向下铺的路（取决于遍历到哪个字符来了）被之前插入串的过程铺过了那么就可以直接走这条路去往下一个结点，否则就要先铺路再去往下一个结点。如再插入串<code>abde</code>和<code>bcd</code>的前缀树将如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/prefix_tree1.png" alt></p>
<p>据前缀树的<code>search</code>和<code>prefixNumber</code>两个操作，我们还需要在每次铺路后记录以下每个结点经过的次数（<code>across</code>），以及每次插入操作每个结点作为终点结点的次数（<code>end</code>）。</p>
<h4 id="前缀树的实现"><a href="#前缀树的实现" class="headerlink" title="前缀树的实现"></a>前缀树的实现</h4><p>前缀树的实现示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> across;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] paths;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      across = <span class="number">0</span>;</span><br><span class="line">      end = <span class="number">0</span>;</span><br><span class="line">      paths = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrieTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向树中插入一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> chs[] = str.toCharArray();</span><br><span class="line">    TrieNode cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : chs) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (cur.paths[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur.paths[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur.paths[index];</span><br><span class="line">      cur.across++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.end++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询某个字符串插入的次数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> chs[] = str.toCharArray();</span><br><span class="line">    TrieNode cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : chs) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (cur.paths[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur.paths[index];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除一次插入过的某个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (search(str) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> chs[] = str.toCharArray();</span><br><span class="line">      TrieNode cur = root;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> ch : chs) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (--cur.paths[index].across == <span class="number">0</span>) &#123;</span><br><span class="line">          cur.paths[index] = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.paths[index];</span><br><span class="line">      &#125;</span><br><span class="line">      cur.end--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查询所有插入的字符串中，以prefix为前缀的有多少个</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="keyword">null</span> || prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> chs[] = prefix.toCharArray();</span><br><span class="line">    TrieNode cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : chs) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (cur.paths[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur.paths[index];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.across;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TrieTree tree = <span class="keyword">new</span> TrieTree();</span><br><span class="line">    tree.insert(<span class="string">"abc"</span>);</span><br><span class="line">    tree.insert(<span class="string">"abde"</span>);</span><br><span class="line">    tree.insert(<span class="string">"bcd"</span>);</span><br><span class="line">    System.out.println(tree.search(<span class="string">"abc"</span>));	<span class="comment">//1</span></span><br><span class="line">    System.out.println(tree.prefixNumber(<span class="string">"ab"</span>));	<span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="前缀树的相关问题"><a href="#前缀树的相关问题" class="headerlink" title="前缀树的相关问题"></a>前缀树的相关问题</h4><p>一个字符串类型的数组arr1，另一个字符串类型的数组arr2：</p>
<ul>
<li>arr2中有哪些字符，是arr1中出现的？请打印</li>
<li>arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印</li>
<li>arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印arr2中出现次数最大的前缀。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单链表和双向链表"><a href="#反转单链表和双向链表" class="headerlink" title="反转单链表和双向链表"></a>反转单链表和双向链表</h3><p>实现反转单向链表和反转双向链表的函数，要求时间复杂度为<code>O(N)</code>，额外空间复杂度为<code>O(1)</code></p>
<blockquote>
<p>此题的难点就是反转一个结点的next指针后，就无法在该结点通过next指针找到后续的结点了。因此每次反转之前需要将该结点的后继结点记录下来。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">truct LinkNode&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	LinkNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(LinkNode* &amp;head)</span></span>&#123;</span><br><span class="line">	head = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,LinkNode* head)</span></span>&#123;</span><br><span class="line">	LinkNode* p = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">	p-&gt;data = i;</span><br><span class="line">	p-&gt;next =  head-&gt;next;</span><br><span class="line">	head-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(LinkNode* head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	LinkNode* p = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(LinkNode *head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	LinkNode* cur = head-&gt;next;</span><br><span class="line">	LinkNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">	LinkNode* next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		next = cur-&gt;next;</span><br><span class="line">		cur-&gt;next = pre;</span><br><span class="line">		pre = cur;</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//pre -&gt; end node</span></span><br><span class="line">	head-&gt;next = pre;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LinkNode* head;</span><br><span class="line">	init(head);</span><br><span class="line">	add(<span class="number">1</span>,head);</span><br><span class="line">	add(<span class="number">2</span>,head);</span><br><span class="line">	add(<span class="number">3</span>,head);</span><br><span class="line">	add(<span class="number">4</span>,head);</span><br><span class="line">	</span><br><span class="line">	printList(head);</span><br><span class="line">	reverseList(head);</span><br><span class="line">	printList(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断一个链表是否为回文结构"><a href="#判断一个链表是否为回文结构" class="headerlink" title="判断一个链表是否为回文结构"></a>判断一个链表是否为回文结构</h3><p>请实现一个函数判断某个单链表是否是回文结构，如<code>1-&gt;3-&gt;1</code>返回<code>true</code>、<code>1-&gt;2-&gt;2-&gt;1</code>返回<code>true</code>、<code>2-&gt;3-&gt;1</code>返回<code>false</code>。</p>
<blockquote>
<p>我们可以利用回文链表前后两半部分逆序的特点、结合栈先进后出来求解此问题。将链表中间结点之前的结点依次压栈，然后从中间结点的后继结点开始遍历链表的后半部分，将遍历的结点与栈弹出的结点比较。</p>
</blockquote>
<p>代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	判断某链表是否是回文结构</span></span><br><span class="line"><span class="comment">	1、首先找到链表的中间结点（若是偶数个结点则是中间位置的左边一个结点）</span></span><br><span class="line"><span class="comment">	2、使用一个栈将中间结点之前的结点压栈，然后从中间结点的后一个结点开始从栈中拿出结点比较 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromeList</span><span class="params">(LinkNode* head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">	LinkNode *slow = head , *fast = head;</span><br><span class="line">	SqStack* <span class="built_in">stack</span>;</span><br><span class="line">	init(<span class="built_in">stack</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//fast指针每走两步，slow指针才走一步 </span></span><br><span class="line">	<span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;	</span><br><span class="line">		slow = slow-&gt;next;	</span><br><span class="line">		push(slow,<span class="built_in">stack</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//链表没有结点或只有一个结点，不是回文结构</span></span><br><span class="line">	<span class="keyword">if</span>(isEmpty(<span class="built_in">stack</span>)) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//判断偶数个结点还是奇数个结点</span></span><br><span class="line">	<span class="keyword">if</span>(fast-&gt;next != <span class="literal">NULL</span>)&#123;	<span class="comment">//奇数个结点,slow需要再走一步 </span></span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从slow的后继结点开始遍历链表，将每个结点与栈顶结点比较</span></span><br><span class="line">	LinkNode* node;</span><br><span class="line">	slow = slow-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(slow != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		pop(<span class="built_in">stack</span>,node);</span><br><span class="line">		<span class="comment">//一旦发现有一个结点不同就不是回文结构 </span></span><br><span class="line">		<span class="keyword">if</span>(slow-&gt;data != node-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	LinkNode* head;</span><br><span class="line">	init(head);</span><br><span class="line">	add(<span class="number">2</span>,head);</span><br><span class="line">	add(<span class="number">3</span>,head);</span><br><span class="line">	add(<span class="number">3</span>,head);</span><br><span class="line">	add(<span class="number">2</span>,head);</span><br><span class="line">	printList(head);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(isPalindromeList(head))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"是回文链表"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"不是回文链表"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 进阶：要求使用时间复杂度为<code>O(N)</code>，额外空间复杂度为<code>O(1)</code>求解此问题。</p>
<p> 思路：我们可以先将链表的后半部分结点的<code>next</code>指针反向，然后从链表的两头向中间推进，逐次比较。（当然了，为了不破坏原始数据结构，我们在得出结论之后还需要将链表指针恢复原样）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromeList</span><span class="params">(LinkNode* head)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*第一步、与方法一一样，找到中间结点*/</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *n1 = head , *n2 = head;</span><br><span class="line">    <span class="keyword">while</span>(n2-&gt;next != <span class="literal">NULL</span> &amp;&amp; n2-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        n2 = n2-&gt;next-&gt;next;</span><br><span class="line">        n1 = n1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有结点或者只有一个首结点</span></span><br><span class="line">    <span class="keyword">if</span>(n2 == head)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是奇数个结点</span></span><br><span class="line">    <span class="keyword">if</span>(n2-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        n1 = n1-&gt;next;  <span class="comment">//n1 -&gt; middle node</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第二步、不使用额外空间，在链表自身上做文章：反转链表后半部分结点的next指针*/</span></span><br><span class="line">    n2 = n1-&gt;next;  <span class="comment">// n2 -&gt; right part first node</span></span><br><span class="line">    n1-&gt;next = <span class="literal">NULL</span>;<span class="comment">//middle node-&gt;next = NULL</span></span><br><span class="line">    LinkNode *n3 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n3 = n2-&gt;next;  <span class="comment">//记录下一个要反转指针的结点</span></span><br><span class="line">        n2-&gt;next = n1;  <span class="comment">//反转指针</span></span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n1 -&gt; end node</span></span><br><span class="line">    n3 = n1;  <span class="comment">//record end node</span></span><br><span class="line">    n2 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2-&gt;data != n1-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = n2-&gt;next;  <span class="comment">//move n2 forward right</span></span><br><span class="line">        n1 = n1-&gt;next;  <span class="comment">//move n1 forward left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//recover the right part nodes</span></span><br><span class="line">    n2 = n3; <span class="comment">//n2 -&gt; end node</span></span><br><span class="line">    n1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n3 = n2-&gt;next;</span><br><span class="line">        n2-&gt;next = n1;</span><br><span class="line">        n1=n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode* head;</span><br><span class="line">    init(head);</span><br><span class="line">    add(<span class="number">2</span>,head);</span><br><span class="line">    add(<span class="number">3</span>,head);</span><br><span class="line">    add(<span class="number">3</span>,head);</span><br><span class="line">    add(<span class="number">1</span>,head);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isPalindromeList(head))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yes"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表与荷兰国旗问题"><a href="#链表与荷兰国旗问题" class="headerlink" title="链表与荷兰国旗问题"></a>链表与荷兰国旗问题</h3><p>将单向链表按某值划分成左边小、中间相等、右边大的形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	partition一个链表有两种做法。</span></span><br><span class="line"><span class="comment">	1，将链表中的所有结点放入一个数组中，那么就转换成了荷兰国旗问题，但这种做法会使用O(N)的额外空间；</span></span><br><span class="line"><span class="comment">	2，分出逻辑上的small,equal,big三个区域，遍历链表结点将其添加到对应的区域中，最后再将这三个区域连起来。 </span></span><br><span class="line"><span class="comment">	这里只示范第二种做法： </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionList</span><span class="params">(LinkNode *head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	LinkNode *smH = <span class="literal">NULL</span>;	<span class="comment">//small area head node</span></span><br><span class="line">	LinkNode *smT = <span class="literal">NULL</span>;	<span class="comment">//small area tail node</span></span><br><span class="line">	LinkNode *midH = <span class="literal">NULL</span>;	<span class="comment">//equal area head node</span></span><br><span class="line">	LinkNode *midT = <span class="literal">NULL</span>;	<span class="comment">//equal area tail node</span></span><br><span class="line">	LinkNode *bigH = <span class="literal">NULL</span>;	<span class="comment">//big area head node</span></span><br><span class="line">	LinkNode *bigT = <span class="literal">NULL</span>;	<span class="comment">//big area tail node</span></span><br><span class="line">	LinkNode *cur = head-&gt;next;	</span><br><span class="line">	LinkNode *next = <span class="literal">NULL</span>;<span class="comment">//next node need to be distributed to the three areas</span></span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		next = cur-&gt;next;</span><br><span class="line">		cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span>(cur-&gt;data &gt; val)&#123;</span><br><span class="line">			<span class="keyword">if</span>(bigH == <span class="literal">NULL</span>)&#123;</span><br><span class="line">				bigH = bigT = cur;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				bigT-&gt;next = cur;</span><br><span class="line">				bigT = cur;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;data == val)&#123;</span><br><span class="line">			<span class="keyword">if</span>(midH == <span class="literal">NULL</span>)&#123;</span><br><span class="line">				midH = midT = cur;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				midT-&gt;next = cur;</span><br><span class="line">				midT = cur;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(smH == <span class="literal">NULL</span>)&#123;</span><br><span class="line">				smH = smT = cur;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				smT-&gt;next = cur;</span><br><span class="line">				smT = cur;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//reconnect small and equal</span></span><br><span class="line">	<span class="keyword">if</span>(smT != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		smT-&gt;next = midH;</span><br><span class="line">		midT = midT == <span class="literal">NULL</span> ? midT : smT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//reconnect equal and big</span></span><br><span class="line">	<span class="keyword">if</span>(bigT != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		midT-&gt;next = bigH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	head = smH != <span class="literal">NULL</span> ? smH : midH != <span class="literal">NULL</span> ? midH : bigH;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LinkNode* head;</span><br><span class="line">	init(head);</span><br><span class="line">	add(<span class="number">5</span>,head);</span><br><span class="line">	add(<span class="number">2</span>,head);</span><br><span class="line">	add(<span class="number">7</span>,head);</span><br><span class="line">	add(<span class="number">9</span>,head);</span><br><span class="line">	add(<span class="number">1</span>,head);</span><br><span class="line">	add(<span class="number">3</span>,head);</span><br><span class="line">	add(<span class="number">5</span>,head);</span><br><span class="line">	printList(head);</span><br><span class="line">	partitionList(head,<span class="number">5</span>);</span><br><span class="line">	printList(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制含有随机指针结点的链表"><a href="#复制含有随机指针结点的链表" class="headerlink" title="复制含有随机指针结点的链表"></a>复制含有随机指针结点的链表</h3><h4 id="借助哈希表，额外空间O-N"><a href="#借助哈希表，额外空间O-N" class="headerlink" title="借助哈希表，额外空间O(N)"></a>借助哈希表，额外空间<code>O(N)</code></h4><p>将链表的所有结点复制一份，以<code>key,value</code>为<code>源结点，副本结点</code>的方式存储到哈希表中，再建立副本结点之间的关系（<code>next、rand</code>指针域）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyLinkListWithRandom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line">        Node rand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyLinkListWithRandom</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Map&lt;Node, Node&gt; copyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyMap.put(cur, <span class="keyword">new</span> Node(cur.data));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyMap.get(cur).next = copyMap.get(cur.next);</span><br><span class="line">            copyMap.get(cur).rand = copyMap.get(cur.rand);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyMap.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListWithRandom</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                System.out.print(<span class="string">"node data:"</span> + head.data);</span><br><span class="line">                <span class="keyword">if</span> (head.rand != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">",rand data:"</span> + head.rand.data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">",rand is null"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node();</span><br><span class="line">        head.next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="进阶操作：额外空间O-1"><a href="#进阶操作：额外空间O-1" class="headerlink" title="进阶操作：额外空间O(1)"></a>进阶操作：额外空间<code>O(1)</code></h4><p>将副本结点追加到对应源结点之后，建立副本结点之间的指针域，最后将副本结点从该链表中分离出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extra area O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyLinkListWithRandom2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node cur = head;</span><br><span class="line">  <span class="comment">//copy every node and append</span></span><br><span class="line">  <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node copy = <span class="keyword">new</span> Node(cur.data);</span><br><span class="line">    copy.next = cur.next;</span><br><span class="line">    cur.next = copy;</span><br><span class="line">    cur = cur.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//set the rand pointer of every copy node</span></span><br><span class="line">  Node copyHead = head.next;</span><br><span class="line">  cur = head;</span><br><span class="line">  Node curCopy = copyHead;</span><br><span class="line">  <span class="keyword">while</span> (curCopy != <span class="keyword">null</span>) &#123;</span><br><span class="line">    curCopy.rand = cur.rand == <span class="keyword">null</span> ? <span class="keyword">null</span> : cur.rand.next;</span><br><span class="line">    cur = curCopy.next;</span><br><span class="line">    curCopy = cur == <span class="keyword">null</span> ? <span class="keyword">null</span> : cur.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//split</span></span><br><span class="line">  cur = head;</span><br><span class="line">  Node next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    curCopy = cur.next;</span><br><span class="line">    next = cur.next.next;</span><br><span class="line">    curCopy.next = next == <span class="keyword">null</span> ? <span class="keyword">null</span> : next.next;</span><br><span class="line">    cur.next = next;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="若两个可能有环的单链表相交，请返回相交的第一个结点"><a href="#若两个可能有环的单链表相交，请返回相交的第一个结点" class="headerlink" title="若两个可能有环的单链表相交，请返回相交的第一个结点"></a>若两个可能有环的单链表相交，请返回相交的第一个结点</h3><p>根据单链表的定义，每个结点有且只有一个<code>next</code>指针，那么如果单链表有环，它的结构将是如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/intersected_linked_list.png" alt> </p>
<p>相交会导致两个结点指向同一个后继结点，但不可能出现一个结点有两个后继结点的情况。</p>
<p>1、当相交的结点不在环上时，有如下两种情况：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/intersected_linked_list1.png" alt> </p>
<p>2、当相交的结点在环上时，只有一种情况：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/intersected_linked_list2.png" alt> </p>
<p>综上，两单链表若相交，要么都无环，要么都有环。</p>
<blockquote>
<p>此题还需要注意的一点是如果链表有环，那么如何获取入环呢（因为不能通过<code>next</code>是否为空来判断是否是尾结点了）。这里就涉及到了一个规律：如果快指针<code>fast</code>和慢指针<code>slow</code>同时从头结点出发，<code>fast</code>走两步而<code>slow</code>走一步，当两者相遇时，将<code>fast</code>指针指向头结点，使两者都一次只走一步，两者会在入环结点相遇。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstIntersectNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node fast = head;</span><br><span class="line">        Node slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">        <span class="comment">//fast == slow</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFirstIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node loop1 = getLoopNode(head1);    <span class="comment">//两链表的入环结点loop1和loop2</span></span><br><span class="line">        Node loop2 = getLoopNode(head2);</span><br><span class="line">        <span class="comment">//no loop</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//both loop</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bothLoop(head1, head2, loop1, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//don't intersect</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node head2, Node loop1, Node loop2)</span> </span>&#123;</span><br><span class="line">        Node cur1 = head1;</span><br><span class="line">        Node cur2 = head2;</span><br><span class="line">        <span class="comment">//入环结点相同，相交点不在环上</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur1.next != loop1) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2.next != loop1) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;           <span class="comment">//将cur1指向结点数较多的链表</span></span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;   <span class="comment">//将cur2指向另一个链表</span></span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;                        <span class="comment">//将cur1先走两链表结点数差值个结点</span></span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;                  <span class="comment">//cur1和cur2会在入环结点相遇</span></span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入环结点不同，相交点在环上</span></span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;    <span class="comment">//链表2的入环结点在链表1的环上，说明相交</span></span><br><span class="line">                <span class="keyword">return</span> loop1;   <span class="comment">//返回loop1或loop2均可，因为整个环就是两链表的相交部分</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在链表1的环上转了一圈也没有找到链表2的入环结点，说明不想交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        Node cur1 = head1;</span><br><span class="line">        Node cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2) &#123;     <span class="comment">//两链表的尾结点不同，不可能相交</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;           <span class="comment">//将cur1指向结点数较多的链表</span></span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;   <span class="comment">//将cur2指向另一个链表</span></span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;                        <span class="comment">//将cur1先走两链表结点数差值个结点</span></span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;                  <span class="comment">//cur1和cur2会在入环结点相遇</span></span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.print(head.data+<span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应三种情况测试如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/intersected_linked_list2.png" alt> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//==================== both loop ======================</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;[3]-&gt;4-&gt;5-&gt;6-&gt;7-&gt;[3]...</span></span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head1.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head1.next.next.next.next.next.next.next = head1.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9-&gt;8-&gt;[6]-&gt;7-&gt;3-&gt;4-&gt;5-&gt;[6]...</span></span><br><span class="line">        Node head2 = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head2.next.next = head1.next.next.next.next.next;</span><br><span class="line">        head2.next.next.next = head1.next.next.next.next.next.next;</span><br><span class="line">        head2.next.next.next.next = head1.next.next;</span><br><span class="line">        head2.next.next.next.next.next = head1.next.next.next;</span><br><span class="line">        head2.next.next.next.next.next.next = head1.next.next.next.next;</span><br><span class="line">        head2.next.next.next.next.next.next.next = head1.next.next.next.next.next;</span><br><span class="line"></span><br><span class="line">        printList(head1);</span><br><span class="line">        printList(head2);</span><br><span class="line">        System.out.println(getFirstIntersectNode(head1, head2).data);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1-&gt;[2]-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;4...</span></span><br><span class="line">        Node head3 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head3.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head3.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head3.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head3.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head3.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head3.next.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head3.next.next.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head3.next.next.next.next.next.next.next.next = head1.next.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9-&gt;0-&gt;[2]-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;4...</span></span><br><span class="line">        Node head4 = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head4.next = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head4.next.next = head3.next;</span><br><span class="line">        head4.next.next.next = head3.next.next;</span><br><span class="line">        head4.next.next.next.next = head3.next.next.next;</span><br><span class="line">        head4.next.next.next.next.next = head3.next.next.next.next;</span><br><span class="line">        head4.next.next.next.next.next.next = head3.next.next.next.next.next;</span><br><span class="line">        head4.next.next.next.next.next.next.next = head3.next.next.next.next.next.next;</span><br><span class="line">        head4.next.next.next.next.next.next.next.next = head3.next.next.next.next.next.next.next;</span><br><span class="line">        head4.next.next.next.next.next.next.next.next.next = head3.next.next.next;</span><br><span class="line"></span><br><span class="line">        printList(head3);</span><br><span class="line">        printList(head4);</span><br><span class="line">        System.out.println(getFirstIntersectNode(head3,head4).data);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//============= no loop ==============</span></span><br><span class="line">        <span class="comment">//1-&gt;[2]-&gt;3-&gt;4-&gt;5</span></span><br><span class="line">        Node head5 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head5.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head5.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head5.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head5.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//6-&gt;[2]-&gt;3-&gt;4-&gt;5</span></span><br><span class="line">        Node head6 = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head6.next = head5.next;</span><br><span class="line">        head6.next.next = head5.next.next;</span><br><span class="line">        head6.next.next.next = head5.next.next.next;</span><br><span class="line">        head6.next.next.next.next = head5.next.next.next.next;</span><br><span class="line"></span><br><span class="line">        System.out.println(getFirstIntersectNode(head5,head6).data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="用数组结构实现大小固定的栈和队列"><a href="#用数组结构实现大小固定的栈和队列" class="headerlink" title="用数组结构实现大小固定的栈和队列"></a>用数组结构实现大小固定的栈和队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArrayStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ArrayStack *&amp;<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> = (ArrayStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(ArrayStack* <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span> ?;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span> ?;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i, ArrayStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(ArrayStack* <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTopElement</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayStack* <span class="built_in">stack</span>;</span><br><span class="line">    init(<span class="built_in">stack</span>);</span><br><span class="line">    push(<span class="number">1</span>, <span class="built_in">stack</span>);</span><br><span class="line">    push(<span class="number">2</span>, <span class="built_in">stack</span>);</span><br><span class="line">    push(<span class="number">3</span>, <span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, pop(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, getTopElement(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, pop(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, pop(<span class="built_in">stack</span>));</span><br><span class="line">		<span class="comment">//3 2 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组结构实现的环形队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArrayCircleQueue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ArrayCircleQueue *&amp;<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> = (ArrayCircleQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayCircleQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(ArrayCircleQueue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(ArrayCircleQueue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">queue</span>-&gt;rear+<span class="number">1</span>)%MAX_SIZE==<span class="built_in">queue</span>-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> i, ArrayCircleQueue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="comment">//move the rear and fill it</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;data[++<span class="built_in">queue</span>-&gt;rear] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(ArrayCircleQueue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;data[++<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayCircleQueue* <span class="built_in">queue</span>;</span><br><span class="line">    init(<span class="built_in">queue</span>);</span><br><span class="line">    enQueue(<span class="number">1</span>, <span class="built_in">queue</span>);</span><br><span class="line">    enQueue(<span class="number">2</span>, <span class="built_in">queue</span>);</span><br><span class="line">    enQueue(<span class="number">3</span>, <span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, deQueue(<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取栈中最小元素"><a href="#取栈中最小元素" class="headerlink" title="取栈中最小元素"></a>取栈中最小元素</h3><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作<code>getMin</code>。要求如下：</p>
<ul>
<li><code>pop</code>、<code>push</code>、<code>getMin</code>操作的时间复杂度都是<code>O(1)</code>。</li>
<li>设计的栈类型可以使用现成的栈结构。</li>
</ul>
<blockquote>
<p>思路：由于每次<code>push</code>之后都会可能导致栈中已有元素的最小值发生变化，因此需要一个容器与该栈联动（记录每次<code>push</code>产生的栈中最小值）。我们可以借助一个辅助栈，数据栈<code>push</code>第一个元素时，将其也<code>push</code>到辅助栈，此后每次向数据栈<code>push</code>元素的同时将其和辅助栈的栈顶元素比较，如果小，则将其也<code>push</code>到辅助栈，否则取辅助栈的栈顶元素<code>push</code>到辅助栈。（数据栈正常<code>push</code>、<code>pop</code>数据，而辅助栈<code>push</code>每次数据栈<code>push</code>后产生的栈中最小值；但数据栈<code>pop</code>时，辅助栈也只需简单的<code>pop</code>即可，保持同步）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ArrayStack.cpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GetMinStack</span>&#123;</span></span><br><span class="line">    ArrayStack* dataStack;</span><br><span class="line">    ArrayStack* helpStack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initGetMinStack</span><span class="params">(GetMinStack* &amp;<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> = (GetMinStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GetMinStack));</span><br><span class="line">    init(<span class="built_in">stack</span>-&gt;dataStack);</span><br><span class="line">    init(<span class="built_in">stack</span>-&gt;helpStack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i, GetMinStack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">stack</span>-&gt;dataStack)) &#123;</span><br><span class="line">        push(i, <span class="built_in">stack</span>-&gt;dataStack);  <span class="comment">//ArrayStack.cpp</span></span><br><span class="line">        <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>-&gt;helpStack)) &#123;</span><br><span class="line">            i = min(i, getTopElement(<span class="built_in">stack</span>-&gt;helpStack));</span><br><span class="line">        &#125;</span><br><span class="line">        push(i, <span class="built_in">stack</span>-&gt;helpStack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(GetMinStack* <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>-&gt;dataStack)) &#123;</span><br><span class="line">        pop(<span class="built_in">stack</span>-&gt;helpStack);</span><br><span class="line">        <span class="keyword">return</span> pop(<span class="built_in">stack</span>-&gt;dataStack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(GetMinStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>-&gt;dataStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getTopElement(<span class="built_in">stack</span>-&gt;helpStack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GetMinStack *<span class="built_in">stack</span>;</span><br><span class="line">    initGetMinStack(<span class="built_in">stack</span>);</span><br><span class="line">    push(<span class="number">6</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, getMin(<span class="built_in">stack</span>));<span class="comment">//6</span></span><br><span class="line">    push(<span class="number">3</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, getMin(<span class="built_in">stack</span>));<span class="comment">//3</span></span><br><span class="line">    push(<span class="number">1</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, getMin(<span class="built_in">stack</span>));<span class="comment">//1</span></span><br><span class="line">  	pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, getMin(<span class="built_in">stack</span>));<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仅用队列结构实现栈结构"><a href="#仅用队列结构实现栈结构" class="headerlink" title="仅用队列结构实现栈结构"></a>仅用队列结构实现栈结构</h3><blockquote>
<p>思路：只要将关注点放在 <strong>后进先出</strong> 这个特性就不难实现了。使用一个数据队列和辅助队列，当放入数据时使用队列的操作正常向数据队列中放，但出队元素时，需将数据队列的前n-1个数入队辅助队列，而将数据队列的队尾元素弹出来，最后数据队列和辅助队列交换角色。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ArrayCircleQueue.cpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleQueueStack</span>&#123;</span></span><br><span class="line">    ArrayCircleQueue* dataQ;</span><br><span class="line">    ArrayCircleQueue* helpQ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(DoubleQueueStack* &amp;<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> = (DoubleQueueStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleQueueStack));</span><br><span class="line">    init(<span class="built_in">stack</span>-&gt;dataQ);</span><br><span class="line">    init(<span class="built_in">stack</span>-&gt;helpQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(ArrayCircleQueue *&amp;dataQ, ArrayCircleQueue *&amp;helpQ)</span></span>&#123;</span><br><span class="line">    ArrayCircleQueue* temp = dataQ;</span><br><span class="line">    dataQ = helpQ;</span><br><span class="line">    helpQ = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i,DoubleQueueStack* <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">stack</span>-&gt;dataQ)) &#123;</span><br><span class="line">        <span class="keyword">return</span> enQueue(i, <span class="built_in">stack</span>-&gt;dataQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(DoubleQueueStack* <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>-&gt;dataQ)) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = deQueue(<span class="built_in">stack</span>-&gt;dataQ);</span><br><span class="line">        <span class="keyword">while</span> (!isEmpty(<span class="built_in">stack</span>-&gt;dataQ)) &#123;</span><br><span class="line">            enQueue(i, <span class="built_in">stack</span>-&gt;helpQ);</span><br><span class="line">            i = deQueue(<span class="built_in">stack</span>-&gt;dataQ);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">stack</span>-&gt;dataQ, <span class="built_in">stack</span>-&gt;helpQ);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(DoubleQueueStack* <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isEmpty(<span class="built_in">stack</span>-&gt;dataQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTopElement</span><span class="params">(DoubleQueueStack* <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>-&gt;dataQ)) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = deQueue(<span class="built_in">stack</span>-&gt;dataQ);</span><br><span class="line">        <span class="keyword">while</span> (!isEmpty(<span class="built_in">stack</span>-&gt;dataQ)) &#123;</span><br><span class="line">            enQueue(i, <span class="built_in">stack</span>-&gt;helpQ);</span><br><span class="line">            i = deQueue(<span class="built_in">stack</span>-&gt;dataQ);</span><br><span class="line">        &#125;</span><br><span class="line">        enQueue(i, <span class="built_in">stack</span>-&gt;helpQ);</span><br><span class="line">        swap(<span class="built_in">stack</span>-&gt;dataQ, <span class="built_in">stack</span>-&gt;helpQ);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    DoubleQueueStack *<span class="built_in">stack</span>;</span><br><span class="line">    init(<span class="built_in">stack</span>);</span><br><span class="line">    push(<span class="number">1</span>, <span class="built_in">stack</span>);</span><br><span class="line">    push(<span class="number">2</span>, <span class="built_in">stack</span>);</span><br><span class="line">    push(<span class="number">3</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pop(<span class="built_in">stack</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    push(<span class="number">4</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, getTopElement(<span class="built_in">stack</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仅用栈结构实现队列结构"><a href="#仅用栈结构实现队列结构" class="headerlink" title="仅用栈结构实现队列结构"></a>仅用栈结构实现队列结构</h3><blockquote>
<p>思路：使用两个栈，一个栈<code>PutStack</code>用来放数据，一个栈<code>GetStack</code>用来取数据。取数据时，如果<code>GetStack</code>为空则需要将<code>PutStack</code>中的<strong>所有元素</strong>一次性依次<code>pop</code>并放入<code>GetStack</code>。</p>
<p>特别要注意的是这个 <strong>倒数据</strong>的时机：</p>
<ul>
<li>只有当<code>GetStack</code>为空时才能往里倒</li>
<li><strong>倒数据</strong>时必须一次性将<code>PutStack</code>中的数据倒完</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleStackQueue</span>&#123;</span></span><br><span class="line">    ArrayStack* putStack;</span><br><span class="line">    ArrayStack* getStack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(DoubleStackQueue *&amp;<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> = (DoubleStackQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleStackQueue));</span><br><span class="line">    init(<span class="built_in">queue</span>-&gt;putStack);</span><br><span class="line">    init(<span class="built_in">queue</span>-&gt;getStack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(DoubleStackQueue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isEmpty(<span class="built_in">queue</span>-&gt;getStack) &amp;&amp; isEmpty(<span class="built_in">queue</span>-&gt;putStack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pour</span><span class="params">(ArrayStack *stack1, ArrayStack *stack2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(stack1)) &#123;</span><br><span class="line">        push(pop(stack1), stack2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> i, DoubleStackQueue *<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">queue</span>-&gt;putStack)) &#123;</span><br><span class="line">        push(i, <span class="built_in">queue</span>-&gt;putStack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>-&gt;getStack)) &#123;</span><br><span class="line">            pour(<span class="built_in">queue</span>-&gt;putStack, <span class="built_in">queue</span>-&gt;getStack);</span><br><span class="line">            push(i, <span class="built_in">queue</span>-&gt;putStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(DoubleStackQueue* <span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">queue</span>-&gt;getStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> pop(<span class="built_in">queue</span>-&gt;getStack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty(<span class="built_in">queue</span>-&gt;putStack)) &#123;</span><br><span class="line">            pour(<span class="built_in">queue</span>-&gt;putStack, <span class="built_in">queue</span>-&gt;getStack);</span><br><span class="line">            <span class="keyword">return</span> pop(<span class="built_in">queue</span>-&gt;getStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DoubleStackQueue *<span class="built_in">queue</span>;</span><br><span class="line">    init(<span class="built_in">queue</span>);</span><br><span class="line">    enQueue(<span class="number">1</span>, <span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, deQueue(<span class="built_in">queue</span>));</span><br><span class="line">    enQueue(<span class="number">2</span>, <span class="built_in">queue</span>);</span><br><span class="line">    enQueue(<span class="number">3</span>, <span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, deQueue(<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="实现二叉树的先序、中序、后续遍历，包括递归方式和非递归方式"><a href="#实现二叉树的先序、中序、后续遍历，包括递归方式和非递归方式" class="headerlink" title="实现二叉树的先序、中序、后续遍历，包括递归方式和非递归方式"></a>实现二叉树的先序、中序、后续遍历，包括递归方式和非递归方式</h3><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  Node left;</span><br><span class="line">  Node right;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecursive</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.print(root.data+<span class="string">" "</span>);</span><br><span class="line">    preOrderRecursive(root.left);</span><br><span class="line">    preOrderRecursive(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">medOrderRecursive</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">    medOrderRecursive(root.left);</span><br><span class="line">    System.out.print(root.data+<span class="string">" "</span>);</span><br><span class="line">    medOrderRecursive(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderRecursive</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">    postOrderRecursive(root.left);</span><br><span class="line">    postOrderRecursive(root.right);</span><br><span class="line">    System.out.print(root.data+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">  root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">  root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">  root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">  root.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">  root.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">  root.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">  preOrderRecursive(root);	<span class="comment">//1 2 4 5 3 6 7</span></span><br><span class="line">  System.out.println();</span><br><span class="line">  medOrderRecursive(root);	<span class="comment">//4 2 5 1 6 3 7 </span></span><br><span class="line">  System.out.println();</span><br><span class="line">  postOrderRecursive(root);	<span class="comment">//4 5 2 6 7 3 1 </span></span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以先根遍历二叉树为例，可以发现递归方式首先尝试打印当前结点的值，随后尝试打印左子树，打印完左子树后尝试打印右子树，递归过程的<code>base case</code>是当某个结点为空时停止子过程的展开。这种递归尝试是由二叉树本身的结构所决定的，因为二叉树上的任意结点都可看做一棵二叉树的根结点（即使是叶子结点，也可以看做是一棵左右子树为空的二叉树根结点）。</p>
<p>观察先序、中序、后序三个递归方法你会发现，不同点在于打印当前结点的值这一操作的时机。<strong>你会发现每个结点会被访问三次</strong>：进入方法时算一次、递归处理左子树完成之后返回时算一次、递归处理右子树完成之后返回时算一次。因此在<code>preOrderRecursive</code>中将打印语句放到方法开始时就产生了先序遍历；在<code>midOrderRecursive</code>中，将打印语句放到递归chu处理左子树完成之后就产生了中序遍历。</p>
<h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>拿到一棵树的根结点后，首先打印该结点的值，然后将其非空右孩子、非空左孩子依次压栈。栈非空循环：从栈顶弹出结点（一棵子树的根节点）并打印其值，再将其非空右孩子、非空左孩子依次压栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  stack.push(root);</span><br><span class="line">  Node cur;</span><br><span class="line">  <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">    cur = stack.pop();</span><br><span class="line">    System.out.print(cur.data+<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现压栈的顺序和打印的顺序是相反的，压栈是先根结点，然后有右孩子就压右孩子、有左孩子就压左孩子，这是利用栈的后进先出。每次获取到一棵子树的根节点之后就可以获取其左右孩子，因此无需保留其信息，直接弹出并打印，然后保留其左右孩子到栈中即可。</p>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>对于一棵树，将该树的左边界全部压栈，<code>root</code>的走向是只要左孩子不为空就走向左孩子。当左孩子为空时弹出栈顶结点（此时该结点是一棵左子树为空的树的根结点，根据中序遍历可以直接打印该结点，然后中序遍历该结点的右子树）打印，如果该结点的右孩子非空（说明有右子树），那么将其右孩子压栈，这个右孩子又可能是一棵子树的根节点，因此将这棵子树的左边界压栈，这时回到了开头，以此类推。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">medOrderUnRecur</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (!stack.empty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root = stack.pop();</span><br><span class="line">      System.out.print(root.data+<span class="string">" "</span>);</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><blockquote>
<p>思路一：准备两个栈，一个栈用来保存遍历时的结点信息，另一个栈用来排列后根顺序（根节点先进栈，右孩子再进，左孩子最后进）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderUnRecur1</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Stack&lt;Node&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  Stack&lt;Node&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  stack1.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">    root = stack1.pop();</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack1.push(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack1.push(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    stack2.push(root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">    System.out.print(stack2.pop().data + <span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路二：只用一个栈。借助两个变量<code>h</code>和<code>c</code>，<code>h</code>代表最近一次打印过的结点，<code>c</code>代表栈顶结点。首先将根结点压栈，此后栈非空循环，令<code>c</code>等于栈顶元素（<code>c=stack.peek()</code>）执行以下三个分支：</p>
<ol>
<li><code>c</code>的左右孩子是否与<code>h</code>相等，如果都不相等，说明<code>c</code>的左右孩子都不是最近打印过的结点，由于左右孩子是左右子树的根节点，根据后根遍历的特点，左右子树肯定都没打印过，那么将左孩子压栈（打印左子树）。</li>
<li>分支1没有执行说明<code>c</code>的左孩子要么不存在；要么左子树刚打印过了；要么右子树刚打印过了。这时如果是前两种情况中的一种，那就轮到打印右子树了，因此如果<code>c</code>的右孩子非空就压栈。</li>
<li>如果前两个分支都没执行，说明<code>c</code>的左右子树都打印完了，因此弹出并打印<code>c</code>结点，更新一下<code>h</code>。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderUnRecur2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node h = <span class="keyword">null</span>;  <span class="comment">//最近一次打印的结点</span></span><br><span class="line">  Node c = <span class="keyword">null</span>;  <span class="comment">//代表栈顶结点</span></span><br><span class="line">  Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">    c = stack.peek();</span><br><span class="line">    <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; c.left != h &amp;&amp; c.right != h) &#123;</span><br><span class="line">      stack.push(c.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; c.right != h) &#123;</span><br><span class="line">      stack.push(c.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.print(stack.pop().data + <span class="string">" "</span>);</span><br><span class="line">      h = c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在二叉树中找一个结点的后继结点，结点除lleft-right指针外还包含一个parent指针"><a href="#在二叉树中找一个结点的后继结点，结点除lleft-right指针外还包含一个parent指针" class="headerlink" title="在二叉树中找一个结点的后继结点，结点除lleft,right指针外还包含一个parent指针"></a>在二叉树中找一个结点的后继结点，结点除lleft,right指针外还包含一个parent指针</h3><blockquote>
<p>这里的后继结点不同于链表的后继结点。在二叉树中，前驱结点和后继结点是按照二叉树中两个结点被中序遍历的先后顺序来划分的。比如某二叉树的中序遍历是<code>2 1 3</code>，那么<code>1</code>的后继结点是<code>3</code>，前驱结点是<code>2</code></p>
</blockquote>
<p>你当然可以将二叉树中序遍历一下，在遍历到该结点的时候标记一下，那么下一个要打印的结点就是该结点的后继结点。</p>
<p>我们可以推测一下，当我们来到二叉树中的某个结点时，如果它的右子树非空，那么它的后继结点一定是它的右子树中最靠左的那个结点；如果它的右孩子为空，那么它的后继结点一定是它的祖先结点中，把它当做左子孙（它存在于祖先结点的左子树中）的那一个，否则它没有后继结点。</p>
<p>这里如果它的右孩子为空的情况比较难分析，我们可以借助一个指针<code>parent</code>，当前来到的结点<code>node</code>和其父结点<code>parent</code>的<code>parent.left</code>比较，如果相同则直接返回<code>parent</code>，否则<code>node</code>来到<code>parent</code>的位置，<code>parent</code>则继续向上追溯，直到<code>parent</code>到达根节点为止若<code>node</code>还是不等于<code>parent</code>的左孩子，则返回<code>null</code>表明给出的结点没有后继结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindSuccessorNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        Node parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">findSuccessorNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node parent = node.parent;</span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = parent.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent == <span class="keyword">null</span> ? <span class="keyword">null</span> : parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        root.left.parent = root;</span><br><span class="line">        root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        root.left.left.parent = root.left;</span><br><span class="line">        root.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        root.left.right.parent = root.left;</span><br><span class="line">        root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        root.right.parent = root;</span><br><span class="line">        root.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        root.right.right.parent = root.right;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (findSuccessorNode(root.left.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"node5's successor node is:"</span>+findSuccessorNode(root.left.right).data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"node5's successor node doesn't exist"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findSuccessorNode(root.right.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"node6's successor node is:"</span>+findSuccessorNode(root.right.right).data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"node6's successor node doesn't exist"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="介绍二叉树的序列化和反序列化"><a href="#介绍二叉树的序列化和反序列化" class="headerlink" title="介绍二叉树的序列化和反序列化"></a>介绍二叉树的序列化和反序列化</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><blockquote>
<p>二叉树的序列化要注意的两个点如下：</p>
<ol>
<li>每序列化一个结点数值之后都应该加上一个结束符表示一个结点序列化的终止，如<code>!</code>。</li>
<li>不能忽视空结点的存在，可以使用一个占位符如<code>#</code>表示空结点的序列化。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先根遍历的方式进行序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  序列化来到了哪个结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serializeByPre</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//收集以当前结点为根节点的树的序列化信息</span></span><br><span class="line">  String res = node.data + <span class="string">"!"</span>;</span><br><span class="line">  <span class="comment">//假设能够获取左子树的序列化结果</span></span><br><span class="line">  res += serializeByPre(node.left);</span><br><span class="line">  <span class="comment">//假设能够获取右子树的序列化结果</span></span><br><span class="line">  res += serializeByPre(node.right);</span><br><span class="line">  <span class="comment">//返回以当前结点为根节点的树的序列化结果</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">  root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">  root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">  root.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">  root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">  root.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(serializeByPre(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h4><blockquote>
<p>怎么序列化的，就怎么反序列化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconstrut</span><span class="params">(String serializeStr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (serializeStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String[] datas = serializeStr.split(<span class="string">"!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (datas.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//借助队列保存结点数值</span></span><br><span class="line">      Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (String data : datas) &#123;</span><br><span class="line">        queue.offer(data);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> recon(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">recon</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//依次出队元素重建结点</span></span><br><span class="line">  String data = queue.poll();</span><br><span class="line">  <span class="comment">//重建空结点，也是base case，当要重建的某棵子树为空时直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (data.equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重建头结点</span></span><br><span class="line">  Node root = <span class="keyword">new</span> Node(Integer.parseInt(data));</span><br><span class="line">  <span class="comment">//重建左右子树</span></span><br><span class="line">  root.left = recon(queue);</span><br><span class="line">  root.right = recon(queue);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">  root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">  root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">  root.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">  root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">  root.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  String str = serializeByPre(root);</span><br><span class="line">  Node root2 = reconstrut(str);</span><br><span class="line">  System.out.println(serializeByPre(root2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断一个树是否是平衡二叉树"><a href="#判断一个树是否是平衡二叉树" class="headerlink" title="判断一个树是否是平衡二叉树"></a>判断一个树是否是平衡二叉树</h3><blockquote>
<p>平衡二叉树的定义：当二叉树的任意一棵子树的左子树的高度和右子树的高度相差不超过1时，该二叉树为平衡二叉树。</p>
</blockquote>
<p>根据定义可知，要确认一个二叉树是否是平衡二叉树势必要遍历所有结点。而遍历到每个结点时，要想知道以该结点为根结点的子树是否是平衡二叉树，我们要收集两个信息：</p>
<ol>
<li>该结点的左子树、右子树是否是平衡二叉树</li>
<li>左右子树的高度分别是多少，相差是否超过1</li>
</ol>
<p>那么我们来到某个结点时（子过程），我们需要向上层（父过程）返回的信息就是该结点为根结点的树是否是平衡二叉树以及该结点的高度，这样的话，父过程就能继续向上层返回应该收集的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为平衡二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalanceBTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历时，来到某个结点需要收集的信息</span></span><br><span class="line"><span class="comment">     * 1、以该结点为根节点的树是否是平衡二叉树</span></span><br><span class="line"><span class="comment">     * 2、该结点的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">boolean</span> isBalanced, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isBalanced = isBalanced;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">isBalancedBinaryTree</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ReturnData leftData = isBalancedBinaryTree(node.left);</span><br><span class="line">        <span class="keyword">if</span> (leftData.isBalanced == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="comment">//只要有一棵子树不是平衡二叉树，则会一路返回false，该树的高度自然不必收集了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ReturnData rightDta = isBalancedBinaryTree(node.right);</span><br><span class="line">        <span class="keyword">if</span> (rightDta.isBalanced == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回该层收集的结果</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(leftData.height - rightDta.height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若是平衡二叉树，树高等于左右子树较高的那个加1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, Math.max(leftData.height, rightDta.height) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        root.right.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        System.out.println(isBalancedBinaryTree(root).isBalanced);	<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归很好用，该题中的递归用法也是一种经典用法，可以高度套路：</p>
<ol>
<li>分析问题的解决需要哪些步骤（这里是遍历每个结点，确认每个结点为根节点的子树是否为平衡二叉树）</li>
<li>确定递归：父问题是否和子问题相同</li>
<li>子过程要收集哪些信息</li>
<li>本次递归如何利用子过程返回的信息得到本过程要返回的信息</li>
<li><code>base case</code></li>
</ol>
</blockquote>
<h3 id="判断一棵树是否是搜索二叉树"><a href="#判断一棵树是否是搜索二叉树" class="headerlink" title="判断一棵树是否是搜索二叉树"></a>判断一棵树是否是搜索二叉树</h3><blockquote>
<p>搜索二叉树的定义：对于二叉树的任意一棵子树，其左子树上的所有结点的值小于该子树的根节点的值，而其右子树上的所有结点的值大于该子树的根结点的值，并且整棵树上任意两个结点的值不同。</p>
</blockquote>
<p>根据定义，搜索二叉树的中序遍历打印将是一个升序序列。因此我们可以利用二叉树的中序遍历的非递归方式，比较中序遍历时相邻两个结点的大小，只要有一个结点的值小于其后继结点的那就不是搜索二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是搜索二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> preData = Integer.MIN_VALUE;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node node = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (node.data &lt; preData) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    preData = node.data;</span><br><span class="line">                &#125;</span><br><span class="line">                root = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> Node(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(isBST(root));	<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断一棵树是否是完全二叉树"><a href="#判断一棵树是否是完全二叉树" class="headerlink" title="判断一棵树是否是完全二叉树"></a>判断一棵树是否是完全二叉树</h3><p>根据完全二叉树的定义，如果二叉树上某个结点有右孩子无左孩子则一定不是完全二叉树；否则如果二叉树上某个结点有左孩子而没有右孩子，那么该结点所在的那一层上，该结点右侧的所有结点应该是叶子结点，否则不是完全二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为完全二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsCompleteBTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCompleteBTree</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            <span class="comment">//左空右不空</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//如果开启了叶子结点阶段，结点不能有左右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (leaf &amp;&amp;</span><br><span class="line">                    (node.left != <span class="keyword">null</span> || node.right != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将下一层要遍历的加入到队列中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//左右均为空，或左不空右空。该结点同层的右侧结点均为叶子结点，开启叶子结点阶段</span></span><br><span class="line">                leaf = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(isCompleteBTree(root));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知一棵完全二叉树，求其结点个数，要求时间复杂度0-N"><a href="#已知一棵完全二叉树，求其结点个数，要求时间复杂度0-N" class="headerlink" title="已知一棵完全二叉树，求其结点个数，要求时间复杂度0(N)"></a>已知一棵完全二叉树，求其结点个数，要求时间复杂度0(N)</h3><p>如果我们遍历二叉树的每个结点来计算结点个数，那么时间复杂度将是<code>O(N^2)</code>，我们可以利用满二叉树的结点个数为<code>2^h-1</code>（h为树的层数）来加速这个过程。</p>
<p>首先完全二叉树，如果其左子树的最左结点在树的最后一层，那么其右子树肯定是满二叉树，且高度为<code>h-1</code>；否则其左子树肯定是满二叉树，且高度为<code>h-2</code>。也就是说，对于一个完全二叉树结点个数的求解，我们可以分解求解过程：1个根结点+ 一棵满二叉树（高度为h-1或者h-2）+ 一棵完全二叉树（高度为h-1）。前两者的结点数是可求的（1+2^level -1=2^level），后者就又成了求一棵完全二叉树结点数的问题了，可以使用递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求一棵完全二叉树的节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CBTNodesNum</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取完全二叉树的高度</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLevelOfCBT</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      level++;</span><br><span class="line">      root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNodesNum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = getLevelOfCBT(node);</span><br><span class="line">    <span class="keyword">if</span> (getLevelOfCBT(node.right) == level - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 左子树满，且高度为 level-1；收集左子树节点数2^(level-1)-1和头节点，对右子树重复此过程</span></span><br><span class="line">      <span class="keyword">int</span> leftNodesAndRoot = <span class="number">1</span> &lt;&lt; (level - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> getNodesNum(node.right) + leftNodesAndRoot;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 右子树满，且高度为 level-2；收集右子树节点数2^(level-2)-1和头节点1,对左子树重复此过程</span></span><br><span class="line">      <span class="keyword">int</span> rightNodesAndRoot = <span class="number">1</span> &lt;&lt; (level - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> getNodesNum(node.left) + rightNodesAndRoot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    root.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    root.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">    root.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    root.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    root.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">    root.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(getNodesNum(root));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><strong>并查集</strong>是一种树型的<a href="https://zh.wikipedia.org/wiki/数据结构" target="_blank" rel="noopener">数据结构</a>，用于处理一些<a href="https://zh.wikipedia.org/wiki/不交集" target="_blank" rel="noopener">不交集</a>（Disjoint Sets）的合并及查询问题。有一个<strong>联合-查找算法</strong>（<strong>union-find algorithm</strong>）定义了两个用于此数据结构的操作：</p>
<ul>
<li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
<li>Union：将两个子集合并成同一个集合。</li>
</ul>
<h3 id="并查集结构的实现"><a href="#并查集结构的实现" class="headerlink" title="并查集结构的实现"></a>并查集结构的实现</h3><p>首先并查集本身是一个结构，我们在构造它的时候需要将所有要操作的数据扔进去，初始时每个数据自成一个结点，且每个结点都有一个父指针（初始时指向自己）。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/union_find.png" alt></p>
<p>初始时并查集中的每个结点都算是一个子集，我们可以对任意两个元素进行合并操作。值得注意的是，<code>union(nodeA,nodeB)</code>并不是将结点<code>nodeA</code>和<code>nodeB</code>合并成一个集合，而是将<code>nodeA</code>所在的集合和<code>nodeB</code>所在的集合合并成一个新的子集：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/union_find1.png" alt></p>
<p>那么合并两个集合的逻辑是什么呢？首先要介绍一下<strong>代表结点</strong>这个概念：找一结点所在集合的代表结点就是找这个集合中父指针指向自己的结点（并查集初始化时，每个结点都是各自集合的代表结点）。那么合并两个集合就是将结点个数较少的那个集合的代表结点的父指针指向另一个集合的代表结点：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/union_find2.png" alt></p>
<p>还有一个<code>find</code>操作：查找两个结点是否所属同一个集合。我们只需判断两个结点所在集合的代表结点是否是同一个就可以了：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/union_find3.png" alt></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		<span class="comment">//whatever you like to store   int , char , String ..etc</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Node,Node&gt; fatherMap;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Node,Integer&gt; nodesNumMap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//give me the all nodes need to save into the UnionFindSet</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line">		fatherMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">		nodesNumMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">		<span class="keyword">for</span>(Node node : nodes)&#123;</span><br><span class="line">			fatherMap.put(node,node);</span><br><span class="line">			nodesNumMap.put(node,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="keyword">null</span> || b == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node rootOfA = getRoot(a);</span><br><span class="line">		Node rootOfB = getRoot(b);</span><br><span class="line">		<span class="keyword">if</span>(rootOfA != rootOfB)&#123;</span><br><span class="line">			<span class="keyword">int</span> numOfA = nodesNumMap.get(rootOfA);</span><br><span class="line">			<span class="keyword">int</span> numOfB = nodesNumMap.get(rootOfB);</span><br><span class="line">			<span class="keyword">if</span>(numOfA &gt;= numOfB)&#123;</span><br><span class="line">				fatherMap.put(rootOfB , rootOfA);</span><br><span class="line">				nodesNumMap.put(rootOfA, numOfA + numOfB);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				fatherMap.put(rootOfA , rootOfB);</span><br><span class="line">				nodesNumMap.put(rootOfB, numOfA + numOfB);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="keyword">null</span> || b == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node rootOfA = getRoot(a);</span><br><span class="line">		Node rootOfB = getRoot(b);</span><br><span class="line">		<span class="keyword">return</span> rootOfA == rootOfB ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node father = fatherMap.get(node);</span><br><span class="line">		<span class="keyword">if</span>(father != node)&#123;</span><br><span class="line">			father = fatherMap.get(father);</span><br><span class="line">		&#125;</span><br><span class="line">		fatherMap.put(node, father);</span><br><span class="line">		<span class="keyword">return</span> father;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Node a = <span class="keyword">new</span> Node();</span><br><span class="line">		Node b = <span class="keyword">new</span> Node();</span><br><span class="line">		Node c = <span class="keyword">new</span> Node();</span><br><span class="line">		Node d = <span class="keyword">new</span> Node();</span><br><span class="line">		Node e = <span class="keyword">new</span> Node();</span><br><span class="line">		Node f = <span class="keyword">new</span> Node();</span><br><span class="line">		Node[] nodes = &#123;a,b,c,d,e,f&#125;;</span><br><span class="line"></span><br><span class="line">		UnionFindSet set = <span class="keyword">new</span> UnionFindSet(Arrays.asList(nodes));</span><br><span class="line">		set.union(a, b);</span><br><span class="line">		set.union(c, d);</span><br><span class="line">		set.union(b, e);</span><br><span class="line">		set.union(a, c);</span><br><span class="line">		System.out.println(set.find(d,e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现<code>union</code>和<code>find</code>的过程中都会有找一个结点所在集合的代表结点这个过程，所以我把它单独抽出来成一个<code>getRoot</code>，而且利用递归做了一个优化：找一个结点所在集合的代表结点时，会不停地向上找父指针指向自己的结点，最后在递归回退时将沿途路过的结点的父指针改为直接指向代表结点：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/union_find4.png" alt></p>
<p>诚然，这样做是为了提高下一次查找的效率。</p>
<h3 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h3><p>并查集结构本身其实很简单，但是其应用却很难。这里以<strong>岛问题</strong>做引子，当矩阵相当大的时候，用单核CPU去跑这个遍历和感染效率是很低的，可能会使用并行计算框架来完成岛数量的统计。也就是说矩阵可能被分割成几个部分，逐个统计，最后在汇总。那么问题来了：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/island.png" alt></p>
<p>上面这个矩阵的岛数量是1；但如果从中间竖着切开，那么左边的岛数量是1，右边的岛数量是2，总数是3。如何处理切割后，相邻子矩阵之间的边界处的1相邻导致的重复统计呢？其实利用并查集的特性就很容易解决这个问题：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/island1.png" alt></p>
<p>首先将切割边界处的数据封装成结点加入到并查集中并合并同一个岛上的结点，在分析边界时，查边界两边的1是否在同一个集合，如果不在那就<code>union</code>这两个结点，并将总的岛数量减1；否则就跳过此行继续分析下一行边界上的两个点。</p>
]]></content>
      <categories>
        <category>左神算法</category>
        <category>经典结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法班笔记-排序</title>
    <url>/2020/03/10/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%8F%AD%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置，接下来只需对剩下的（n-1）个元素，重复上述操作即可。</p><a id="more"></a>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/bubbleSort.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr==<span class="literal">NULL</span> || length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;	<span class="comment">//只需比较(length-1)轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度为<code>n+(n-1)+...+1</code>，很明显是一个等差数列，由（首项+末项）*项数/2求其和为<code>(n+1)n/2</code>，可知时间复杂度为<code>O(n^2)</code></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>以升序排序为例：找到最小数的下标<code>minIndex</code>，将其与第一个数交换，接着对子序列（1-n）重复该操作，直到子序列只含一个元素为止。(即选出最小的数放到第一个位置，该数安排好了，再对剩下的数选出最小的放到第二个位置，以此类推）</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/selectSort.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; ++i) &#123;    <span class="comment">//要进行n-1次选择，选出n-1个数分别放在前n-1个位置上</span></span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="literal">NULL</span> || length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minIndex = i;	<span class="comment">//记录较小数的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">      swap(&amp;arr[minIndex],&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，不难得出该算法的时间复杂度（big o）为<code>O(n^2)</code>（n-1+n-2+n-3+…+1）</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的过程可以联想到打扑克时揭一张牌然后将其到手中有序纸牌的合适位置上。比如我现在手上的牌是7、8、9、J、Q、K，这时揭了一张10，我需要将其依次与K、Q、J、9、8、7比较，当比到9时发现大于9，于是将其插入到9之后。对于一个无序序列，可以将其当做一摞待揭的牌，首先将首元素揭起来，因为揭之前手上无牌，因此此次揭牌无需比较，此后每揭一次牌都需要进行上述的插牌过程，当揭完之后，手上的握牌顺序就对应着该序列的有序形式。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/insertSort.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="literal">NULL</span> || length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;		<span class="comment">//第一张牌无需插入，直接入手，后续揭牌需比较然后插入，因此从第二个元素开始遍历（插牌）</span></span><br><span class="line">      	<span class="comment">//将新揭的牌与手上的逐次比较，若小于则交换，否则停止，比较完了还没遇到更小的也停止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> || arr[j] &lt;= arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序的big o该如何计算？可以发现如果序列有序，那么该算法的big o为<code>O(n)</code>，因为只是遍历了一次序列（这时最好情况）；如果序列降序排列，那么该算法的big o为<code>O(n^2)</code>（每次插入前的比较交换加起来要：1+2+…+n-1）（最坏情况）。<strong>一般应用场景中都是按算法的最坏情况来考量算法的效率的，因为你做出来的应用要能够承受最坏情况。</strong>即该算法的big o为<code>O(n^2)</code></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的核心思想是先让序列的左半部分有序、再让序列的右半部分有序，最后从两个子序列（左右两半）从头开始逐次比较，往辅助序列中填较小的数。</p>
<p>以序列<code>{2,1,4,3}</code>为例，归并排序的过程大致如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/mergeSort.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> helpArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = startIndex, R = midIndex + <span class="number">1</span>, i = startIndex;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= midIndex &amp;&amp; R &lt;= endIndex) &#123; <span class="comment">//只要没有指针没越界就逐次比较</span></span><br><span class="line">        helpArr[i++] = arr[L] &lt; arr[R] ? arr[L++] : arr[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (L != midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">        helpArr[i++] = arr[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (R != endIndex + <span class="number">1</span>) &#123;</span><br><span class="line">        helpArr[i++] = arr[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        arr[i] = helpArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> helpArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &lt; endIndex) &#123;  <span class="comment">//当子序列只含一个元素时，不再进行此子过程</span></span><br><span class="line">      	<span class="comment">//(endIndex+startIndex)/2可能会导致int溢出，下面求中位数的做法更安全</span></span><br><span class="line">        midIndex = startIndex + ((endIndex - startIndex) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(arr, helpArr, startIndex, midIndex);        <span class="comment">//对左半部分排序</span></span><br><span class="line">        mergeSort(arr, helpArr, midIndex + <span class="number">1</span>, endIndex);      <span class="comment">//对右半部分排序</span></span><br><span class="line">        merge(arr, helpArr, startIndex, midIndex, endIndex);  <span class="comment">//使整体有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    travels(arr, <span class="number">7</span>);<span class="comment">//遍历打印</span></span><br><span class="line">    <span class="keyword">int</span> helpArr[<span class="number">7</span>];</span><br><span class="line">    mergeSort(arr, helpArr, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    travels(arr, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此算法的核心就是第<code>24、25、26</code>这三行。第<code>26</code>行应该不难理解，就是使用两个指针<code>L、R</code>外加一个辅助数组，将两个序列有序地<strong>并入</strong>辅助数组。但为什么<code>24、25</code>行执行过后数组左右两半部分就分别有序了呢？这就又牵扯到了归并排序的核心思想：先让一个序列左右两半部分有序，然后再并入使整体有序。因此<code>24、25</code>是对左右两半部分分别递归执行归并排序，直到某次递归时左右两半部分均为一个元素时递归终止。当一个序列只含两个元素时，调用<code>mergeSort</code>会发现<code>24、25</code>行是无效操作，直接执行<code>merge</code>。就像上图所示，两行递归完毕后，左右两半部分都会变得有序。</p>
<blockquote>
<p>当一个递归过程比较复杂时（不像递归求阶乘那样一幕了然），我们可以列举简短样本进行分析。</p>
<p>对于这样复杂的递归行为，千万不要想着追溯整个递归过程，只需分析第一步要做的事（比如此例中第一步要做的是就是<code>mergeSort</code>函数所呈现出来的那样：对左半部分排序、对右半部分排序、最后并入，你先不管是怎么排序的，不要被24、25行的<code>mergeSort</code>给带进去了）和递归终止的条件（比如此例中是``startIndex&gt;=endIndex`，即要排序的序列只有一个元素时）。</p>
</blockquote>
<p>归并排序的时间复杂度是<code>O(nlogn)</code>，额外空间复杂度是<code>O(n)</code>。</p>
<p>根据<strong>Master公式</strong>（本文 <strong>小技巧</strong>一节中有讲到）可得<code>T(n)=2T(n/2)+O(n)</code>，第一个2的含义是子过程（对子序列进行归并排序）要执行两次，第二个2的含义是子过程样本量占一半（因为分成了左右两半部分），最后<code>O(n)</code>表示左右有序之后进行的并入操作为<code>O(n+n)=O(n)</code>(L、R指针移动次数总和为n，将辅助数组覆盖源数组为n)，符合<code>T(n)=aT(n/b)+O(n^d)</code>，经计算该算法的时间复杂度为<code>O(nlogn)</code></p>
<h4 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h4><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于数组[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="number">1</span>左边比<span class="number">1</span>小的数，没有；</span><br><span class="line"><span class="number">3</span>左边比<span class="number">3</span>小的数，<span class="number">1</span>；</span><br><span class="line"><span class="number">4</span>左边比<span class="number">4</span>小的数，<span class="number">1</span>、<span class="number">3</span>；</span><br><span class="line"><span class="number">2</span>左边比<span class="number">2</span>小的数，<span class="number">1</span>；</span><br><span class="line"><span class="number">5</span>左边比<span class="number">5</span>小的数，<span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">2</span>；</span><br><span class="line">所以小和为<span class="number">1</span>+<span class="number">1</span>+<span class="number">3</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">2</span>=<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>简单的做法就是遍历一遍数组，将当前遍历的数与该数之前数比较并记录小于该数的数。易知其时间复杂度为<code>O(n^2)</code>（0+1+2+……+n-1）。</p>
<p>更优化的做法是利用归并排序的<strong>并入逻辑</strong>：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/min_sum.png" alt></p>
<p>对应代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> helpArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = startIndex, R = midIndex + <span class="number">1</span>, i = startIndex;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= midIndex &amp;&amp; R &lt;= endIndex ) &#123; <span class="comment">//只要没有指针没越界就逐次比较</span></span><br><span class="line">        res += arr[L] &lt; arr[R] ? arr[L] * (endIndex - R + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        helpArr[i++] = arr[L] &lt; arr[R] ? arr[L++] : arr[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (L != midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">        helpArr[i++] = arr[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (R != endIndex + <span class="number">1</span>) &#123;</span><br><span class="line">        helpArr[i++] = arr[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        arr[i] = helpArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> helpArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &lt; endIndex) &#123;  <span class="comment">//当子序列只含一个元素时，不再进行此子过程</span></span><br><span class="line">        midIndex = startIndex + ((endIndex - startIndex) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeSort(arr, helpArr, startIndex, midIndex) +        <span class="comment">//对左半部分排序</span></span><br><span class="line">               mergeSort(arr, helpArr, midIndex + <span class="number">1</span>, endIndex) +     <span class="comment">//对右半部分排序</span></span><br><span class="line">               merge(arr, helpArr, startIndex, midIndex, endIndex);  <span class="comment">//使整体有序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//一个元素时不存在小和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> helpArr[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"small_sum:%d\n"</span>,mergeSort(arr, helpArr, <span class="number">0</span>, <span class="number">4</span>)) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法在归并排序的基础上做了略微改动，即<code>merge</code>中添加了变量<code>res</code>记录每次<strong>并入</strong>操作应该累加的小和、<code>mergeSort</code>则将每次并入应该累加的小和汇总。此种做法的复杂度与归并排序的相同，优于遍历的做法。可以理解，依次求每个数的小和过程中有很多比较是重复的，而利用归并排序求小和时利用了并入的两个序列分别有序的特性省去了不必要的比较，如<code>134并入25</code>时，<code>2&gt;1</code>直接推出<code>2</code>后面的数都<code>&gt;1</code>，因此直接<code>1*(endIndex-indexOf(2)+1)</code>即可。这在样本量不大的情况下看不出来优化的效果，试想一下如果样本量为<code>2^32</code>，那么依照前者求小和<code>O(n^2)</code>可知时间复杂度为<code>O(21亿的平方)</code>，而归并排序求小和则只需<code>O(21亿*32)</code>，足以见得<code>O(n^2)</code>和<code>O(nlogn)</code>的优劣。</p>
<h4 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h4><p>在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。</p>
<blockquote>
<p>这题的思路也可以利用归并排序来解决，在并入操作时记录<code>arr[L]&gt;arr[R]</code>的情况即可。</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="经典快排"><a href="#经典快排" class="headerlink" title="经典快排"></a>经典快排</h4><p>经典快排就是将序列中比尾元素小的移动到序列左边，比尾元素大的移动到序列右边，对以该元素为界的左右两个子序列（均不包括该元素）重复此操作。</p>
<p>首先我们要考虑的是对给定的一个数，如何将序列中比该数小的移动到左边，比该数大的移动到右边。</p>
<blockquote>
<p>思路：利用一个辅助指针<code>small</code>，代表较小数的右边界（初始指向首元素前一个位置），遍历序列每次遇到比该数小的数就将其与<code>arr[small+1]</code>交换并右移<code>small</code>，最后将该数与<code>arr[small+1]</code>交换即达到目的。对应算法如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> small = startIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; endIndex; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[endIndex]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (small + <span class="number">1</span> != i) &#123;</span><br><span class="line">                swap(arr[++small], arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果small、i相邻则不用交换</span></span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[++small], arr[endIndex]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    travles(arr, <span class="number">8</span>);<span class="comment">//1 2 3 4 6 7 8 5</span></span><br><span class="line">    partition(arr, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    travles(arr, <span class="number">8</span>);<span class="comment">//1 2 3 4 5 7 8 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是快排的递归逻辑：对<code>1 2 3 4 6 7 8 5</code>序列<code>partition</code>之后，去除之前的比较参数<code>5</code>，对剩下的子序列<code>1234</code>和<code>786</code>继续<code>partition</code>，直到子序列为一个元素为止：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> small = startIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; endIndex; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[endIndex]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (small + <span class="number">1</span> != i) &#123;</span><br><span class="line">                swap(arr[++small], arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果small、i相邻则不用交换</span></span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[++small], arr[endIndex]);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = partition(arr, startIndex, endIndex);</span><br><span class="line">    quickSort(arr, startIndex, index - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, index + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    travles(arr, <span class="number">8</span>);	<span class="comment">//1 5 6 2 7 3 8 0</span></span><br><span class="line">    quickSort(arr, <span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    travles(arr, <span class="number">8</span>);	<span class="comment">//0 1 2 3 5 6 7 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典排序的时间复杂度与数据状况有关，如果<strong>每一次</strong><code>partition</code>时，尾元素都是序列中最大或最小的，那么去除该元素序列并未如我们划分为样本量相同的左右两个子序列，而是只安排好了一个元素（就是去掉的那个元素），这样的话时间复杂度就是<code>O(n-1+n-2+……+1)=O(n^2)</code>；但如果每一次<code>partition</code>时，都将序列分成了两个样本量相差无几的左右两个子序列，那么时间复杂度就是<code>O(nlogn)</code>（使用Master公式求解）。</p>
<h4 id="由荷兰国旗问题引发对经典快排的改进"><a href="#由荷兰国旗问题引发对经典快排的改进" class="headerlink" title="由荷兰国旗问题引发对经典快排的改进"></a>由荷兰国旗问题引发对经典快排的改进</h4><p>可以发现这里<code>partition</code>的过程与荷兰国旗问题中的<code>partition</code>十分相似，能否以后者的<code>partition</code>实现经典快排呢？我们来试一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123; ;</span><br><span class="line">    <span class="keyword">int</span> small = startIndex - <span class="number">1</span>, great = endIndex + <span class="number">1</span>, i = startIndex;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= great - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[endIndex]) &#123;</span><br><span class="line">            swap(arr[++small], arr[i++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; arr[endIndex])&#123;</span><br><span class="line">            swap(arr[--great], arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> range[] = &#123;small, great&#125;;</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* range = partition(arr, startIndex, endIndex);</span><br><span class="line">    quickSort(arr, startIndex, range[<span class="number">0</span>]);</span><br><span class="line">    quickSort(arr, range[<span class="number">1</span>], endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    travles(arr, <span class="number">8</span>);	<span class="comment">//1 5 6 2 7 3 8 0</span></span><br><span class="line">    quickSort(arr, <span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    travles(arr, <span class="number">8</span>);	<span class="comment">//0 1 2 3 5 6 7 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较一下经典排序和使用荷兰国旗问题改进后的经典排序，不难发现，后者一次<code>partition</code>能去除一个以上的元素（等于<code>arr[endIndex]</code>的区域），而前者每次<code>partition</code>只能去除一个元素，这里的去除相当于安排（排序）好了对应元素的位置。因此后者比经典排序更优，但是优化不大，只是常数时间内的优化，实质上的效率还是要看数据状况（最后的情况为<code>O(nlogn)</code>，最坏的情况为<code>O(n^2)</code>）。</p>
<h4 id="随机快排——O-nlogn"><a href="#随机快排——O-nlogn" class="headerlink" title="随机快排——O(nlogn)"></a>随机快排——O(nlogn)</h4><p>上面谈到了快排的短板是依赖数据状况，那么我们有没有办法消除这个依赖，让他成为真正的<code>O(nlogn)</code>呢？</p>
<blockquote>
<p>事实上，为了让算法中的操作不依托于数据状况（如快排中每一次<code>partition</code>取尾元素作为比较，这就没有规避样本的数据状况，如果尾元素是最大或最小值就成了最坏情况）常常有两种做法：</p>
<p>1、使用随机取数</p>
<p>2、将样本数据哈希打乱</p>
</blockquote>
<p>随机快排就是采用上了上述第一种解决方案，在每一轮的<code>partition</code>中随机选择序列中的一个数作为要比较的数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生[startIndex,endIndex]之间的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomInRange</span><span class="params">(<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % (endIndex - startIndex + <span class="number">1</span>) + startIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123; ;</span><br><span class="line">    <span class="keyword">int</span> small = startIndex - <span class="number">1</span>, great = endIndex + <span class="number">1</span>, i = startIndex;</span><br><span class="line">    <span class="keyword">int</span> randomNum = arr[randomInRange(startIndex, endIndex)];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= great - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; randomNum) &#123;</span><br><span class="line">            swap(arr[++small], arr[i++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; randomNum)&#123;</span><br><span class="line">            swap(arr[--great], arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> range[] = &#123;small, great&#125;;</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* range = partition(arr, startIndex, endIndex);</span><br><span class="line">    quickSort(arr, startIndex, range[<span class="number">0</span>]);</span><br><span class="line">    quickSort(arr, range[<span class="number">1</span>], endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travles</span><span class="params">(<span class="keyword">int</span> dataArr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, dataArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//此后调用rand()时将以调用时的时间为随机数种子</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    travles(arr, <span class="number">9</span>);</span><br><span class="line">    quickSort(arr, <span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line">    travles(arr, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察比较代码可以发现随机快排只不过是在<code>partition</code>时随机选出一个下标上的数作为比较对象，从而避免了每一轮选择尾元素会受数据状况的影响的问题。</p>
<blockquote>
<p>那么随机快排的时间复杂度又为多少呢？</p>
</blockquote>
<p>经数学论证，由于每一轮<code>partition</code>选出的作为比较对象的数是随机的，即序列中的每个数都有<code>1/n</code>的概率被选上，那么该算法时间复杂度为概率事件，经数学论证该算法的<strong>数学期望</strong>为<code>O(nlogn)</code>。虽然说是数学期望，但在实际工程中，常常就把随机快排的时间复杂度当做<code>O(nlog)</code>。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><p>堆结构就是将一颗<strong>完全二叉树</strong>映射到数组中的一种存储方式：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/heap.png" alt></p>
<h4 id="大根堆和小根堆"><a href="#大根堆和小根堆" class="headerlink" title="大根堆和小根堆"></a>大根堆和小根堆</h4><p>当堆的每一颗子树（包括树本身）的最大值就是其根结点时称为大根堆；相反，当堆的每一颗子树的最小值就是其根结点时称为小根堆。其中大根堆的应用较为广泛，是一种很重要的数据结构。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/heap1.png" alt></p>
<h4 id="heapInsert和heapify"><a href="#heapInsert和heapify" class="headerlink" title="heapInsert和heapify"></a>heapInsert和heapify</h4><p>大根堆最重要的两个操作就是<code>heapInsert</code>和<code>heapify</code>，前者是当一个元素加入到大根堆时应该自底向上与其父结点比较，若大于父结点则交换；后者是当堆中某个结点的数值发生变化时，应不断向下与其孩子结点中的最大值比较，若小于则交换。下面是对应的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index之前的序列符合大根堆排序，将index位置的元素加入堆结构，但不能破坏大根堆的特性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123; <span class="comment">//当该结点大于父结点时</span></span><br><span class="line">        swap(arr[index], arr[(index - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;    <span class="comment">//继续向上比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组中下标从0到heapSize符合大根堆排序</span></span><br><span class="line"><span class="comment">//index位置的值发生了变化，重新调整堆结构为大根堆</span></span><br><span class="line"><span class="comment">//heapSize指的是数组中符合大根堆排序的范围而不是数组长度,最大为数组长度，最小为0 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftChild = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftChild &lt; heapSize) &#123;  <span class="comment">//当该结点有左孩子时</span></span><br><span class="line">        <span class="keyword">int</span> greatOne = leftChild + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[leftChild + <span class="number">1</span>] &gt; arr[leftChild] ?</span><br><span class="line">                leftChild + <span class="number">1</span> : leftChild;  <span class="comment">//只有当右孩子存在且大于左孩子时，最大值是右孩子，否则是左孩子</span></span><br><span class="line">        greatOne = arr[greatOne] &gt; arr[index] ? greatOne : index;<span class="comment">//将父结点与最大孩子结点比较，确定最大值</span></span><br><span class="line">        <span class="keyword">if</span> (greatOne == index) &#123;</span><br><span class="line">            <span class="comment">//如果最大值是本身，则不用继续向下比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[index], arr[greatOne]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//next turn下一轮</span></span><br><span class="line">        index = greatOne;</span><br><span class="line">        leftChild = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立大根堆"><a href="#建立大根堆" class="headerlink" title="建立大根堆"></a>建立大根堆</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildBigRootHeap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用heapify排序"><a href="#利用heapify排序" class="headerlink" title="利用heapify排序"></a>利用heapify排序</h4><p>前面做了那么多铺垫都是为了建立大根堆，那么如何利用它来排序呢？</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/heapify.png" alt></p>
<p>对应代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//先建立大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line"> 	  <span class="comment">//循环弹出堆顶元素并heapify</span></span><br><span class="line">    <span class="keyword">int</span> heapSize = length;</span><br><span class="line">    swap(arr[<span class="number">0</span>], arr[--heapSize]);<span class="comment">//相当于弹出堆顶元素</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        heapify(arr, heapSize, <span class="number">0</span>);</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[--heapSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    heapSort(arr, <span class="number">9</span>);</span><br><span class="line">    travles(arr, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序的优势在于无论是入堆一个元素<code>heapInsert</code>还是出堆一个元素之后的<code>heapify</code>都不是将整个样本遍历一遍（<code>O(n)</code>级别的操作），而是树层次上的遍历（<code>O(logn)</code>级别的操作）。</p>
<p>这样的话堆排序过程中，建立堆的时间复杂度为<code>O(nlogn)</code>，循环弹出堆顶元素并<code>heapify</code>的时间复杂度为<code>O(nlogn)</code>，整个堆排序的时间复杂度为<code>O(nlogn)</code>，额外空间复杂度为<code>O(1)</code></p>
<blockquote>
<p>优先级队列结构（比如Java中的<code>PriorityQueue</code>）就是堆结构。</p>
</blockquote>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>排序算法的稳定性指的是排序前后是否维持值相同的元素在序列中的相对次序。如序列<code>271532</code>，在排序过程中如果能维持第一次出现的<code>2</code>在第二次出现的<code>2</code>的前面，那么该排序算法能够保证稳定性。首先我们来分析一下前面所讲排序算法的稳定性，再来谈谈稳定性的意义。</p>
<ul>
<li><strong>冒泡排序</strong>。可以保证稳定性，只需在比较相邻两个数时只在后一个数比前一个数大的情况下才交换位置即可。</li>
<li><strong>选择排序</strong>。无法保证稳定性，比如序列<code>926532</code>，在第一轮<code>maxIndex</code>的选择出来之后（<code>maxIndex=0</code>），第二次出现的<code>2</code>（尾元素）将与<code>9</code>交换位置，那么两个<code>2</code>的相对次序就发生了变化，而这个交换是否会影响稳定性在我们<code>coding</code>的时候是不可预测的。</li>
<li><strong>插入排序</strong>。可以保证稳定性，每次插入一个数到有序序列中时，遇到比它大的就替换，否则不替换。这样的话，值相同的元素，后面插入的就总在前面插入的后面了。</li>
<li><strong>归并排序</strong>。可以保证稳定性，在左右两半子序列排好序后的<code>merge</code>过程中，比较大小时如果相等，那么优先插入左子序列中的数。</li>
<li><strong>快排</strong>。不能保证稳定性，因为<code>partition</code>的过程会将比<code>num</code>小的与<code>small</code>区域的右一个数交换位置，将比<code>num</code>大的与<code>great</code>区域的左一个数交换位置，而<code>small</code>、<code>great</code>分居序列两侧，很容易打乱值相同元素的相对次序。</li>
<li><strong>堆排序</strong>。不能保证稳定性。二叉树如果交换位置的结点是相邻层次的可以保证稳定性，但堆排序中弹出堆顶元素后的<code>heapify</code>交换的是第一层的结点和最后一层的结点。</li>
</ul>
<p>维持稳定性一般是为了满足业务需求。假设下面是一张不同厂商下同一款产品的价格和销售情况表：</p>
<table>
<thead>
<tr>
<th align="left">品牌</th>
<th align="left">价格</th>
<th align="left">销量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">三星</td>
<td align="left">1603</td>
<td align="left">92</td>
</tr>
<tr>
<td align="left">小米</td>
<td align="left">1603</td>
<td align="left">74</td>
</tr>
<tr>
<td align="left">vivo</td>
<td align="left">1604</td>
<td align="left">92</td>
</tr>
</tbody></table>
<p>要求先按价格排序，再按销量排序。如果保证稳定性，那么排序后应该是这样的：</p>
<table>
<thead>
<tr>
<th align="left">品牌</th>
<th align="left">价格</th>
<th align="left">销量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">三星</td>
<td align="left">1603</td>
<td align="left">92</td>
</tr>
<tr>
<td align="left">vivo</td>
<td align="left">1604</td>
<td align="left">92</td>
</tr>
<tr>
<td align="left">小米</td>
<td align="left">1603</td>
<td align="left">74</td>
</tr>
</tbody></table>
<p>即按销量排序后，销量相同的两条记录会保持之前的按价格排序的状态，这样先前的价格排序这个工作就没白做。</p>
<h3 id="有关排序问题的补充"><a href="#有关排序问题的补充" class="headerlink" title="有关排序问题的补充"></a>有关排序问题的补充</h3><ol>
<li><strong>归并排序</strong>可以做到额外空间复杂度为<code>O(1)</code>，但是比较难，感兴趣的可以搜 <strong>归并排序 内部缓存法</strong></li>
<li><strong>快速排序</strong>可以做到保证稳定性，但是很难，可以搜<code>01 stable sort</code>（论文）</li>
<li>有一道题是：是奇数放到数组左边，是偶数放到数组右边，还要求奇数和奇数之间、偶数和偶数之间的原始相对次序不变。这道题和归并排序如出一辙，只不过归并排序是将<code>arr[length-1]</code>或<code>arr[randomIndex]</code>作为比较的标准，而这道题是将是否能整除2作为比较的标准，这类问题都同称为<code>o1 sort</code>，要使这类问题做到稳定性，要看<code>01 stable sort</code>这篇论文。</li>
</ol>
<h3 id="工程中的综合排序算法"><a href="#工程中的综合排序算法" class="headerlink" title="工程中的综合排序算法"></a>工程中的综合排序算法</h3><p>实际工程中的排序算法一般会将 <strong>归并排序</strong>、<strong>插入排序</strong>、<strong>快速排序</strong>综合起来，集大家之所长来应对不同的场景要求：</p>
<ul>
<li>当要排序的元素为基本数据类型且元素个数较少时，直接使用 <strong>插入排序</strong>。因为在样本规模较小时（比如60），<code>O(NlogN)</code>的优势并不明显甚至不及<code>O(N^2)</code>，而在<code>O(N^2)</code>的算法中，插入排序的常数时间操作最少。</li>
<li>当要排序的元素为对象数据类型（包含若干字段），为保证稳定性将采用 <strong>归并排序</strong>。</li>
<li>当要排序的元素为基本数据类型且样本规模较大时，将采用 <strong>快速排序</strong>。</li>
</ul>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>上一节中所讲的都是基于比较的排序，也即通过比较确定每个元素所处的位置。那么能不能不比较而实现排序呢？这就涉及到了 <strong>桶排序</strong> 这个方法论：准备一些桶，将序列中的元素按某些规则放入翻入对应的桶中，最后根据既定的规则依次倒出桶中的元素。</p>
<blockquote>
<p>非基于比较的排序，与被排序的样本的实际数据状况有很大关系，所以在实际中并不常用。</p>
</blockquote>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序是 <strong>桶排序</strong> 方法论的一种实现，即准备一个与序列中元素的数据范围大小相同的数组，然后遍历序列，将遇到的元素作为数组的下标并将该位置上的数加1。例如某序列元素值在0~100之间，请设计一个算法对其排序，要求时间复杂度为<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucketArr[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= <span class="number">100</span> ; i++)&#123;</span><br><span class="line">        bucketArr[i]=<span class="number">0</span>;	<span class="comment">//init buckets</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line">        bucketArr[arr[i]]++;	<span class="comment">//put into buckets</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketArr[i] != <span class="number">0</span>) &#123; <span class="comment">//pour out</span></span><br><span class="line">            count = bucketArr[i];</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[j++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travels</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    travels(arr, <span class="number">12</span>);<span class="comment">//9 2 1 4 5 2 1 6 3 8 1 2</span></span><br><span class="line">    countSort(arr, <span class="number">12</span>);</span><br><span class="line">    travels(arr, <span class="number">12</span>);<span class="comment">//1 1 1 2 2 2 3 4 5 6 8 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 如果下次面试官问你有没有事件复杂度比<code>O(N)</code>更优的排序算法时，不要忘了计数排序哦！！！</p>
</blockquote>
<h3 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h3><ol>
<li>给定一个数组，求如果排序后，相邻两数的最大值，要求时间复杂度为<code>O(N)</code>，且要求不能用非基于比较的排序。</li>
</ol>
<p>这道题的思路比较巧妙：首先为这N个数准备N+1个桶，然后以其中的最小值和最大值为边界将数值范围均分成N等分，然后遍历数组将对应范围类的数放入对应的桶中，下图以数组长度为9举例</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/barrel.png" alt> </p>
<p>这里比较难理解的是：</p>
<ul>
<li>题目问的是求<strong>如果排序后，相邻两数的最大差值</strong>。该算法巧妙的借助一个空桶（N个数进N+1个桶，必然有一个是空桶），将问题转向了求<strong>两个相邻非空桶</strong><br>  （其中可能隔着若干个空桶）之间前桶的最大值和后桶最小值的差值，而无需在意每个桶中进了哪些数（<strong>只需记录每个桶入数的最大值和最小值以及是否有数</strong>）</li>
</ul>
<p>对应代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据要入桶的数和最大最小值得到对应桶编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBucketId</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> bucketsNum,<span class="keyword">int</span> min,<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num - min) * bucketsNum / (max - min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxGap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">-999999</span>, minValue = <span class="number">999999</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//找出最大最小值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        maxValue = max(maxValue, arr[i]);</span><br><span class="line">        minValue = min(minValue, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录每个桶的最大最小值以及是否有数，初始时每个桶都没数</span></span><br><span class="line">    <span class="keyword">int</span> maxs[length + <span class="number">1</span>], mins[length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> hasNum[length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length + <span class="number">1</span>; i++) &#123;	</span><br><span class="line">        hasNum[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//put maxValue into the last bucket</span></span><br><span class="line">    mins[length] = maxs[length] = maxValue;</span><br><span class="line">    hasNum[length] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterate the arr</span></span><br><span class="line">    <span class="keyword">int</span> bid; <span class="comment">//bucket id</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != maxValue) &#123;</span><br><span class="line">            bid = getBucketId(arr[i], length + <span class="number">1</span>, minValue, maxValue);</span><br><span class="line">          	<span class="comment">//如果桶里没数，则该数入桶后，最大最小值都是它，否则更新最大最小值</span></span><br><span class="line">            mins[bid] = !hasNum[bid] ? arr[i] : arr[i] &lt; mins[bid] ? arr[i] : mins[bid];</span><br><span class="line">            maxs[bid] = !hasNum[bid] ? arr[i] : arr[i] &gt; maxs[bid] ? arr[i] : maxs[bid];</span><br><span class="line">            hasNum[bid] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find the max gap between two nonEmpty buckets</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        j = i + <span class="number">1</span>;<span class="comment">//the next nonEmtpy bucket id</span></span><br><span class="line">        <span class="keyword">while</span> (!hasNum[j]) &#123;<span class="comment">//the last bucket must has number</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, (mins[j] - maxs[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">13</span>, <span class="number">41</span>, <span class="number">67</span>, <span class="number">26</span>, <span class="number">55</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">82</span>, <span class="number">39</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, getMaxGap(arr, <span class="number">9</span>));	<span class="comment">//17</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>左神算法</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法班笔记-时间复杂度和空间复杂度</title>
    <url>/2020/03/10/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E7%8F%AD%E7%AC%94%E8%AE%B0-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为<code>O(n)</code>），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于<strong>常数</strong>时间内的操作（对应时间复杂度<code>O(1)</code>）。</p><a id="more"></a>
<p>在化简某算法时间复杂度表达式时需遵循以下规则：</p>
<ul>
<li>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如<code>O(n^2)+O(n)</code>可化简为<code>O(n^2)</code>，<code>O(n)+O(1)</code>可化简为<code>O(n)</code></li>
<li>可省去样本量前的常量系数，如<code>O(2n)</code>可化简为<code>O(n)</code>，<code>O(8)</code>可化简为<code>O(1)</code></li>
<li>对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如<code>O(logm)+O(n^2)</code>不能化简为<code>O(n^2)</code>或<code>O(logm)</code>。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为<code>O(logm)</code>，因为表达式增量是由样本量决定的。</li>
</ul>
<h1 id="额外空间复杂度"><a href="#额外空间复杂度" class="headerlink" title="额外空间复杂度"></a>额外空间复杂度</h1><p>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量<code>temp</code>，那么该算法的额外空间复杂度为<code>O(1)</code>。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为<code>O(n)</code>。</p>
<h1 id="经典例题——举一反三"><a href="#经典例题——举一反三" class="headerlink" title="经典例题——举一反三"></a>经典例题——举一反三</h1><h2 id="找出B中不属于A的数"><a href="#找出B中不属于A的数" class="headerlink" title="找出B中不属于A的数"></a>找出B中不属于A的数</h2><blockquote>
<p>找出数组B中不属于A的数，数组A有序而数组B无序。假设数组A有n个数，数组B有m个数，写出算法并分析时间复杂度。</p>
</blockquote>
<h3 id="方法一：遍历"><a href="#方法一：遍历" class="headerlink" title="方法一：遍历"></a>方法一：遍历</h3><p>首先遍历B，将B中的每个数拿到到A中找，若找到则打印。对应算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> B[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> temp = B[i];</span><br><span class="line">  bool flag = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[j] == temp) &#123;</span><br><span class="line">      flag = <span class="keyword">true</span>;    <span class="comment">//找到了</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;    <span class="comment">//没找到</span></span><br><span class="line">    printf(<span class="string">"%d"</span>, temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出上述算法的时间复杂度为<code>O(m*n)</code>，因为将两个数组都遍历了一遍</p>
<h3 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h3><p>由于数组A是有序的，<strong>在一个有序序列中查找一个元素可以使用二分法（也称折半法）</strong>。原理就是将查找的元素与序列的中位数进行比较，如果小于则去掉中位数及其之后的序列，如果大于则去掉中位数及其之前的序列，如果等于则找到了。如果不等于那么再将其与剩下的序列继续比较直到找到或剩下的序列为空为止。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/binarySearch.png" alt></p>
<p>利用二分法对应题解的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;		<span class="comment">//B的长度为6</span></span><br><span class="line">  <span class="keyword">int</span> temp = B[i];</span><br><span class="line">  <span class="comment">//二分法查找</span></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">5</span>-<span class="number">1</span>;			<span class="comment">//A的长度为5</span></span><br><span class="line">  <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right &amp;&amp; A[mid] != temp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[mid] &gt; temp) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (A[mid] != temp) &#123;</span><br><span class="line">    printf(<span class="string">"%d"</span>, temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for<code>循环</code>m<code>次，</code>while<code>循环</code>logn<code>次（如果没有特别说明，log均以2为底），此算法的时间复杂度为</code>O(mlogn)</p>
<h3 id="方法三：排序-外排"><a href="#方法三：排序-外排" class="headerlink" title="方法三：排序+外排"></a>方法三：排序+外排</h3><p>第三种方法就是将数组B也排序，然后使用<strong>逐次比对</strong>的方式来查找A数组中是否含有B数组中的某元素。引入a、b两个指针分别指向数组A、B的首元素，比较指针指向的元素值，当<code>a时，向后移动a指针查找该元素；当</code>a=b<code>时，说明A中存在该元素，跳过该元素查找，向后移动b；当</code>a&gt;b`时说明A中不存在该元素，打印该元素并跳过该元素的查找，向后移动b。直到a或b有一个到达数组末尾为止（若a先到达末尾，那么b和b之后的数都不属于A）</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/sorting.png" alt></p>
<p>对应题解的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> a_length,<span class="keyword">int</span> B[],<span class="keyword">int</span> b_length)</span></span>&#123;</span><br><span class="line">    quickSort(B, <span class="number">0</span>, b_length - <span class="number">1</span>);	<span class="comment">//使用快速排序法对数组B排序-&gt;O(mlogm)</span></span><br><span class="line">    <span class="keyword">int</span>* a = A,*b=B;</span><br><span class="line">    <span class="keyword">while</span> (a &lt;= A + a_length - <span class="number">1</span> || b &lt;= B + b_length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*a == *b) &#123;</span><br><span class="line">            b++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*a &gt; *b) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, *b);</span><br><span class="line">            b++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == A + a_length) &#123;	<span class="comment">//a先到头</span></span><br><span class="line">        <span class="keyword">while</span> (b &lt; B + b_length) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, *b);</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">//交换两个int变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生一个low~high之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomInRange</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    srand((<span class="keyword">int</span>) time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> (rand() % (high - low))+low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序的核心算法，随机选择一个数，将比该数小的移至数组左边，比该数大的移至</span></span><br><span class="line"><span class="comment">//数组右边，最后返回该数的下标（移动完之后该数的下标可能与移动之前不一样）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt;= <span class="number">0</span> || start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = randomInRange(start, end);<span class="comment">//随机选择一个数</span></span><br><span class="line">    swap(arr[index], arr[end]);<span class="comment">//将该数暂时放至末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历前n-1个数与该数比较并以该数为界限将前n-1个数</span></span><br><span class="line">    <span class="comment">//分为两组，small指向小于该数的那一组的最后一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt; arr[end]) &#123;</span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span> (small != index) &#123;</span><br><span class="line">                swap(arr[small], arr[index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后将该数放至数值较小的那一个组的中间</span></span><br><span class="line">    ++small;</span><br><span class="line">    swap(arr[small], arr[end]);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = partition(arr, start, end);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; start) &#123;</span><br><span class="line">        quickSort(arr,start, index - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; end) &#123;</span><br><span class="line">        quickSort(arr, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此种方法的时间复杂度为：<code>O(mlogm)</code>（先对B排序）+<code>O(m+n)</code>（最坏的情况是指针a和b都到头）。</p>
<h3 id="三种方法的比较"><a href="#三种方法的比较" class="headerlink" title="三种方法的比较"></a>三种方法的比较</h3><ol>
<li><code>O(m*n)</code></li>
<li><code>O(mlogn)</code>（以2为底）</li>
<li><code>O(mlogm)+O(m+n)</code>（以2为底）</li>
</ol>
<p>易知算法2比1更优，因为增长率<code>logn &lt; n</code>。而2和3的比较取决于样本量m和n之间的差距，若<code>m&gt;&gt;n</code>那么2更优，不难理解：数组B元素较多，那么对B的排序肯定要花费较长时间，而这一步并不是题解所必需的，不如采用二分法；相反地，若<code>m&lt;&lt;n</code>，那么3更优。</p>
<h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><p>给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。</p>
<blockquote>
<p>要求额外空间复杂度O(1)，时间复杂度O(N)</p>
</blockquote>
<p>思路：利用两个指针<code>L</code>、<code>R</code>，将<code>L</code>指向首元素之前，将<code>R</code>指向尾元素之后。从头遍历序列，将当前遍历元素与<code>num</code>比较，若<code>num</code>，则将其与<code>L</code>的右一个元素交换位置并遍历下一个元素、右移<code>L</code>；若<code>=num</code>则直接遍历下一个元素；若<code>&gt;num</code>则将其和<code>R</code>的左一个元素交换位置，并重新判断当前位置元素与<code>num</code>的关系。直到遍历的元素下标到为<code>R-1</code>为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = startIndex - <span class="number">1</span>, R = endIndex + <span class="number">1</span>, i = startIndex;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= R - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; num) &#123;</span><br><span class="line">            swap(arr[i++], arr[++L]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; num) &#123;</span><br><span class="line">            swap(arr[i], arr[--R]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    travles(arr, <span class="number">8</span>);</span><br><span class="line">    partition(arr, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">    travles(arr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>L</code>代表小于<code>num</code>的数的右界，<code>R</code>代表大于<code>num</code>的左界，<code>partition</code>的过程就是遍历元素、不断壮大<code>L、R</code>范围的过程。这里比较难理解的地方可能是为什么<code>arr[i]时要右移</code>L<code>而</code>arr[i]&gt;num<code>时却不左移</code>R<code>，这是因为对于当前元素</code>arr[i]<code>，如果</code>arr[i]进行<code>swap(arr[i],arr[L+1])</code>之后对于当前下标的数据状况是知晓的（一定有<code>arr[i]=arr[L+1]</code>），因为是从头遍历到<code>i</code>的，而<code>L+1&lt;=i</code>。但是如果<code>arr[i]&gt;num</code>进行<code>swap(arr[i],arr[R-1])</code>之后对于当前元素的数据状况是不清楚的，因为<code>R-1&gt;=i</code>，<code>arr[R-1]</code>还没遍历到。</p>
<h2 id="矩阵打印问题"><a href="#矩阵打印问题" class="headerlink" title="矩阵打印问题"></a>矩阵打印问题</h2><h3 id="转圈打印方块矩阵"><a href="#转圈打印方块矩阵" class="headerlink" title="转圈打印方块矩阵"></a>转圈打印方块矩阵</h3><p>给定一个4阶矩阵如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/circlePrint.png" alt></p>
<p>打印结果如下（要求额外空间复杂度为<code>O(1)</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">8</span> <span class="number">12</span> <span class="number">16</span> <span class="number">15</span> <span class="number">14</span> <span class="number">13</span> <span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">11</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路：这类问题需要将思维打开，从宏观的层面去找出问题存在的共性从而求解。如果你的思维局限在1是如何变到2的、4是怎么变到8的、11之后为什么时10、它们之间有什么关联，那么你就陷入死胡同了。</p>
<p>从宏观的层面找共性，其实转圈打印的过程就是不断顺时针打印外围元素的过程，只要给你一个左上角的点（如<code>(0,0)</code>）和右下角的点（如<code>(3,3)</code>），你就能够打印出<code>1 2 3 4 8 12 16 15 14 13 9 5</code>；同样，给你<code>(1,1)</code>和<code>(2,2)</code>，你就能打印出<code>6 7 11 10</code>。这个根据两点打印正方形上元素的过程可以抽取出来，整个问题也就迎刃而解了。</p>
</blockquote>
<p>打印一个矩阵某个正方形上的点的逻辑如下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/circlePrint1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FACTORIAL 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSquare</span><span class="params">(<span class="keyword">int</span> leftUp[], <span class="keyword">int</span> rigthDown[],<span class="keyword">int</span> matrix[][FACTORIAL])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = leftUp[<span class="number">0</span>], j = leftUp[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; rigthDown[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, matrix[i][j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; rigthDown[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, matrix[i++][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; leftUp[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, matrix[i][j--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; leftUp[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, matrix[i--][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrixCircled</span><span class="params">(<span class="keyword">int</span> matrix[][FACTORIAL])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftUp[] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, rightDown[] = &#123;FACTORIAL<span class="number">-1</span>,FACTORIAL<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (leftUp[<span class="number">0</span>] &lt; rightDown[<span class="number">0</span>] &amp;&amp; leftUp[<span class="number">1</span>] &lt; rightDown[<span class="number">1</span>]) &#123;</span><br><span class="line">        printSquare(leftUp, rightDown, matrix);</span><br><span class="line">        ++leftUp[<span class="number">0</span>];</span><br><span class="line">        ++leftUp[<span class="number">1</span>];</span><br><span class="line">        --rightDown[<span class="number">0</span>];</span><br><span class="line">        --rightDown[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>,  <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;,</span><br><span class="line">            &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    printMatrixCircled(matrix);<span class="comment">//1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="旋转方块矩阵"><a href="#旋转方块矩阵" class="headerlink" title="旋转方块矩阵"></a>旋转方块矩阵</h3><p>给定一个方块矩阵，请把该矩阵调整成顺时针旋转90°之后的样子，要求额外空间复杂度为<code>O(1)</code>。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rotatePrint.png" alt></p>
<blockquote>
<p>思路：拿上图举例，首先选取矩阵四个角上的点<code>1,3,9,7</code>，按顺时针的方向<code>1</code>到<code>3</code>的位置（<code>1-&gt;3</code>）、<code>3-&gt;9</code>、<code>9-&gt;7</code>、<code>7-&gt;1</code>，这样对于旋转后的矩阵而言，这四个点已经调整好了。接下来只需调整<code>2,6,8,4</code>的位置，调整方法是一样的。只需对矩阵第一行的前n-1个点采用同样的方法进行调整、对矩阵第二行的前前n-3个点……，那么调整n阶矩阵就容易了。</p>
<p>这也是在宏观上观察数据变动的一般规律，找到以不变应万变的通解（给定一个点，确定矩阵上以该点为角的正方形，将该正方形旋转90°），整个问题就不攻自破了。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/rotatePrint1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FACTORIAL 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">circleSquare</span><span class="params">(<span class="keyword">int</span> leftUp[],<span class="keyword">int</span> rightDown[],<span class="keyword">int</span> matrix[][FACTORIAL])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1[] = &#123;leftUp[<span class="number">0</span>], leftUp[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">int</span> p2[] = &#123;leftUp[<span class="number">0</span>], rightDown[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">int</span> p3[] = &#123;rightDown[<span class="number">0</span>], rightDown[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">int</span> p4[] = &#123;rightDown[<span class="number">0</span>],leftUp[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">while</span> (p1[<span class="number">1</span>] &lt; rightDown[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">//swap</span></span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[p4[<span class="number">0</span>]][p4[<span class="number">1</span>]];</span><br><span class="line">        matrix[p4[<span class="number">0</span>]][p4[<span class="number">1</span>]] = matrix[p3[<span class="number">0</span>]][p3[<span class="number">1</span>]];</span><br><span class="line">        matrix[p3[<span class="number">0</span>]][p3[<span class="number">1</span>]] = matrix[p2[<span class="number">0</span>]][p2[<span class="number">1</span>]];</span><br><span class="line">        matrix[p2[<span class="number">0</span>]][p2[<span class="number">1</span>]] = matrix[p1[<span class="number">0</span>]][p1[<span class="number">1</span>]];</span><br><span class="line">        matrix[p1[<span class="number">0</span>]][p1[<span class="number">1</span>]] = tmp;</span><br><span class="line"></span><br><span class="line">        p1[<span class="number">1</span>]++;</span><br><span class="line">        p2[<span class="number">0</span>]++;</span><br><span class="line">        p3[<span class="number">1</span>]--;</span><br><span class="line">        p4[<span class="number">0</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">circleMatrix</span><span class="params">(<span class="keyword">int</span> matrix[][FACTORIAL])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftUp[] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, rightDown[] = &#123;FACTORIAL - <span class="number">1</span>, FACTORIAL - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (leftUp[<span class="number">0</span>] &lt; rightDown[<span class="number">0</span>] &amp;&amp; leftUp[<span class="number">1</span>] &lt; rightDown[<span class="number">1</span>]) &#123;</span><br><span class="line">        circleSquare(leftUp, rightDown, matrix);</span><br><span class="line">        leftUp[<span class="number">0</span>]++;</span><br><span class="line">        leftUp[<span class="number">1</span>]++;</span><br><span class="line">        --rightDown[<span class="number">0</span>];</span><br><span class="line">        --rightDown[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> matrix[][FACTORIAL])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FACTORIAL; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; FACTORIAL; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d "</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[FACTORIAL][FACTORIAL] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>,  <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;,</span><br><span class="line">            &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    printMatrix(matrix);</span><br><span class="line">    circleMatrix(matrix);</span><br><span class="line">    printMatrix(matrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="之字形打印矩阵"><a href="#之字形打印矩阵" class="headerlink" title="之字形打印矩阵"></a>之字形打印矩阵</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/zigzagPrint.png" alt></p>
<p>对如上矩阵的打印结果如下（要求额外空间复杂度为<code>O(1)</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">13</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span> <span class="number">14</span> <span class="number">15</span> <span class="number">10</span> <span class="number">5</span> <span class="number">6</span> <span class="number">11</span> <span class="number">16</span> <span class="number">17</span> <span class="number">12</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此题也是需要从宏观上找出一个共性：给你两个，你能否将该两点连成的45°斜线上的点按给定的打印方向打印出来。拿上图举例，给出<code>(2,0)</code>、<code>(0,2)</code>和<code>turnUp=true</code>，应该打印出<code>13,8,3</code>。那么整个问题就变成了两点的走向问题了，开始时两点均为<code>(0,0)</code>，然后一个点往下走，另一个点往右走（如<code>1-&gt;7</code>，<code>1-&gt;2</code>）；当往下走的点是边界点时就往右走（如<code>13-&gt;14</code>），当往右走的点到边界时就往下走（如<code>6-&gt;12</code>）。每次两点走一步，并打印两点连线上的点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rows = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cols = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLine</span><span class="params">(<span class="keyword">int</span> leftDown[],<span class="keyword">int</span> rightUp[], <span class="keyword">bool</span> turnUp,<span class="keyword">int</span> matrix[rows][cols])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span> (turnUp) &#123;</span><br><span class="line">        i = leftDown[<span class="number">0</span>], j = leftDown[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= rightUp[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, matrix[i--][j++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = rightUp[<span class="number">0</span>], j = rightUp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= leftDown[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, matrix[i++][j--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zigZagPrintMatrix</span><span class="params">(<span class="keyword">int</span> matrix[rows][cols])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDown[] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, rightUp[] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> turnUp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftDown[<span class="number">1</span>] &lt;= cols - <span class="number">1</span>) &#123;</span><br><span class="line">        printLine(leftDown, rightUp, turnUp, matrix);</span><br><span class="line">        turnUp = !turnUp;</span><br><span class="line">        <span class="keyword">if</span> (leftDown[<span class="number">0</span>] &lt; rows - <span class="number">1</span>) &#123;</span><br><span class="line">            leftDown[<span class="number">0</span>]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftDown[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightUp[<span class="number">1</span>] &lt; cols - <span class="number">1</span>) &#123;</span><br><span class="line">            ++rightUp[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++rightUp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[rows][cols] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,  <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;,</span><br><span class="line">            &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    zigZagPrintMatrix(matrix);<span class="comment">//1 2 7 13 8 3 4 9 14 15 10 5 6 11 16 17 12 18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在行和列都排好序的矩阵上找数"><a href="#在行和列都排好序的矩阵上找数" class="headerlink" title="在行和列都排好序的矩阵上找数"></a>在行和列都排好序的矩阵上找数</h3><p>如图：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/algorithms/findNumInSortedMatrix.png" alt></p>
<p>任何一列或一行上的数是有序的，实现一个函数，判断某个数是否存在于矩阵中。要求时间复杂度为<code>O(M+N)</code>，额外空间复杂度为<code>O(1)</code>。</p>
<blockquote>
<p>从矩阵右上角的点开始取点与该数比较，如果大于该数，那么说明这个点所在的列都不存在该数，将这个点左移；如果这个点上的数小于该数，那么说明这个点所在的行不存在该数，将这个点下移。直到找到与该数相等的点为止。最坏的情况是，该数只有一个且在矩阵左下角上，那么时间复杂度为<code>O(M-1+N-1)=O(M+N)</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rows = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumInSortedMatrix</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> matrix[rows][cols])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= rows - <span class="number">1</span> &amp;&amp; j &lt;= cols - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; num) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; num) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[rows][cols] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (findNumInSortedMatrix(<span class="number">7</span>, matrix)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"find!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not exist!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h2><p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？</p>
<p>比如矩阵：</p>
<table>
<thead>
<tr>
<th align="left">1</th>
<th align="left">0</th>
<th align="left">1</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>就有3个岛。</p>
<blockquote>
<p>分析：我们可以遍历矩阵中的每个位置，如果遇到1就将与其相连的一片1都感染成2，并自增岛数量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IslandNum</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIslandNums</span><span class="params">(<span class="keyword">int</span> matrix[][])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; matrix.length ; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; matrix[i].length ; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">					res++;</span><br><span class="line">					infect(matrix , i , j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">int</span> matrix[][], <span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix[i].length || matrix[i][j] != <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		matrix[i][j] = <span class="number">2</span>;</span><br><span class="line">		infect(matrix , i-<span class="number">1</span> , j);</span><br><span class="line">		infect(matrix , i+<span class="number">1</span> , j);</span><br><span class="line">		infect(matrix , i , j-<span class="number">1</span>);</span><br><span class="line">		infect(matrix , i , j+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> matrix[][] = &#123;</span><br><span class="line">			&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">			&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		System.out.println(getIslandNums(matrix));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>左神算法</category>
        <category>时间和空间复杂度</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发之Synchronized详解</title>
    <url>/2020/03/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-Java的锁"><a href="#1-Java的锁" class="headerlink" title="1.Java的锁"></a>1.Java的锁</h2><h3 id="1-1-锁的内存语义"><a href="#1-1-锁的内存语义" class="headerlink" title="1.1 锁的内存语义"></a>1.1 锁的内存语义</h3><blockquote>
<ul>
<li>锁可以让临界区互斥执行，还可以让释放锁的线程向同一个锁的线程发送消息</li>
<li>锁的释放要遵循Happens-before原则（<code>锁规则：解锁必然发生在随后的加锁之前</code>）</li>
<li>锁在Java中的具体表现是 <code>Synchronized</code> 和 <code>Lock</code></li>
</ul>
</blockquote><h3 id="1-2-锁的释放"><a href="#1-2-锁的释放" class="headerlink" title="1.2 锁的释放"></a>1.2 锁的释放</h3><blockquote>
<ul>
<li>线程A释放锁后，会将共享变更操作刷新到主内存中</li>
</ul>
</blockquote><a id="more"></a>

<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized.png" alt></p>
<h3 id="1-3-锁的获取"><a href="#1-3-锁的获取" class="headerlink" title="1.3 锁的获取"></a>1.3 锁的获取</h3><blockquote>
<ul>
<li>线程B获取锁时，JMM会将该线程的本地内存置为无效，被监视器保护的临界区代码必须从主内存中读取共享变量</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized1.png" alt></p>
<h3 id="1-4-锁的释放与获取"><a href="#1-4-锁的释放与获取" class="headerlink" title="1.4 锁的释放与获取"></a>1.4 锁的释放与获取</h3><blockquote>
<ul>
<li>锁获取与volatile读有相同的内存语义，读者可参见笔者的 <a href="https://www.zybuluo.com/kiraSally/note/850631" target="_blank" rel="noopener">并发番@Java内存模型&amp;Volatile一文通（1.7版）</a></li>
<li>线程A释放一个锁，实质是线程A告知下一个获取到该锁的某个线程其已变更该共享变量</li>
<li>线程B获取一个锁，实质是线程B得到了线程A告知其(在释放锁之前)变更共享变量的消息</li>
<li>线程A释放锁，随后线程B竞争到该锁，实质是线程A通过主内存向线程B发消息告知其变更了共享变量</li>
</ul>
</blockquote>
<h2 id="2-Synchronized的综述"><a href="#2-Synchronized的综述" class="headerlink" title="2.Synchronized的综述"></a>2.Synchronized的综述</h2><blockquote>
<ul>
<li><strong>同步机制：</strong> synchronized是Java同步机制的一种实现，即互斥锁机制，它所获得的锁叫做互斥锁</li>
<li><strong>互斥锁：</strong> 指的是每个对象的锁一次只能分配给一个线程，同一时间只能由一个线程占用</li>
<li><strong>作用：</strong> synchronized用于保证同一时刻只能由一个线程进入到临界区，同时保证共享变量的可见性、原子性和有序性</li>
<li><strong>使用：</strong> 当一个线程试图访问同步代码方法(块)时，它首先必须得到锁，退出或抛出异常时必须释放锁</li>
</ul>
</blockquote>
<h2 id="3-Synchronized的使用"><a href="#3-Synchronized的使用" class="headerlink" title="3.Synchronized的使用"></a>3.Synchronized的使用</h2><h3 id="3-1-Synchronized的三种应用方式"><a href="#3-1-Synchronized的三种应用方式" class="headerlink" title="3.1 Synchronized的三种应用方式"></a>3.1 Synchronized的三种应用方式</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized2.png" alt></p>
<blockquote>
<ul>
<li><strong>补充：</strong> 使用同步代码块的好处在于其他线程仍可以访问非synchronized(this)的同步代码块</li>
</ul>
</blockquote>
<h3 id="3-2-Synchronized的使用规则"><a href="#3-2-Synchronized的使用规则" class="headerlink" title="3.2 Synchronized的使用规则"></a>3.2 Synchronized的使用规则</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 先定义一个测试模板类</span></span><br><span class="line"><span class="comment">  *     这里补充一个知识点：Thread.sleep(long)不会释放锁</span></span><br><span class="line"><span class="comment">  *     读者可参见笔者的`并发番<span class="doctag">@Thread</span>一文通`</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了静态同步方法staticMethod"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束访问静态同步方法staticMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了静态同步方法staticMethod2"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"在staticMethod2方法中获取了SynchronizedDemo.class"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了同步方法synMethod"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束访问同步方法synMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了同步方法synMethod2"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束访问同步方法synMethod2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了普通方法method"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束访问普通方法method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chunkMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了chunkMethod方法"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"在chunkMethod方法中获取了lock"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chunkMethod2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了chunkMethod2方法"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"在chunkMethod2方法中获取了lock"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chunkMethod3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"访问了chunkMethod3方法"</span>);</span><br><span class="line">        <span class="comment">//同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"在chunkMethod3方法中获取了this"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringMethod</span><span class="params">(String lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-普通方法与同步方法调用互不关联"><a href="#3-2-1-普通方法与同步方法调用互不关联" class="headerlink" title="3.2.1 普通方法与同步方法调用互不关联"></a>3.2.1 普通方法与同步方法调用互不关联</h4><blockquote>
<ul>
<li>当一个线程进入同步方法时，其他线程可以正常访问其他非同步方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//调用普通方法</span></span><br><span class="line">        synDemo.method();</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//调用同步方法</span></span><br><span class="line">        synDemo.synMethod();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">1</span>访问了同步方法synMethod</span><br><span class="line">Thread-<span class="number">0</span>访问了普通方法method</span><br><span class="line">Thread-<span class="number">0</span>结束访问普通方法method</span><br><span class="line">Thread-<span class="number">1</span>结束访问同步方法synMethod</span><br><span class="line"><span class="comment">//分析：通过结果可知，普通方法和同步方法是非阻塞执行的</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-所有同步方法只能被一个线程访问"><a href="#3-2-2-所有同步方法只能被一个线程访问" class="headerlink" title="3.2.2 所有同步方法只能被一个线程访问"></a>3.2.2 所有同步方法只能被一个线程访问</h4><blockquote>
<ul>
<li>当一个线程执行同步方法时，其他线程不能访问任何同步方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        synDemo.synMethod();</span><br><span class="line">        synDemo.synMethod2();</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        synDemo.synMethod2();</span><br><span class="line">        synDemo.synMethod();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">0</span>访问了同步方法synMethod</span><br><span class="line">Thread-<span class="number">0</span>结束访问同步方法synMethod</span><br><span class="line">Thread-<span class="number">0</span>访问了同步方法synMethod2</span><br><span class="line">Thread-<span class="number">0</span>结束访问同步方法synMethod2</span><br><span class="line">Thread-<span class="number">1</span>访问了同步方法synMethod2</span><br><span class="line">Thread-<span class="number">1</span>结束访问同步方法synMethod2</span><br><span class="line">Thread-<span class="number">1</span>访问了同步方法synMethod</span><br><span class="line">Thread-<span class="number">1</span>结束访问同步方法synMethod</span><br><span class="line"><span class="comment">//分析：通过结果可知，任务的执行是阻塞的，显然Thread-1必须等待Thread-0执行完毕之后才能继续执行</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-同一个锁的同步代码块同一时刻只能被一个线程访问"><a href="#3-2-3-同一个锁的同步代码块同一时刻只能被一个线程访问" class="headerlink" title="3.2.3 同一个锁的同步代码块同一时刻只能被一个线程访问"></a>3.2.3 同一个锁的同步代码块同一时刻只能被一个线程访问</h4><blockquote>
<ul>
<li>当同步代码块都是同一个锁时，方法可以被所有线程访问，但同一个锁的同步代码块同一时刻只能被一个线程访问</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//调用同步块方法</span></span><br><span class="line">        synDemo.chunkMethod();</span><br><span class="line">        synDemo.chunkMethod2();</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//调用同步块方法</span></span><br><span class="line">        synDemo.chunkMethod();</span><br><span class="line">        synDemo.chunkMethod2();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">0</span>访问了chunkMethod方法</span><br><span class="line">Thread-<span class="number">1</span>访问了chunkMethod方法</span><br><span class="line">Thread-<span class="number">0</span>在chunkMethod方法中获取了lock  </span><br><span class="line">...停顿等待...</span><br><span class="line">Thread-<span class="number">1</span>在chunkMethod方法中获取了lock</span><br><span class="line">...停顿等待...</span><br><span class="line">Thread-<span class="number">0</span>访问了chunkMethod2方法</span><br><span class="line">Thread-<span class="number">0</span>在chunkMethod2方法中获取了lock</span><br><span class="line">...停顿等待...</span><br><span class="line">Thread-<span class="number">1</span>访问了chunkMethod2方法</span><br><span class="line">Thread-<span class="number">1</span>在chunkMethod2方法中获取了lock</span><br><span class="line"><span class="comment">//分析可知：</span></span><br><span class="line"><span class="comment">//1.对比18行和19行可知，即使普通方法有同步代码块，但方法的访问是非阻塞的，任何线程都可以自由进入</span></span><br><span class="line"><span class="comment">//2.对比20行、22行以及25行和27行可知，对于同一个锁的同步代码块的访问一定是阻塞的</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-线程间同时访问同一个锁的多个同步代码的执行顺序不定"><a href="#3-2-4-线程间同时访问同一个锁的多个同步代码的执行顺序不定" class="headerlink" title="3.2.4 线程间同时访问同一个锁的多个同步代码的执行顺序不定"></a>3.2.4 线程间同时访问同一个锁的多个同步代码的执行顺序不定</h4><blockquote>
<ul>
<li>线程间同时访问同一个锁多个同步代码的执行顺序不定，即使是使用同一个对象锁，这点跟同步方法有很大差异</li>
<li>？？读者可以先思考为什么会出现这样的问题？？</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//调用同步块方法</span></span><br><span class="line">        synDemo.chunkMethod();</span><br><span class="line">        synDemo.chunkMethod2();</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//调用同步块方法</span></span><br><span class="line">        synDemo.chunkMethod2();</span><br><span class="line">        synDemo.chunkMethod();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">0</span>访问了chunkMethod方法</span><br><span class="line">Thread-<span class="number">1</span>访问了chunkMethod2方法</span><br><span class="line">Thread-<span class="number">0</span>在chunkMethod方法中获取了lock</span><br><span class="line">...停顿等待...</span><br><span class="line">Thread-<span class="number">0</span>访问了chunkMethod2方法</span><br><span class="line">Thread-<span class="number">1</span>在chunkMethod2方法中获取了lock</span><br><span class="line">...停顿等待...</span><br><span class="line">Thread-<span class="number">1</span>访问了chunkMethod方法</span><br><span class="line">Thread-<span class="number">0</span>在chunkMethod2方法中获取了lock</span><br><span class="line">...停顿等待...</span><br><span class="line">Thread-<span class="number">1</span>在chunkMethod方法中获取了lock</span><br><span class="line"><span class="comment">//分析可知：</span></span><br><span class="line"><span class="comment">//现象：对比20行、22行和24行、25行可知，虽然是同一个lock对象，但其不同代码块的访问是非阻塞的</span></span><br><span class="line"><span class="comment">//原因：根源在于锁的释放和重新竞争，当Thread-0访问完chunkMethod方法后会先释放锁，这时Thread-1就有机会能获取到锁从而优先执行，依次类推到24行、25行时，Thread-0又重新获取到锁优先执行了</span></span><br><span class="line"><span class="comment">//注意：但有一点是必须的，对于同一个锁的同步代码块的访问一定是阻塞的</span></span><br><span class="line"><span class="comment">//补充：同步方法之所有会被全部阻塞，是因为synDemo对象一直被线程在内部把持住就没释放过，论把持住的重要性！</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-不同锁之间访问非阻塞"><a href="#3-2-5-不同锁之间访问非阻塞" class="headerlink" title="3.2.5 不同锁之间访问非阻塞"></a>3.2.5 不同锁之间访问非阻塞</h4><blockquote>
<ul>
<li><p>由于三种使用方式的锁对象都不一样，因此相互之间不会有任何影响</p>
</li>
<li><p>但有两种情况除外：</p>
</li>
</ul>
<ul>
<li>1.当同步代码块使用的Class对象和类对象一致时属于同一个锁，遵循上面的<code>3.2.3</code>原则</li>
<li>2.当同步代码块使用的是this，即与同步方法使用锁属于同一个锁，遵循上面的<code>3.2.2</code>和<code>3.2.3</code>原则</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; synDemo.chunkMethod() );</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; synDemo.chunkMethod3());</span><br><span class="line">    Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; staticMethod());</span><br><span class="line">    Thread thread4 = <span class="keyword">new</span> Thread(() -&gt; staticMethod2());</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread3.start();</span><br><span class="line">    thread4.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">1</span>访问了chunkMethod3方法</span><br><span class="line">Thread-<span class="number">1</span>在chunkMethod3方法中获取了<span class="keyword">this</span></span><br><span class="line">Thread-<span class="number">2</span>访问了静态同步方法staticMethod</span><br><span class="line">Thread-<span class="number">0</span>访问了chunkMethod方法</span><br><span class="line">Thread-<span class="number">0</span>在chunkMethod方法中获取了lock</span><br><span class="line">Thread-<span class="number">3</span>访问了静态同步方法staticMethod2</span><br><span class="line">...停顿等待...</span><br><span class="line">Thread-<span class="number">2</span>结束访问静态同步方法staticMethod</span><br><span class="line">Thread-<span class="number">3</span>在staticMethod2方法中获取了SynchronizedDemo.class</span><br><span class="line"><span class="comment">//分析可知：</span></span><br><span class="line"><span class="comment">//现象：对比16行、18行和24行、25行可知，虽然是同一个lock对象，但其不同代码块的访问是非阻塞的</span></span><br><span class="line"><span class="comment">//原因：根源在于锁的释放和重新竞争，当Thread-0访问完chunkMethod方法后会先释放锁，这时Thread-1就有机会能获取到锁从而优先执行，依次类推到24行、25行时，Thread-0又重新获取到锁优先执行了public static void main(String[] args) &#123;    SynchronizedDemo synDemo = new SynchronizedDemo();    Thread thread1 = new Thread(() -&gt; synDemo.chunkMethod() );    Thread thread2 = new Thread(() -&gt; synDemo.chunkMethod3());    Thread thread3 = new Thread(() -&gt; staticMethod());    Thread thread4 = new Thread(() -&gt; staticMethod2());    thread1.start();    thread2.start();    thread3.start();    thread4.start();&#125;---------------------//输出：Thread-1访问了chunkMethod3方法Thread-1在chunkMethod3方法中获取了thisThread-2访问了静态同步方法staticMethodThread-0访问了chunkMethod方法Thread-0在chunkMethod方法中获取了lockThread-3访问了静态同步方法staticMethod2...停顿等待...Thread-2结束访问静态同步方法staticMethodThread-3在staticMethod2方法中获取了SynchronizedDemo.class//分析可知：//现象：对比16行、18行和24行、25行可知，虽然是同一个lock对象，但其不同代码块的访问是非阻塞的//原因：根源在于锁的释放和重新竞争，当Thread-0访问完chunkMethod方法后会先释放锁，这时Thread-1就有机会能获取到锁从而优先执行，依次类推到24行、25行时，Thread-0又重新获取到锁优先执行了</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-Synchronized的可重入性"><a href="#3-3-Synchronized的可重入性" class="headerlink" title="3.3 Synchronized的可重入性"></a>3.3 Synchronized的可重入性</h3><blockquote>
<ul>
<li><strong>重入锁：</strong>当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功</li>
<li><strong>实现：</strong>一个线程得到一个对象锁后再次请求该对象锁，是允许的，每重入一次，monitor进入次数+1</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        synDemo.synMethod();</span><br><span class="line">        synDemo.synMethod2();</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        synDemo.synMethod2();</span><br><span class="line">        synDemo.synMethod();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">0</span>访问了同步方法synMethod</span><br><span class="line">Thread-<span class="number">0</span>结束访问同步方法synMethod</span><br><span class="line">Thread-<span class="number">0</span>访问了同步方法synMethod2</span><br><span class="line">Thread-<span class="number">0</span>结束访问同步方法synMethod2</span><br><span class="line">Thread-<span class="number">1</span>访问了同步方法synMethod2</span><br><span class="line">Thread-<span class="number">1</span>结束访问同步方法synMethod2</span><br><span class="line">Thread-<span class="number">1</span>访问了同步方法synMethod</span><br><span class="line">Thread-<span class="number">1</span>结束访问同步方法synMethod</span><br><span class="line"><span class="comment">//分析：对比16行和18行可知，在代码块中继续调用了当前实例对象的另外一个同步方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-Synchronized与String锁"><a href="#3-4-Synchronized与String锁" class="headerlink" title="3.4 Synchronized与String锁"></a>3.4 Synchronized与String锁</h3><blockquote>
<ul>
<li><strong>隐患：</strong>由于在JVM中具有String常量池缓存的功能，因此<strong>相同字面量是同一个锁！！！</strong></li>
<li><strong>注意：</strong>严重不推荐将String作为锁对象，而应该改用其他非缓存对象</li>
<li><strong>提示：</strong>对字面量有疑问的话请先回顾一下String的基础，这里不加以解释</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; synDemo.stringMethod(<span class="string">"sally"</span>));</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; synDemo.stringMethod(<span class="string">"sally"</span>));</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">...死循环...</span><br><span class="line"><span class="comment">//分析：输出结果永远都是Thread-0的死循环，也就是说另一个线程，即Thread-1线程根本不会运行</span></span><br><span class="line"><span class="comment">//原因：同步块中的锁是同一个字面量</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-Synchronized与不可变锁"><a href="#3-5-Synchronized与不可变锁" class="headerlink" title="3.5 Synchronized与不可变锁"></a>3.5 Synchronized与不可变锁</h3><blockquote>
<ul>
<li><strong>不可变类:</strong> 不可变类指的是创建类实例后，其属性值不可变 -&gt; 即f inal属性不可变，所有包装类型及字符串皆为不可变类，内部都维护一个final属性表示自身值</li>
<li><strong>隐患：</strong>当使用不可变类对象作为对象锁时，使用synchronized同样会有并发问题</li>
<li><strong>原因：</strong>由于不可变特性，当作为锁但同步块内部仍然有计算操作，会生成一个新的锁对象</li>
<li><strong>注意：</strong>严重不推荐将不可变类作为锁对象时仍对其有计算操作</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer i = <span class="number">0</span>;   <span class="comment">//Integer持有final int value属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">14134</span></span><br><span class="line"><span class="comment">//分析：跟预想中的20000不一致，当使用Integer作为对象锁时但还有计算操作就会出现并发问题</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>我们通过反编译发现执行i++操作相当于执行了i = Integer.valueOf(i.intValue()+1)</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized3.png" alt></p>
<ul>
<li><strong>通过查看Integer的valueOf方法实现可知，其每次都new了一个新的Integer对象，锁变了有木有！！！</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);  <span class="comment">//每次都new一个新的锁有木有！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-Synchronized与死锁"><a href="#3-6-Synchronized与死锁" class="headerlink" title="3.6 Synchronized与死锁"></a>3.6 Synchronized与死锁</h3><blockquote>
<ul>
<li><strong>死锁：</strong>当线程间需要<strong>相互等待对方已持有的锁</strong>时，就形成死锁，进而产生死循环</li>
<li><strong>注意：</strong> <strong>代码中严禁出现死锁！！！</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到lock锁"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到lock2锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到lock2锁"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到lock锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Thread-<span class="number">1</span>获取到lock2锁</span><br><span class="line">Thread-<span class="number">0</span>获取到lock锁</span><br><span class="line">.....</span><br><span class="line"><span class="comment">//分析：线程0获得lock锁，线程1获得lock2锁，但之后由于两个线程还要获取对方已持有的锁，但已持有的锁都不会被双方释放，线程"假死"，无法往下执行，从而形成死循环，即死锁，之后一直在做无用的死循环，严重浪费系统资源</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>我们用jstack查看一下这个任务的各个线程运行情况，可以发现两个线程都被阻塞BLOCKED</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized4.png" alt></p>
<p>从上面我们可以看出：</p>
<p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>② synchronized 修饰方法的的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized5.png" alt></p>
<ul>
<li><strong>我们很明显的发现，Java-level=deadlock，即死锁，两个线程相互等待对方的锁</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized6.png" alt></p>
<h2 id="4-Synchronized实现原理"><a href="#4-Synchronized实现原理" class="headerlink" title="4.Synchronized实现原理"></a>4.Synchronized实现原理</h2><h3 id="4-1-Synchronization"><a href="#4-1-Synchronization" class="headerlink" title="4.1 Synchronization"></a>4.1 Synchronization</h3><blockquote>
<p>Synchronization in the Java Virtual Machine is implemented by monitor entry and exit, either explicitly (by use of the monitorenter and monitorexit instructions) or implicitly (by the method invocation and return instructions).<br>For code written in the Java programming language, perhaps the most common form of synchronization is the synchronized method. A synchronized method is not normally implemented using monitorenter and monitorexit. Rather, it is simply distinguished in the run-time constant pool by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions (§2.11.10).</p>
</blockquote>
<hr>
<blockquote>
<ul>
<li>本段摘自 <a href="https://juejin.im/entry/59424ba68d6d810058c50fc9" target="_blank" rel="noopener">The Java® Virtual Machine Specification 3.14. Synchronization</a></li>
<li>在JVM中，同步的实现是通过监视器锁的进入和退出实现的，要么显示得通过<code>monitorenter</code> 和 <code>monitorexit</code>指令实现，要么隐示地通过方法调用和返回指令实现</li>
<li>对于Java代码来说，或许最常用的同步实现就是同步方法。其中同步代码块是通过使用 <code>monitorenter</code> 和 <code>monitorexit</code> 实现的，而同步方法却是使用 <code>ACC_SYNCHRONIZED</code> 标记符隐示的实现，原理是通过方法调用指令检查该方法在常量池中是否包含 <code>ACC_SYNCHRONIZED</code> 标记符</li>
<li>本篇不会针对<code>Synchronized</code>的字节码实现进行分析，只是点到为止，有兴趣的读者可参见 <a href="http://www.jianshu.com/p/c5058b6fe8e5" target="_blank" rel="noopener">JVM源码分析之synchronized实现</a> （当然，若有机会开JVM番的话，笔者会重新分析的）</li>
</ul>
</blockquote>
<h3 id="4-2-反编译"><a href="#4-2-反编译" class="headerlink" title="4.2 反编译"></a>4.2 反编译</h3><h4 id="4-2-1-预准备"><a href="#4-2-1-预准备" class="headerlink" title="4.2.1 预准备"></a>4.2.1 预准备</h4><blockquote>
<p>为了能直观了解Synchronized的工作原理，我们通过反编译SynchronizedDeme类的class文件的方式看看都发生了什么</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               synDemo.method();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                synDemo.method2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-1-生成-class文件"><a href="#4-2-1-生成-class文件" class="headerlink" title="4.2.1 生成.class文件"></a>4.2.1 生成.class文件</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">javac <span class="module-access"><span class="module"><span class="identifier">SynchronizedDemo</span>.</span></span>java</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：由于笔者OS的默认编码方式是UTF-8，因此可能出现以下错误</li>
</ul>
<h4 id="4-2-2-javap反编译"><a href="#4-2-2-javap反编译" class="headerlink" title="4.2.2 javap反编译"></a>4.2.2 javap反编译</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">javap -v SynchronizedDemo</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过反编译我们会得到常量池、同步方法、同步代码块的不同编译结果，之后我们将基于这三个进行介绍</p>
</blockquote>
<ul>
<li><strong>常量池图示</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized7.png" alt></p>
<blockquote>
<p>常量池除了会包含基本类型和字符串及数组的常量值外，还包含以文本形式出现的符号引用： </p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法和名称和描述符</li>
</ul>
</blockquote>
<ul>
<li><strong>同步方法图示</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized8.png" alt></p>
<blockquote>
<ul>
<li>同步方法会包含一个<code>ACC_SYNCHCRONIZED</code>标记符</li>
</ul>
</blockquote>
<ul>
<li><strong>同步代码块图示</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized9.png" alt></p>
<blockquote>
<ul>
<li>同步代码块会在代码中插入 <code>monitorenter</code> 和 <code>monitorexist</code> 指令</li>
</ul>
</blockquote>
<h3 id="4-3-同步代码块同步原理"><a href="#4-3-同步代码块同步原理" class="headerlink" title="4.3 同步代码块同步原理"></a>4.3 同步代码块同步原理</h3><h4 id="4-3-1-monitor监视器"><a href="#4-3-1-monitor监视器" class="headerlink" title="4.3.1 monitor监视器"></a>4.3.1 monitor监视器</h4><blockquote>
<ul>
<li>每个对象都有一个监视器，在同步代码块中，JVM通过<code>monitorenter</code>和<code>monitorexist</code>指令实现同步锁的获取和释放功能</li>
<li>当一个线程获取同步锁时，即是通过获取monitor监视器进而等价为获取到锁</li>
<li>monitor的实现类似于操作系统中的管程</li>
</ul>
</blockquote>
<h4 id="4-3-2-monitorenter指令"><a href="#4-3-2-monitorenter指令" class="headerlink" title="4.3.2 monitorenter指令"></a>4.3.2 monitorenter指令</h4><blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:<br>• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
<hr>
<blockquote>
<ul>
<li>每个对象都有一个监视器。当该监视器被占用时即是锁定状态(或者说获取监视器即是获得同步锁)。线程执行monitorenter指令时会尝试获取监视器的所有权，过程如下：</li>
</ul>
<ul>
<li>若该监视器的进入次数为0，则该线程进入监视器并将进入次数设置为1，此时该线程即为该监视器的所有者</li>
<li>若线程已经占有该监视器并重入，则进入次数+1</li>
<li>若其他线程已经占有该监视器，则线程会被阻塞直到监视器的进入次数为0，之后线程间会竞争获取该监视器的所有权</li>
<li>只有首先获得锁的线程才能允许继续获取多个锁</li>
</ul>
</blockquote>
<h4 id="4-3-3-monitorexit指令"><a href="#4-3-3-monitorexit指令" class="headerlink" title="4.3.3 monitorexit指令"></a>4.3.3 monitorexit指令</h4><blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<blockquote>
<ul>
<li>执行monitorexit指令将遵循以下步骤：</li>
</ul>
<ul>
<li>执行monitorexit指令的线程必须是对象实例所对应的监视器的所有者</li>
<li>指令执行时，线程会先将进入次数-1，若-1之后进入次数变成0，则线程退出监视器(即释放锁)</li>
<li>其他阻塞在该监视器的线程可以重新竞争该监视器的所有权</li>
</ul>
</blockquote>
<h4 id="4-3-4-实现原理"><a href="#4-3-4-实现原理" class="headerlink" title="4.3.4 实现原理"></a>4.3.4 实现原理</h4><blockquote>
<ul>
<li>在同步代码块中，JVM通过<code>monitorenter</code>和<code>monitorexist</code>指令实现同步锁的获取和释放功能</li>
<li><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置</li>
<li><code>monitorexit</code>指令是插入到方法结束处和异常处</li>
<li>JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对</li>
<li>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态</li>
<li>线程执行<code>monitorenter</code>指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁</li>
<li>线程执行<code>monitorexit</code>指令时，将会将进入次数-1直到变成0时释放监视器</li>
<li>同一时刻只有一个线程能够成功，其它失败的线程会被阻塞，并放入到同步队列中，进入BLOCKED状态</li>
</ul>
</blockquote>
<h4 id="4-3-4-补充"><a href="#4-3-4-补充" class="headerlink" title="4.3.4 补充"></a>4.3.4 补充</h4><blockquote>
<ul>
<li>关于objectref可参见 <code>锁的使用方式</code></li>
<li>由于wait/notify等方法底层实现是基于监视器，因此只有在同步方法(块)中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因</li>
</ul>
</blockquote>
<h3 id="4-4-同步方法同步原理"><a href="#4-4-同步方法同步原理" class="headerlink" title="4.4 同步方法同步原理"></a>4.4 同步方法同步原理</h3><blockquote>
<ul>
<li>区别于同步代码块的监视器实现，同步方法通过使用 <code>ACC_SYNCHRONIZED</code> 标记符隐示的实现</li>
<li>原理是通过方法调用指令检查该方法在常量池中是否包含 <code>ACC_SYNCHRONIZED</code> 标记符，如果有，JVM 要求线程在调用之前请求锁</li>
</ul>
</blockquote>
<h2 id="5-进阶原理"><a href="#5-进阶原理" class="headerlink" title="5.进阶原理"></a>5.进阶原理</h2><h3 id="5-1-Monitor-Obejct模式"><a href="#5-1-Monitor-Obejct模式" class="headerlink" title="5.1 Monitor Obejct模式"></a>5.1 Monitor Obejct模式</h3><h4 id="5-1-1-Monitor-Obejct模式综述"><a href="#5-1-1-Monitor-Obejct模式综述" class="headerlink" title="5.1.1 Monitor Obejct模式综述"></a>5.1.1 Monitor Obejct模式综述</h4><blockquote>
<ul>
<li>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是互斥和信号机制</li>
<li><strong>互斥：</strong> 一个Monitor锁在同一时刻只能被一个线程占用，其他线程无法占用</li>
<li><strong>信号机制(signal)：</strong> 占用Monitor锁失败的线程会暂时放弃竞争并等待某个谓词成真（条件变量），但该条件成立后，当前线程会通过释放锁通知正在等待这个条件变量的其他线程，让其可以重新竞争锁</li>
</ul>
</blockquote>
<ul>
<li>Mesa派的signal机制</li>
</ul>
<blockquote>
<ul>
<li>Mesa派的signal机制又称”Non-Blocking condition variable”</li>
<li>占有Monitor锁的线程发出释放通知时，不会立即失去锁，而是让其他线程等待在队列中，重新竞争锁</li>
<li>这种机制里，等待者拿到锁后不能确定在这个时间差里是否有别的等待者进入过Monitor，因此不能保证谓词一定为真，所以对条件的判断必须使用<code>while</code></li>
<li>Java中采用就是Mesa派的singal机制，即所谓的<code>notify</code></li>
</ul>
</blockquote>
<h4 id="5-1-2-Monitor-Obejct模式结构"><a href="#5-1-2-Monitor-Obejct模式结构" class="headerlink" title="5.1.2 Monitor Obejct模式结构"></a>5.1.2 Monitor Obejct模式结构</h4><p><strong>在 Monitor Object 模式中，主要有四种类型的参与者：</strong></p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized10.png" alt></p>
<h4 id="5-1-3-Monitor-Obejct模式协作过程"><a href="#5-1-3-Monitor-Obejct模式协作过程" class="headerlink" title="5.1.3 Monitor Obejct模式协作过程"></a>5.1.3 Monitor Obejct模式协作过程</h4><blockquote>
<ul>
<li>1.同步方法的调用和串行化：</li>
</ul>
<ul>
<li>当客户线程调用监视者对象的同步方法时，必须首先获取它的监视锁</li>
<li>只要该监视者对象有其他同步方法正在被执行，获取操作便不会成功</li>
<li>当监视者对象已被线程占用时(即同步方法正被执行)，客户线程将被阻塞直到它获取监视锁</li>
<li>当客户线程成功获取监视锁后，进入临界区，执行方法实现的服务</li>
<li>一旦同步方法完成执行，监视锁会被自动释放，目的是使其他客户线程有机会调用执行该监视者对象的同步方法</li>
</ul>
<ul>
<li><p><strong>2.同步方法线程挂起：</strong>如果调用同步方法的客户线程必须被阻塞或是有其他原因不能立刻进行，它能够在一个监视条件(Monitor Condition)上等待，这将导致该客户线程暂时释放监视锁，并被挂起在监视条件上</p>
</li>
<li><p><strong>3.监视条件通知：</strong>一个客户线程能够通知一个监视条件，目的是通知阻塞在该监视条件(该监视锁)的线程恢复运行</p>
</li>
<li><p>4.同步方法线程恢复：</p>
</li>
</ul>
<ul>
<li>一旦一个早先被挂起在监视条件上的同步方法线程获取通知，它将继续在最初的等待监视条件的点上执行</li>
<li>在被通知线程被允许恢复执行同步方法之前，监视锁将自动被获取(线程间自动相互竞争锁)</li>
</ul>
<ul>
<li>对于Monitor笔者将在 <code>并发番@ReentractLock一文通</code>中进一步阐述</li>
</ul>
</blockquote>
<h3 id="5-2-对象头"><a href="#5-2-对象头" class="headerlink" title="5.2 对象头"></a>5.2 对象头</h3><h4 id="5-2-1-JVM内存中的对象"><a href="#5-2-1-JVM内存中的对象" class="headerlink" title="5.2.1 JVM内存中的对象"></a>5.2.1 JVM内存中的对象</h4><blockquote>
<ul>
<li>在JVM中，对象在内存中的布局分成三块区域：对象头、实例数据和对齐填充</li>
<li><strong>对象头：</strong> 对象头主要存储对象的hashCode、锁信息、类型指针、分代年龄等信息</li>
<li><strong>实例数据：</strong>存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组长度，这部分内存按4字节对齐</li>
<li><strong>对齐填充：</strong>由于JVM要求对象起始地址必须是8字节的整数倍，当不满足8字节时会自动填充（是否需要对齐填充取决于JVM引擎）</li>
</ul>
</blockquote>
<h4 id="5-2-2-对象头综述"><a href="#5-2-2-对象头综述" class="headerlink" title="5.2.2 对象头综述"></a>5.2.2 对象头综述</h4><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized11.png" alt></p>
<blockquote>
<ul>
<li>synchcronized的锁是存放在Java对象头中的</li>
<li>如果对象是数组类型，JVM用3个子宽(Word)存储对象头，否则是用2个子宽</li>
<li>在32位虚拟机中，1子宽等于4个字节，即32bit；64位的话就是8个字节，即64bit</li>
</ul>
</blockquote>
<h4 id="5-2-3-Mark-Word的存储结构"><a href="#5-2-3-Mark-Word的存储结构" class="headerlink" title="5.2.3 Mark Word的存储结构"></a>5.2.3 Mark Word的存储结构</h4><p><strong>32位JVM的Mark Word的默认存储结构（无锁状态）</strong> </p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized12.png" alt></p>
<p><strong>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化(32位)</strong> </p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized13.png" alt></p>
<p><strong>64位JVM的Mark Word的默认存储结构(对于32位无锁状态，有25bit没有使用)</strong> </p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized14.png" alt></p>
<h3 id="5-3-Monitor-Record"><a href="#5-3-Monitor-Record" class="headerlink" title="5.3 Monitor Record"></a>5.3 Monitor Record</h3><h4 id="5-3-1-Monitor-Record综述"><a href="#5-3-1-Monitor-Record综述" class="headerlink" title="5.3.1 Monitor Record综述"></a>5.3.1 Monitor Record综述</h4><blockquote>
<ul>
<li>MonitorRecord(统一简称MR)是Java线程私有的数据结构，<strong>每一个线程都有一个可用MR列表，同时还有一个全局的可用列表</strong></li>
<li>一个被锁住的对象都会和一个MR关联（对象头的MarkWord中的LockWord指向MR的起始地址）</li>
<li>MR中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用</li>
</ul>
</blockquote>
<h4 id="5-3-2-Monitor-Record结构"><a href="#5-3-2-Monitor-Record结构" class="headerlink" title="5.3.2 Monitor Record结构"></a>5.3.2 Monitor Record结构</h4><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized15.png" alt></p>
<h4 id="5-3-3-Monitor-Record工作机理"><a href="#5-3-3-Monitor-Record工作机理" class="headerlink" title="5.3.3 Monitor Record工作机理"></a>5.3.3 Monitor Record工作机理</h4><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized16.png" alt></p>
<blockquote>
<ul>
<li>线程如果获得监视锁成功，将成为该监视锁对象的拥有者</li>
<li>在任一时刻，监视器对象只属于一个活动线程(Owner)</li>
<li>拥有者可以调用wait方法自动释放监视锁，进入等待状态</li>
</ul>
</blockquote>
<h2 id="6-锁优化"><a href="#6-锁优化" class="headerlink" title="6.锁优化"></a>6.锁优化</h2><h3 id="6-1-自旋锁"><a href="#6-1-自旋锁" class="headerlink" title="6.1 自旋锁"></a>6.1 自旋锁</h3><blockquote>
<ul>
<li><strong>痛点：</strong>由于线程的阻塞/唤醒需要CPU在用户态和内核态间切换，频繁的转换对CPU负担很重，进而对并发性能带来很大的影响</li>
<li><strong>现象：</strong>通过大量分析发现，对象锁的锁状态通常只会持续很短一段时间，没必要频繁地阻塞和唤醒线程</li>
<li><strong>原理：</strong>通过执行一段无意义的空循环让线程等待一段时间，不会被立即挂起，看持有锁的线程是否很快释放锁，如果锁很快被释放，那当前线程就有机会不用阻塞就能拿到锁了，从而减少切换，提高性能</li>
<li><strong>隐患：</strong>若锁能很快被释放，那么自旋效率就很好(真正执行的自旋次数越少效率越好，等待时间就少)；但若是锁被一直占用，那自旋其实没有做任何有意义的事但又白白占用和浪费了CPU资源，反而造成资源浪费</li>
<li><strong>注意：</strong>自旋次数必须有个限度(或者说自旋时间)，如果超过自旋次数(时间)还没获得锁，就要被阻塞挂起</li>
<li><strong>使用：</strong> JDK1.6以上默认开启<code>-XX:+UseSpinning</code>，自旋次数可通过<code>-XX:PreBlockSpin</code>调整，默认10次</li>
</ul>
</blockquote>
<h3 id="6-2-自适应自旋锁"><a href="#6-2-自适应自旋锁" class="headerlink" title="6.2 自适应自旋锁"></a>6.2 自适应自旋锁</h3><blockquote>
<ul>
<li><strong>痛点：</strong>由于自旋锁只能指定固定的自旋次数，但由于任务的差异，导致每次的最佳自旋次数有差异</li>
<li><strong>原理：</strong>通过引入”智能学习”的概念，由前一次在同一个锁上的自旋时间和锁的持有者的状态来决定自旋的次数，换句话说就是自旋的次数不是固定的，而是可以通过分析上次得出下次，更加智能</li>
<li><strong>实现：</strong>若当前线程针对某锁自旋成功，那下次自旋此时可能增加(因为JVM认为这次成功是下次成功的基础)，增加的话成功几率可能更大；反正，若自旋很少成功，那么自旋次数会减少(减少空转浪费)甚至直接省略自旋过程，直接阻塞(因为自旋完全没有意义，还不如直接阻塞)</li>
<li><strong>补充：</strong>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，JVM对锁的状况预测会越来越准确，JVM会变得越来越智能</li>
</ul>
</blockquote>
<h3 id="6-3-阻塞锁"><a href="#6-3-阻塞锁" class="headerlink" title="6.3 阻塞锁"></a>6.3 阻塞锁</h3><h4 id="6-3-1-阻塞锁"><a href="#6-3-1-阻塞锁" class="headerlink" title="6.3.1 阻塞锁"></a>6.3.1 阻塞锁</h4><blockquote>
<ul>
<li><strong>加锁成功：</strong>当出现锁竞争时，只有获得锁的线程能够继续执行</li>
<li><strong>加锁失败：</strong>竞争失败的线程会由running状态进入blocking状态，并被放置到与目标锁相关的一个等待队列中</li>
<li><strong>解锁：</strong>当持有锁的线程退出临界区，释放锁后，会将等待队列中的一个阻塞线程唤醒，令其重新参与到锁竞争中</li>
<li><strong>补充：</strong>本篇不会涉及到具体的JVM型号的分析，有兴趣的读者可以看看针对HotSopt JVM的分析 <a href="http://blog.csdn.net/chen77716/article/details/6618779" target="_blank" rel="noopener">深入JVM锁机制1-synchronized</a></li>
</ul>
</blockquote>
<h4 id="6-3-2-公平锁"><a href="#6-3-2-公平锁" class="headerlink" title="6.3.2 公平锁"></a>6.3.2 公平锁</h4><blockquote>
<ul>
<li>公平锁就是获得锁的顺序按照先到先得的原则，从实现上说，要求当一个线程竞争某个对象锁时，只要这个锁的等待队列非空，就必须把这个线程阻塞并塞入队尾（插入队尾一般通过一个CAS操作保持插入过程中没有锁释放）</li>
</ul>
</blockquote>
<h4 id="6-3-3-非公平锁"><a href="#6-3-3-非公平锁" class="headerlink" title="6.3.3 非公平锁"></a>6.3.3 非公平锁</h4><blockquote>
<ul>
<li>相对的，非公平锁场景下，每个线程都先要竞争锁，在竞争失败或当前已被加锁的前提下才会被塞入等待队列，在这种实现下，后到的线程有可能无需进入等待队列直接竞争到锁（随机性）</li>
</ul>
</blockquote>
<h3 id="6-4-锁粗化"><a href="#6-4-锁粗化" class="headerlink" title="6.4 锁粗化"></a>6.4 锁粗化</h3><blockquote>
<ul>
<li><strong>痛点：</strong>多次连接在一起的加锁、解锁操作会造成不必要的开销</li>
<li><strong>原理：</strong>将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁</li>
<li><strong>使用：</strong>将多个彼此靠近的同步块合同在一个同步块 或 把多个同步方法合并为一个方法</li>
<li><strong>补充：</strong>在JDK内置的API中，例如StringBuffer、Vector、HashTable都会存在隐性加锁操作，可合并</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * StringBuffer是线程安全的字符串处理类</span></span><br><span class="line"><span class="comment">  * 每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stringBuffer.append(<span class="string">"kira"</span>);</span><br><span class="line">    stringBuffer.append(<span class="string">"sally"</span>);</span><br><span class="line">    stringBuffer.append(<span class="string">"mengmeng"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-锁消除"><a href="#6-5-锁消除" class="headerlink" title="6.5 锁消除"></a>6.5 锁消除</h3><blockquote>
<ul>
<li><strong>痛点：</strong>根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁</li>
<li><strong>原理：</strong> JVM在编译时通过对运行上下文的描述，去除不可能存在共享资源竞争的锁，通过这种方式消除无用锁，即删除不必要的加锁操作，从而节省开销</li>
<li><strong>使用：</strong> 逃逸分析和锁消除分别可以使用参数<code>-XX:+DoEscapeAnalysis</code>和<code>-XX:+EliminateLocks</code>(锁消除必须在<code>-server模式</code>下)开启</li>
<li><strong>补充：</strong>在JDK内置的API中，例如StringBuffer、Vector、HashTable都会存在隐性加锁操作，可消除</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 比如执行10000次字符串的拼接</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo synchronizedDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++)&#123;</span><br><span class="line">        synchronizedDemo.append(<span class="string">"kira"</span>,<span class="string">"sally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//由于StringBuffer对象被封装在方法内部，不可能存在共享资源竞争的情况</span></span><br><span class="line">    <span class="comment">//因此JVM会认为该加锁是无意义的，会在编译期就删除相关的加锁操作</span></span><br><span class="line">    <span class="comment">//还有一点特别要注明：明知道不会有线程安全问题，代码阶段就应该使用StringBuilder</span></span><br><span class="line">    <span class="comment">//否则在没有开启锁消除的情况下，StringBuffer不会被优化，性能可能只有StringBuilder的1/3</span></span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    stringBuffer.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-锁的升级"><a href="#6-6-锁的升级" class="headerlink" title="6.6 锁的升级"></a>6.6 锁的升级</h3><blockquote>
<ul>
<li>从JDK1.6开始，锁一共有四种状态：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量锁状态</strong>、<strong>重量锁状态</strong></li>
<li>锁的状态会随着竞争情况逐渐升级，<strong>锁允许升级但不允许降级</strong></li>
<li><strong>不允许降级的目的是提高获得锁和释放锁的效率</strong></li>
<li>后面笔者会通过倒序的方式，即重量级锁-&gt;轻量级锁-&gt;偏向锁进行讲解，因为通常是前者的优化</li>
</ul>
</blockquote>
<ul>
<li><strong>锁的升级过程</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized17.png" alt></p>
<h3 id="6-7-重量级锁"><a href="#6-7-重量级锁" class="headerlink" title="6.7 重量级锁"></a>6.7 重量级锁</h3><blockquote>
<ul>
<li>重量级锁通过对象内部的monitor实现(见上文的Monitor Object模式)</li>
<li>monitor的本质是依赖于底层操作系统的MutexLock实现，操作系统实现线程间的切换是通过用户态与内核态的切换完成的，而切换成本很高</li>
<li>MutexLock最核心的理念就是 <code>尝试获取锁.若可得到就占有.若不能,就进入睡眠等待</code></li>
<li>有兴趣的读者可以阅读 <a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/" target="_blank" rel="noopener">浅谈Mutex (Lock)</a> ，该篇对Liunx的MutexLock做了很好的讲解</li>
</ul>
</blockquote>
<h3 id="6-8-轻量级锁"><a href="#6-8-轻量级锁" class="headerlink" title="6.8 轻量级锁"></a>6.8 轻量级锁</h3><h4 id="6-8-1-轻量级锁综述"><a href="#6-8-1-轻量级锁综述" class="headerlink" title="6.8.1 轻量级锁综述"></a>6.8.1 轻量级锁综述</h4><blockquote>
<ul>
<li><strong>痛点：</strong>由于线程的阻塞/唤醒需要CPU在用户态和内核态间切换，频繁的转换对CPU负担很重，进而对并发性能带来很大的影响</li>
<li><strong>主要目的：</strong> 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</li>
<li><strong>升级时机：</strong> 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</li>
<li><strong>原理：</strong> 在只有一个线程执行同步块时进一步提高性能</li>
<li><strong>数据结构：</strong> 包括<strong>指向栈中锁记录的指针</strong>、<strong>锁标志位</strong></li>
<li><strong>补充：</strong>建议读者先阅读<code>&lt;&lt;深入了解JVM虚拟机&gt;&gt;</code>的第8章<code>虚拟机字节码执行引擎</code>的栈帧相关知识</li>
<li><strong>补充：</strong>关于CAS请参见笔者的<code>并发番@AbstractQueuedSynchronizer</code>(排期中)</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized18.png" alt></p>
<h4 id="6-8-2-轻量级锁流程图"><a href="#6-8-2-轻量级锁流程图" class="headerlink" title="6.8.2 轻量级锁流程图"></a>6.8.2 轻量级锁流程图</h4><blockquote>
<ul>
<li><strong>线程1和线程2同时争夺锁，并导致锁膨胀成重量级锁</strong></li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized19.png" alt></p>
<h4 id="6-8-3-轻量级锁加锁"><a href="#6-8-3-轻量级锁加锁" class="headerlink" title="6.8.3 轻量级锁加锁"></a>6.8.3 轻量级锁加锁</h4><blockquote>
<ul>
<li>1.线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(Displaced Mark Word-即被取代的Mark Word)做一份拷贝</li>
<li>2.拷贝成功后，线程尝试使用CAS将对象头的Mark Word替换为指向锁记录的指针（将对象头的Mark Word更新为指向锁记录的指针，并将锁记录里的Owner指针指向Object Mark Word）<ul>
<li>如果更新成功，当前线程获得锁，继续执行同步方法</li>
<li>如果更新失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，若自旋后没有获得锁，此时轻量级锁会升级为重量级锁，当前线程会被阻塞</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="6-8-4-轻量级锁解锁"><a href="#6-8-4-轻量级锁解锁" class="headerlink" title="6.8.4 轻量级锁解锁"></a>6.8.4 轻量级锁解锁</h4><blockquote>
<ul>
<li>解锁时会使用CAS操作将Displaced Mark Word替换回到对象头， <ul>
<li>如果解锁成功，则表示没有竞争发生</li>
<li>如果解锁失败，表示当前锁存在竞争，锁会膨胀成重量级锁，需要在释放锁的同时唤醒被阻塞的线程，之后线程间要根据重量级锁规则重新竞争重量级锁</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="6-8-5-轻量级锁注意事项"><a href="#6-8-5-轻量级锁注意事项" class="headerlink" title="6.8.5 轻量级锁注意事项"></a>6.8.5 轻量级锁注意事项</h4><blockquote>
<ul>
<li><strong>隐患：</strong>对于轻量级锁有个使用前提是”没有多线程竞争环境”，一旦越过这个前提，除了互斥开销外，还会增加额外的CAS操作的开销，在多线程竞争环境下，轻量级锁甚至比重量级锁还要慢</li>
</ul>
</blockquote>
<h3 id="6-9-偏向锁"><a href="#6-9-偏向锁" class="headerlink" title="6.9 偏向锁"></a>6.9 偏向锁</h3><h4 id="6-9-1-偏向锁综述"><a href="#6-9-1-偏向锁综述" class="headerlink" title="6.9.1 偏向锁综述"></a>6.9.1 偏向锁综述</h4><blockquote>
<ul>
<li><strong>痛点：</strong> Hotspot作者发现在<strong>大多数情况下不存在多线程竞争的情况</strong>，而是<strong>同一个线程多次获取到同一个锁</strong>，为了让线程获得锁代价更低，因此设计了偏向锁 (这个跟业务使用有很大关系)</li>
<li><strong>主要目的：</strong> 为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径</li>
<li><strong>原理：</strong> 在只有一个线程执行同步块时通过增加标记检查而减少CAS操作进一步提高性能</li>
<li><strong>数据结构：</strong> 包括<strong>占有锁的线程id</strong>，<strong>是否是偏向锁</strong>，<strong>epoch(偏向锁的时间戳)</strong>，<strong>对象分代年龄</strong>、<strong>锁标志位</strong></li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized20.png" alt></p>
<h4 id="6-9-2-偏向锁流程图"><a href="#6-9-2-偏向锁流程图" class="headerlink" title="6.9.2 偏向锁流程图"></a>6.9.2 偏向锁流程图</h4><blockquote>
<ul>
<li><strong>线程1演示了偏向锁的初始化过程，线程2演示了偏向锁的撤销锁过程</strong></li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized21.png" alt></p>
<h4 id="6-9-3-偏向锁初始化"><a href="#6-9-3-偏向锁初始化" class="headerlink" title="6.9.3 偏向锁初始化"></a>6.9.3 偏向锁初始化</h4><blockquote>
<ul>
<li>当一个线程访问同步块并获取到锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而是先简单检查对象头的MarkWord中是否存储了线程：<ul>
<li>如果已存储，说明线程已经获取到锁，继续执行任务即可</li>
<li>如果未存储，则需要再判断当前锁否是偏向锁(即对象头中偏向锁的标识是否设置为1，锁标识位为01)：<ul>
<li>如果<strong>没有设置</strong>，则<strong>使用CAS竞争锁</strong>（说明此时并不是偏向锁，一定是等级高于它的锁）</li>
<li>如果<strong>设置</strong>了，则<strong>尝试使用CAS将对象头的偏向锁指向当前线程</strong>，也就是结构中的线程ID</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="6-9-4-偏向锁撤销锁"><a href="#6-9-4-偏向锁撤销锁" class="headerlink" title="6.9.4 偏向锁撤销锁"></a>6.9.4 偏向锁撤销锁</h4><blockquote>
<ul>
<li><p>偏向锁使用一种<strong>等到竞争出现才释放锁</strong>的机制，只有当其他线程竞争锁时，持有偏向锁的线程才会释放锁</p>
</li>
<li><p>偏向锁的<strong>撤销需要等待全局安全点</strong>(该时间点上没有字节码正在执行)</p>
</li>
<li><p>偏向锁的撤销需要遵循以下步骤：</p>
<ul>
<li><p>首先会</p>
<p>暂停拥有偏向锁的线程并检查该线程是否存活：</p>
<ul>
<li>如果线程<strong>非活动状态</strong>，则将<strong>对象头设置为无锁状态</strong>（其他线程会重新获取该偏向锁）</li>
<li>如果线程是活动状态，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，并将对栈中的锁记录和对象头的MarkWord进行重置：<ul>
<li>要么<strong>重新偏向于其他线程</strong>(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)</li>
<li>要么<strong>恢复到无锁</strong>或者<strong>标记锁对象不适合作为偏向锁</strong>(此时锁会被升级为轻量级锁)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最后唤醒暂停的线程，被阻塞在安全点的线程继续往下执行同步代码块</strong></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="6-9-5-偏向锁关闭锁"><a href="#6-9-5-偏向锁关闭锁" class="headerlink" title="6.9.5 偏向锁关闭锁"></a>6.9.5 偏向锁关闭锁</h4><blockquote>
<ul>
<li>偏向锁在JDK1.6以上默认开启，开启后程序启动几秒后才会被激活</li>
<li>有必要可以使用JVM参数来关闭延迟 <code>-XX：BiasedLockingStartupDelay = 0</code></li>
<li>如果确定锁通常处于竞争状态，则可通过JVM参数 <code>-XX:-UseBiasedLocking=false</code> 关闭偏向锁，那么默认会进入轻量级锁</li>
</ul>
</blockquote>
<h4 id="6-9-6-偏向锁注意事项"><a href="#6-9-6-偏向锁注意事项" class="headerlink" title="6.9.6 偏向锁注意事项"></a>6.9.6 偏向锁注意事项</h4><blockquote>
<ul>
<li><strong>优势：</strong>偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令，其余时刻不需要CAS指令(相比其他锁)</li>
<li><strong>隐患：</strong>由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗（这个通常只能通过大量压测才可知）</li>
<li><strong>对比：</strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能</li>
</ul>
</blockquote>
<h3 id="6-10-偏向锁-vs-轻量级锁-vs-重量级锁"><a href="#6-10-偏向锁-vs-轻量级锁-vs-重量级锁" class="headerlink" title="6.10 偏向锁 vs 轻量级锁 vs 重量级锁"></a>6.10 偏向锁 vs 轻量级锁 vs 重量级锁</h3><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_synchronized22.png" alt></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发之AQS详解</title>
    <url>/2020/03/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>　　谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！</p><p>　　类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p><a id="more"></a>

<h1 id="二、框架"><a href="#二、框架" class="headerlink" title="二、框架"></a>二、框架</h1><p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_aqs.png" alt></p>
<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p>
<ul>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()</li>
</ul>
<p>　　AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p>
<p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<h1 id="三、源码详解"><a href="#三、源码详解" class="headerlink" title="三、源码详解"></a>三、源码详解</h1><p>　　本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。</p>
<h2 id="3-0-结点状态waitStatus"><a href="#3-0-结点状态waitStatus" class="headerlink" title="3.0 结点状态waitStatus"></a>3.0 结点状态waitStatus</h2><p>​      这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
<h2 id="3-1-acquire-int"><a href="#3-1-acquire-int" class="headerlink" title="3.1 acquire(int)"></a>3.1 acquire(int)</h2><p>　　此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">		acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　函数流程如下：</p>
<ol>
<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li>
<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
<p>　　这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。就像《大话西游》里唐僧说的：等你明白了舍生取义的道理，你自然会回来和我唱这首歌的。</p>
<h3 id="3-1-1-tryAcquire-int"><a href="#3-1-1-tryAcquire-int" class="headerlink" title="3.1.1 tryAcquire(int)"></a>3.1.1 tryAcquire(int)</h3><p>　　此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么？直接throw异常？说好的功能呢？好吧，<strong>还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？</strong>就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p>
<p>　　这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</p>
<h3 id="3-1-2-addWaiter-Node"><a href="#3-1-2-addWaiter-Node" class="headerlink" title="3.1.2 addWaiter(Node)"></a>3.1.2 addWaiter(Node)</h3><p>　　此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用再说了，直接看注释吧。</p>
<h4 id="3-1-2-1-enq-Node"><a href="#3-1-2-1-enq-Node" class="headerlink" title="3.1.2.1 enq(Node)"></a>3.1.2.1 enq(Node)</h4><p> 　　此方法用于将node加入队尾。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CAS"自旋"，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。<strong>CAS自旋volatile变量</strong>，是一种很经典的用法。还不太了解的，自己去百度一下吧。</p>
<h3 id="3-1-3-acquireQueued-Node-int"><a href="#3-1-3-acquireQueued-Node-int" class="headerlink" title="3.1.3 acquireQueued(Node, int)"></a>3.1.3 acquireQueued(Node, int)</h3><p>　　OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。这个函数非常关键，还是上源码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 成功获取资源</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</p>
<h4 id="3-1-3-1-shouldParkAfterFailedAcquire-Node-Node"><a href="#3-1-3-1-shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)"></a>3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)</h4><p>　　此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html" target="_blank" rel="noopener">Thread详解</a>），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p>
<h4 id="3-1-3-2-parkAndCheckInterrupt"><a href="#3-1-3-2-parkAndCheckInterrupt" class="headerlink" title="3.1.3.2 parkAndCheckInterrupt()"></a>3.1.3.2 parkAndCheckInterrupt()</h4><p>　　如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);<span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();<span class="comment">//如果被唤醒，查看自己是不是被中断的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html" target="_blank" rel="noopener">Thread详解</a>）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p>
<h4 id="3-1-3-3-小结"><a href="#3-1-3-3-小结" class="headerlink" title="3.1.3.3 小结"></a>3.1.3.3 小结</h4><p>　　OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</p>
<ol>
<li>结点进入队尾后，检查状态，找到安全休息点；</li>
<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>
</ol>
<h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h3><p>　　OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">       selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来总结下它的流程吧：</p>
<ol>
<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>
<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
<p>由于此函数是重中之重，我再用流程图总结一下：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_aqs1.png" alt></p>
<p>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</p>
<h2 id="3-2-release-int"><a href="#3-2-release-int" class="headerlink" title="3.2 release(int)"></a>3.2 release(int)</h2><p> 　　上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，<strong>它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</strong></p>
<h3 id="3-2-1-tryRelease-int"><a href="#3-2-1-tryRelease-int" class="headerlink" title="3.2.1 tryRelease(int)"></a>3.2.1 tryRelease(int)</h3><p>　　此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p>
<h3 id="3-2-2-unparkSuccessor-Node"><a href="#3-2-2-unparkSuccessor-Node" class="headerlink" title="3.2.2 unparkSuccessor(Node)"></a>3.2.2 unparkSuccessor(Node)</h3><p>　　此方法用于唤醒等待队列中下一个线程。下面是源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从后向前找。</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个函数并不复杂。一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p>
<h3 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h3><p>　　release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p>
<p>​      如果获取锁的线程在release时异常了，没有unpark队列中的其他结点，这时队列中的其他结点会怎么办？是不是没法再被唤醒了？</p>
<p>​      答案是<strong>YES</strong>！！！这时，队列中等待锁的线程将永远处于park状态，无法再被唤醒！！！但是我们再回头想想，获取锁的线程在什么情形下会release抛出异常呢？？</p>
<ol>
<li>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</li>
<li>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</li>
<li>release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。<strong>除非自己写的tryRelease()有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了</strong>。</li>
</ol>
<h2 id="3-3-acquireShared-int"><a href="#3-3-acquireShared-int" class="headerlink" title="3.3 acquireShared(int)"></a>3.3 acquireShared(int)</h2><p>　　此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    	doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p>
<ol>
<li><ol>
<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>
<li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li>
</ol>
</li>
</ol>
<h3 id="3-3-1-doAcquireShared-int"><a href="#3-3-1-doAcquireShared-int" class="headerlink" title="3.3.1 doAcquireShared(int)"></a>3.3.1 doAcquireShared(int)</h3><p>　　此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//加入队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否成功标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//前驱</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)<span class="comment">//如果等待过程中被打断过，此时将中断补上。</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</p>
<p>　　跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p>
<h4 id="3-3-1-1-setHeadAndPropagate-Node-int"><a href="#3-3-1-1-setHeadAndPropagate-Node-int" class="headerlink" title="3.3.1.1 setHeadAndPropagate(Node, int)"></a>3.3.1.1 setHeadAndPropagate(Node, int)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p>
<p>　　doReleaseShared()我们留着下一小节的releaseShared()里来讲。</p>
<h3 id="3-3-2-小结"><a href="#3-3-2-小结" class="headerlink" title="3.3.2 小结"></a>3.3.2 小结</h3><p>　　OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</p>
<ol>
<li></li>
<li><ol>
<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>
<li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li>
</ol>
</li>
</ol>
<p>　　其实跟acquire()的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p>
<h2 id="3-4-releaseShared"><a href="#3-4-releaseShared" class="headerlink" title="3.4 releaseShared()"></a>3.4 releaseShared()</h2><p>　　上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p>
<h3 id="3-4-1-doReleaseShared"><a href="#3-4-1-doReleaseShared" class="headerlink" title="3.4.1 doReleaseShared()"></a>3.4.1 doReleaseShared()</h3><p>　　此方法主要用于唤醒后继。下面是它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p>　　本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，相应的源码跟acquire()和acquireShared()差不多，这里就不再详解了。</p>
<h1 id="四、简单应用"><a href="#四、简单应用" class="headerlink" title="四、简单应用"></a>四、简单应用</h1><h2 id="4-1-Mutex（互斥锁）"><a href="#4-1-Mutex（互斥锁）" class="headerlink" title="4.1 Mutex（互斥锁）"></a>4.1 Mutex（互斥锁）</h2><p>​    Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</p>
<p>　　除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</p>
<p>　　OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程：volatile关键字解析</title>
    <url>/2020/03/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>　　volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p><a id="more"></a>
<h2 id="一-内存模型的相关概念"><a href="#一-内存模型的相关概念" class="headerlink" title="一.内存模型的相关概念"></a>一.内存模型的相关概念</h2><p>​    大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p> 　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<p>　　1）通过在总线加LOCK#锁的方式</p>
<p>　　2）通过缓存一致性协议</p>
<p>　　这2种方式都是硬件层面上提供的方式。</p>
<p>　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_memory_model.png" alt></p>
<h2 id="二-并发编程中的三个概念"><a href="#二-并发编程中的三个概念" class="headerlink" title="二.并发编程中的三个概念"></a>二.并发编程中的三个概念</h2><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<p><strong>1.原子性</strong></p>
<p>　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>　　一个很经典的例子就是银行账户转账问题：</p>
<p>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>　　同样地反映到并发编程中会出现什么结果呢？</p>
<p>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p> 　　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<p><strong>2.可见性</strong></p>
<p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>　　举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i =  <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p> 　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<p><strong>3.有序性</strong></p>
<p>　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;        <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p> 　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a * a;    <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p> 　　这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p><img src="https://raw.githubusercontent.com/Fi-Null/blog-pic/master/blog-pics/java/java_concurrent.png" alt></p>
<p>　那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p> 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h2 id="三-Java内存模型"><a href="#三-Java内存模型" class="headerlink" title="三.Java内存模型"></a>三.Java内存模型</h2><p>　　在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>　　举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span>  = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>　　那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<p><strong>1.原子性</strong></p>
<p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>　　请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p> 　　咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p> 　　所以上面4个语句只有语句1的操作具备原子性。</p>
<p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p><strong>2.可见性</strong></p>
<p>　　对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>3.有序性</strong></p>
<p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>　　下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>　　这8条原则摘自《深入理解Java虚拟机》。</p>
<p>　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>　　下面我们来解释一下前4条规则：</p>
<p>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h2 id="四-深入剖析volatile关键字"><a href="#四-深入剖析volatile关键字" class="headerlink" title="四.深入剖析volatile关键字"></a>四.深入剖析volatile关键字</h2><p>　　在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<p><strong>1.volatile关键字的两层语义</strong></p>
<p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>　　2）禁止进行指令重排序。</p>
<p>　　先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　但是用volatile修饰之后就变得不一样了：</p>
<p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
<p><strong>2.volatile保证原子性吗？</strong></p>
<p>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>　　下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>　　假如某个时刻变量inc的值为10，</p>
<p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>　　把上面的代码改成以下任何一种都可以达到效果：</p>
<p>　　采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　采用Lock：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<p><strong>3.volatile能保证有序性吗？</strong></p>
<p>　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>　　volatile关键字禁止指令重排序有两层意思：</p>
<p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>　　可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure>

<p>　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>　　那么我们回到前面举的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<p><strong>4.volatile的原理和实现机制</strong></p>
<p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>　　下面这段话摘自《深入理解Java虚拟机》：</p>
<p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="五-使用volatile关键字的场景"><a href="#五-使用volatile关键字的场景" class="headerlink" title="五.使用volatile关键字的场景"></a>五.使用volatile关键字的场景</h2><p>　　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>　　1）对变量的写操作不依赖于当前值</p>
<p>　　2）该变量没有包含在具有其他变量的不变式中</p>
<p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>　　下面列举几个Java中使用volatile的几个场景。</p>
<p><strong>1.状态标记量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p><strong>2.double check</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　至于为何需要这么写请参考：</p>
<p>　　《Java 中的双重检查（Double-Check）》<a href="http://blog.csdn.net/dl88250/article/details/5439024" target="_blank" rel="noopener">http://blog.csdn.net/dl88250/article/details/5439024</a></p>
<p>　　和<a href="http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://www.iteye.com/topic/652440</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo博客添加全局APlayer播放器</title>
    <url>/2019/11/25/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80APlayer%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div class="note info">
            <p>如果你只是想要在自己站点的左下角加一个极其Stable的音乐播放器，而不想听我废话自己踩的坑，请直接跳转：<br><a href="/2019/11/25/为Hexo博客添加全局APlayer播放器/#Show-me-the-CODE">“Show me the CODE!”</a></p>
          </div>
<a id="more"></a>

<h1 id="早期尝试"><a href="#早期尝试" class="headerlink" title="早期尝试"></a>早期尝试</h1><h2 id="网易云iframe"><a href="#网易云iframe" class="headerlink" title="网易云iframe"></a>网易云iframe</h2><p>今天，我试图解决一个历史遗留问题。</p>
<p>之前我博客上的音乐播放器一直都是网易云的外链iframe，就这个样式的：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1384318412&auto=0&height=66"></iframe>

<p>我一直把这个玩意放在sidebar里。但是问题是，移动版视图下sidebar是不展示的，只有header能够显示出来，而且还需要用toggle展开。我使用的主题是<code>NexT</code>，试验了一下，需要修改的地方是：</p>
<p><code>\themes\next\layout\_partials\header\index.swig</code></p>
<p>由于toggle展开的是<code>site-nav</code>，将源码修改如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; partial('_partials/header/brand.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"site-nav"</span>&gt;</span></span><br><span class="line">  &#123;&#123; partial('_partials/header/menu.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--网易云iframe--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=1384318412&amp;auto=0&amp;height=66"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--网易云iframe end--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.algolia_search.enable or theme.local_search.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-search"</span>&gt;</span></span><br><span class="line">    &#123;&#123; partial('_partials/search/index.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- next_inject('header') &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/12/Dmhzxi8XFIQK7np.jpg" alt="site-nav中的iframe.jpg"></p>
<p>这个效果属实🍔🍔。并且在桌面版视图下还会把sidebar压下去，不太理想。</p>
<h2 id="明月浩空音乐"><a href="#明月浩空音乐" class="headerlink" title="明月浩空音乐"></a>明月浩空音乐</h2><p>有没有悬浮式的播放器呢？有的。随便查一查就看到了这篇文章：<a href="https://leafjame.github.io/posts/2636059693.html" target="_blank" rel="noopener">一款炫丽的网页播放器插件</a>，这里介绍了<code>绚丽彩虹播放器</code>，确实是够绚丽的，点进去一看还是个东方二次元，连域名都叫<code>badapple.top</code>，爱了。</p>
<p>一阵操作之后，预览的效果确实挺理想的，可是到我网站上就只能播放第一首曲子了，和上面那篇文章的评论区里一位老哥说的一模一样：</p>
<p><img src="https://i.loli.net/2020/01/12/Sb8tgk2FZLrnu3i.jpg" alt="出现了绚丽的问题"></p>
<p>在我试图解决这个问题的时候，<code>badapple.top</code>突然就503了，回想起上面最后的更新日期是2018年，我就感到一阵不妙。不一会儿我就发现了和这绚丽播放器几乎<code>完 全 一 致</code>的替代品<a href="https://music.ain19.com/" target="_blank" rel="noopener">AIP播放器</a>，并且找出了前面问题的解决方案。可是，这两个东西相似度怎么能够这么高？？</p>
<p>原来它们都是从<a href="https://player.lmih.cn/" target="_blank" rel="noopener">明月浩空音乐</a>改来的，而这个原版是需要收费的。这明月浩空又是何许人也？传闻其名乃“李明浩”，这里有他不知真假的黑历史：<a href="https://www.chinasuc.cn/?thread-151.htm" target="_blank" rel="noopener">关于Colorful2.6(明月浩空模板)后门剖析</a>。</p>
<p>本来如果我不太在意这个插件的安全性，折腾播放器的经历到这里就应该结束了。可是AIP播放器它不能自由修改主题色，而默认的颜色偏偏还是绿的，强迫症让我不能忍。看了看它的加载方式，是用<code>\theme\next\layout\_layout.swig</code>中插入的JS脚本加载远端服务器上的CSS，JS、CSS、播放列表都在远端，这可没法随便改了。</p>
<p>当然，也许我可以自己写一个CSS（在NexT里用的是Stylus）来覆盖它的设定——可惜我不会。</p>
<p>那咋办嘛，只能再看看有没有其他选择了。如此“简单”的需求难道会没有对应的开源软件吗？</p>
<h1 id="APlayer"><a href="#APlayer" class="headerlink" title="APlayer"></a>APlayer</h1><p>在寻找替代品的过程中，我曾看到过这篇文章：<a href="https://diygod.me/best-players-in-hexo/" target="_blank" rel="noopener">可能是目前最好用的两个 Hexo 播放器插件</a>，讲的是开源的<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a>，这是一个给hexo使用的<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">APlayer</a>。</p>
<p>然而在看了它的文档之后，我没有第一时间get到它的点，特别是不知道要咋用。README.md里关于用法仅有一句：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure>

<p>这是个啥？当时我虽然知道Hexo的<code>Tag Plugins</code>，准确地说是NexT带来的<a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">Bootstrap Callout</a>——不得不说，<code>Tag Plugins</code>这个名字起得真是沙雕，它太容易和<code>tags</code>混淆了——但是我因为没什么机会用到，并没有细看过它的格式，所以也并不明白这<code>{&#37; &#37;}</code>是个什么操作。</p>
<p>现在必须得找其他方法的话，那就只好研究一下了。看了些Issues才搞明白原来是写在md文件里的，这与我的想法背道而驰——我希望能放在所有页面的固定位置，如果能做到网易云音乐网页版那样跳转页面而播放进度不变就再好不过了。</p>
<p>经过一段时间的测试之后，我发现如果使用<code>hexo-tag-aplayer</code>最好的解决方案就是如这个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/58" target="_blank" rel="noopener">issue</a>所言，在md里插入播放器后，再把生成的html文件里对应部分复制到header的<code>index.swig</code>里。可是这不就是个威力加强版的网易云iframe了吗？！</p>
<p>其实如果不是因为另一个问题，也还勉强能用。它的<code>fixed</code>模式（文档里翻译为“固定模式”）总让人感觉不太对劲，播放列表竟然是向上展开，如果放在header里，本来位置就很靠上，向上展开之后有一部分会伸出页面之外。虽然有一个默认值为<code>340px</code>的参数<code>listmaxheight</code>表示播放列表展开的高度，但我将其调为负值时，不但没有变成向下展开，而且还把播放列表倒过来了……</p>
<blockquote><p>当你感到迷惑，就应该去查Issues，大概率会有人和你遇到同样的迷惑问题。</p>
<footer><strong>沃兹·吉硕德</strong></footer></blockquote>

<p>所以我又查到一个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/79" target="_blank" rel="noopener">issue</a>，什么？<code>吸底</code>？这正是我想要的——这说的不就是<strong>原版</strong>APlayer吗？！</p>
<p><img src="https://i.loli.net/2020/01/12/Rm4tpK1sBMrdcyT.jpg" alt="APlayer吸底模式"></p>
<p>在APlayer的文档里，对<code>fixed</code>模式的描述是<code>吸底</code>，这才是我所期望的功能，前面被“固定模式”这个沙雕翻译给整蒙了。那么，原版APlayer又是怎么用的呢？</p>
<p><img src="https://i.loli.net/2020/01/12/CBPWNdEnRqrUoHs.jpg" alt="APlayer入门"></p>
<p>看到这里，我的迷惑更上一层楼，有一定前端知识的人应该很快就能看懂这里在说什么，但是我显然不是……</p>
<p>好在这时看到这篇文章：<a href="https://cloud.tencent.com/developer/article/1157669" target="_blank" rel="noopener">添加全站 APlayer 播放器</a>，看起来把这段代码加到<code>_layout.swig</code>的body里就OK了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aplayer"</span> <span class="attr">data-id</span>=<span class="string">"534542404"</span> <span class="attr">data-server</span>=<span class="string">"netease"</span> <span class="attr">data-type</span>=<span class="string">"song"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是依然不行：</p>
<blockquote>
<p>这里的外部调用链接没有包含版本号，默认加载最新 release 版本；正常来说不会出什么问题，但是如果需要 100% 稳定运行，建议自行加上版本号。</p>
</blockquote>
<p>事后发现这里加载的最新版本MetingJS是<code>2.0.0</code>，但实际上这个版本和APlayer根本不兼容，而MetingJS的文档却给人一种稳得一批的感觉：</p>
<p><img src="https://i.loli.net/2020/01/12/tmUfeSh5KFILic7.jpg" alt="虚假的MetingJS文档"></p>
<p>（都不Supported你贴个啥APLAYER啊！！）</p>
<p>好，那就自己加上版本号。这里从<code>jsDelivr</code>引用了三个文件，APlayer的CSS和JS，Meting的JS。最新的（截至2019年11月25日）稳定版本使用如下，你也可以去<code>jsDelivr</code>自行查找。</p>
<h1 id="Show-me-the-CODE"><a href="#Show-me-the-CODE" class="headerlink" title="Show me the CODE!"></a>Show me the CODE!</h1><p>如果你和我一样使用<code>NexT</code>主题，请复制以下代码，定位到<code>\theme\next\layout\_layout.swig</code>，将其粘贴到body体内即可。如果是其他情况，<strong>大同小异！大同小异！</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 我使用的APlayer本体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aplayer"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-id</span>=<span class="string">"2465890057"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-server</span>=<span class="string">"netease"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-type</span>=<span class="string">"playlist"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-fixed</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-autoplay</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-order</span>=<span class="string">"random"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-volume</span>=<span class="string">"0.55"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-theme</span>=<span class="string">"#cc543a"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">date-preload</span>=<span class="string">"auto"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果将本体放在body里面导致页面加载出现问题，请尝试放到body体后面--&gt;</span></span><br></pre></td></tr></table></figure>

<p>  APlayer的属性设置，请查阅<a href="https://aplayer.js.org/#/zh-Hans/?id=%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">APlayer中文文档-参数</a>以及能让你使用音乐平台的<a href="https://github.com/metowolf/MetingJS" target="_blank" rel="noopener">MetingJS</a>。</p>
<blockquote>
<p><strong>注意：</strong> 如果你使用上述代码，请以<code>data-xxx</code>格式书写参数名！</p>
</blockquote>
<h1 id="Bonus：使用pjax，页面跳转不重新播放"><a href="#Bonus：使用pjax，页面跳转不重新播放" class="headerlink" title="Bonus：使用pjax，页面跳转不重新播放"></a>Bonus：使用pjax，页面跳转不重新播放</h1><p><strong>最后一步！</strong></p>
<p><a href="https://music.163.com/" target="_blank" rel="noopener">网易云音乐网页版</a>底部的播放器，无论在网易云里如何跳转页面，只要还在当前标签页都是不重新加载的，这样就可以使正在播放中的音乐不随页面跳转中断。怎样实现这个功能呢？</p>
<p><a href="https://www.zhihu.com/question/23720144" target="_blank" rel="noopener">知乎-网易云音乐网页版底部的播放器是如何实现在切换网页时不停止播放音乐的？</a></p>
<p>这篇文章讲述了pjax的使用：<a href="https://cloud.tencent.com/developer/article/1096366" target="_blank" rel="noopener">迷你音乐播放器及实现全站pjax无刷新加载</a></p>
<p>虽然不是专讲APlayer，但是大同小异，大同小异！我作为对前端没什么了解的人，就跟着这个路子踩坑吧。</p>
<p>需要添加pjax和<code>1.7.0</code>以上版本的jquery，我这里依然从<code>jsDelivr</code>引用，最好放在body体结束前：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- require JQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- require pjax --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/pjax@0.2.8/index.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后按照以下方法使用pjax:</p>
<p><img src="https://i.loli.net/2020/01/12/gsN2MBVqIzCW9Uf.jpg" alt="使用pjax"></p>
<p><strong>然而，全部木大！</strong> 该跳还是跳了，也许是我姿势不对。</p>
<p>我转念一想，<code>NexT</code>这种历史悠久的主题，<code>pjax</code>这么好用的技术，岂有不内置的道理？鬼使神差之下，我打开主题的<code>_config.yml</code>一搜，还真的有：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class="line"><span class="comment"># For moreinformation: https://github.com/MoOx/pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>仅仅直接在这里把选项置为<code>true</code>是不行的，因为虽然配置文件里已经写了选项，但其实并没有安装对应的插件。关于如何使用，<a href="https://github.com/theme-next/theme-next-pjax" target="_blank" rel="noopener">Dependencies</a>的文档里说得极为清楚，在此就不赘述了。</p>
<p>开启之后，全站都实现了无刷新加载，接下来你就随便戳吧，音乐始终会在左下角播放的。</p>
<p>至此，一整天的折腾之旅才算是终于告一段落了。</p>
<p>1、商家中心Web，京东融合订单不允许修改</p>
<p>2、权限系统。（1）禁用了一批运营账号。（2）梳理了之前自动同步账号的逻辑。worker无予发布环境【测试需要预发】，导入新入职的人员需要在字典里配置部门和角色去掉（产品谈论），离职或者新增用户超过20个，报警机制。产品手动取创建（3）开放绑定第三方运单的事</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>音乐</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo配置Gitalk，并更改主题颜色</title>
    <url>/2019/10/20/%E4%B8%BAHexo%E9%85%8D%E7%BD%AEGitalk%EF%BC%8C%E5%B9%B6%E6%9B%B4%E6%94%B9%E4%B8%BB%E9%A2%98%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="配置Gitalk"><a href="#配置Gitalk" class="headerlink" title="配置Gitalk"></a>配置Gitalk</h1><p>在重新搭建这个站点的过程中，碰到一个“小”问题：以前我的网站使用的是WordPress，内建了评论系统，而现在在Hexo站点中该如何引入评论系统？</p>
<a id="more"></a>

<p>当然，这根本就不是问题，Hexo最著名的主题NexT已经在配置文件中给出了多种可供选择的评论系统。Google搜索到的大部分人使用的是Disqus，然而当我按照他们的流程一通操作后，执行<code>hexo g</code>却永远都是：</p>
<pre><code>next disqus TypeError: Cannot read property &apos;replace&apos; of null</code></pre><p>在我感到阵阵窒息之后，我看到了这样的issue：</p>
<p><img src="https://i.loli.net/2020/01/12/fkE8JSxeo4pjmu7.jpg" alt="不支持Disqus.jpg"></p>
<p>我人傻了，3月份就不支持了咋现在还在配置文件里？</p>
<blockquote>
<p>显然，当时匆匆扫过的我并没明白 <code>暂时的解决方案是 count: false</code> 是什么意思。</p>
</blockquote>
<p>于是我转而尝试其他的评论系统，好么，国内的一个赛一个麻烦，又是实名认证又是人脸信息的，还是别了。而国外的又时刻有被河蟹的风险。</p>
<p>终于我看到了Gitalk，它基于GitHub的issue，只要有GitHub账号就可以评论，看来同性交友网站不倒，这玩意就能用下去。</p>
<p>配置起来不算太麻烦，在NexT的配置文件里<strong>找到comments块，将gitalk给active上</strong>（这一步很重要），再去下面一点的gitalk块里按照文档一顿填，基本就完事了。</p>
<p>给出我的配置以供参考：</p>
<p><img src="https://i.loli.net/2020/01/12/jPw6frglHAW52ME.jpg" alt="gitalk块配置"></p>
<p>到这里，理论上你基本就能看到和gitalk官网上一样的效果了。</p>
<p>然而，坑爹的事情不会就此停止，如果你在本地<code>hexo s</code>，然后打开一篇文章，你应该确实会看到“Gitalk加载中”，然后 * 噔  噔  咚 * ，出现了这样的场景：</p>
<p><img src="https://i.loli.net/2020/01/12/VmbrWfpDMNute5O.jpg" alt="未找到相关的Issues"></p>
<p>你会试着点击<code>使用GitHub登录</code>，然而什么也没有发生，这大概是因为GitHub的登陆结果传不回本机的Hexo server。不必奇怪，尽管<code>hexo d</code>将它部署上去，访问你的站点再次点击它就好了。</p>
<p>需要注意，每篇文章下面的Gitalk都需要你戳上一下才能开始运行，这是因为刚刚说过的，Gitalk的原理是issue，你得以管理员的身份在repo里给每篇文章开上一个对应的issue，其他人才能在下面留言。</p>
<p>举个栗子，这是我用于测试Gitalk的几个留言在站点上的样子：</p>
<p><img src="https://i.loli.net/2020/01/12/62GCSo1yZp3ixRW.jpg" alt="gitalk在站点上"></p>
<p>而这是repo里对应的issue：</p>
<p><img src="https://i.loli.net/2020/01/12/l7pDt8vaf1gKdmk.jpg" alt="gitalk在issue中"></p>
<p>注意到红线标出的这一行，Gitalk就是用这两个标签来对应issue和文章的。</p>
<h1 id="更改Gitalk的主题颜色"><a href="#更改Gitalk的主题颜色" class="headerlink" title="更改Gitalk的主题颜色"></a>更改Gitalk的主题颜色</h1><p>如果你足够细心，也许会注意到官方的gitalk是蓝色的，而我站点中的却是与页头一致的绯色。</p>
<p>这两种颜色差别太大，我想要保持网页配色的一致性，于是免不了多折腾两下。</p>
<p>要更改颜色，首先就得知道这是什么颜色。</p>
<p>F12，审查元素，可以看到默认的色号是<code>#6190E8</code>。</p>
<p><img src="https://i.loli.net/2020/01/12/mjACFTl8et5hfwp.jpg" alt="默认配色"><br>既然如此，我们去Gitalk的repo，找找这个色号出现在哪些地方。</p>
<p><img src="https://i.loli.net/2020/01/12/EAkaJT7sGz8jcC1.jpg" alt="repo中的位置"></p>
<p>可以看到，这个色号出现在<code>dist/gitalk.css</code>和<code>src/style/index.styl</code>中。而真正决定Gitalk颜色的，应当是<code>dist</code>（Distribution，分发）中的<code>gitalk.css</code>。</p>
<p>明白了这一点，我们就可以整活了。首先将这个repo给fork过来，再将<code>dist/gitalk.css</code>中的色号全都改成想要的样子。我使用的绯色<code>#CC543A</code>取自<a href="http://nipponcolors.com" target="_blank" rel="noopener">NIPPON COLORS - 日本の伝統色</a>。</p>
<p>康康初音浅葱色？</p>
<p><img src="https://i.loli.net/2020/01/12/rzUKvqA5SIT7tPG.jpg" alt="浅葱"></p>
<p>这套色彩也是锤子的坚果手机“文青版”那几个骚气配色名称：远州鼠、落栗、苏芳、石竹、枯草、柳煤竹茶、锖青磁、鸠羽紫的来源。</p>
<p><img src="https://i.loli.net/2020/01/12/7p1J9MOtAChDqyi.jpg" alt="坚果手机文青版"></p>
<p>当然，这还不算完，我们得让NexT主题用上我们修改过的<code>gitalk.css</code>。</p>
<p>我们可以在next文件夹里搜索gitalk，看看它是如何被加载的。</p>
<p><img src="https://i.loli.net/2020/01/12/UiRWDco3Tr6IAls.jpg" alt="gtalk搜索结果"></p>
<p>显然，第2、4行的<code>gitalk_css_uri</code>和<code>gitalk_js_uri</code>就是关键。它说明gitalk的文件可以从两个地方加载：一个是<code>theme.vendors</code>，也就是主题配置文件<code>_config.yml</code>的<code>vendors</code>块中的记录，一个是<code>jsdelivr</code>这个CDN。</p>
<p><img src="https://i.loli.net/2020/01/12/FpBQKzJZhqjdtmY.jpg" alt="gitalk vendors"></p>
<p>以上两张截图里的CDN已经被我改成了我修改后的分支中对应的文件。关于这个CDN地址的格式，可以参看<a href="https://www.jsdelivr.com" target="_blank" rel="noopener">jsDelivr官网</a>的说明。</p>
<p>地址修改完成后，<code>hexo g -d</code>走起，你的配色应该已经成了想要的样子，庆贺吧！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Work summary</title>
    <url>/2019/03/08/Work-summary/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="订单中心："><a href="#订单中心：" class="headerlink" title="订单中心："></a>订单中心：</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>负责生成订单，把控整个订单生命周期（支付完成-&gt;补全-》下发商家-〉妥投等流程），通知下游系统订单状态变更，订单查询服务。</p><h3 id="现状："><a href="#现状：" class="headerlink" title="现状："></a>现状：</h3><p>接手之前，COE频发。每年至少出3-4次事故，给平台造成巨大的经济损失，用户流失。</p><p>力保系统必须稳定，我们的订单时效是一小时，高峰期一旦系统出问题造成订单无法生产，在1个小时内是解决不了的，压力很大。</p><a id="more"></a>


<p>观察以往事故经验，出事故主要集中在Es查询服务这边，查询超时，商家查不到订单，无法生成。</p>
<p>排查Es查询服务，发现Es集群服务器Cpu经常抖动，cpu使用使用率飙高到90%，于是查询原因：（1）Es集群混布，其他系统的es集群也不部署在订单中心查询服务器上，高峰期存在资源抢占，分配不均等行为。（2）Es单集群，存储到家3年的订单，大概10几亿条数据，数据量大，订单的复杂查询（比如多条件聚合查询）多，聚合查询每分钟能达到500k。</p>
<h3 id="技术架构升级优化："><a href="#技术架构升级优化：" class="headerlink" title="技术架构升级优化："></a>技术架构升级优化：</h3><p>（1）单独搭建一套新的Es热集群，集群资源不与任何系统共享，消除混布带来的不稳定。并且热集群只保存5天的数据，大概500万左右。思考我们的业务，其实99%的订单都会在一小时内送出去，热集群保存5天数据用于生产环境的查询完全是没有任何问题。如果商家有查询历史数据的需求，可以继续查原来的冷集群全量数据。</p>
<p>（2）冷热双集群问题不仅解决了之前的查询问题。还解决了之前的单点故障，如果Es热集群挂了，可以立马切换到冷集群。之前数据是双写的，冷集群数据好似全量数据。热双集群实时可以随时切换。</p>
<p>升级订单中心Es单集群架构为冷热双集群架构，不仅解决集群单点故障，还解决订单数据查询和存储瓶颈等问题，使订单中心处理订单处理能力由日均百万级单量升级为千万级。</p>
<h3 id="业务升级："><a href="#业务升级：" class="headerlink" title="业务升级："></a>业务升级：</h3><h4 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h4><p>开发到家配送联盟，使订单的履约率有96.5%提升到99.5%。配送联盟是去年参加<strong>hackthon</strong>的idea，并且深受各位评委的好评，夺得<strong>hackthon</strong>一等奖，并且也获得了去年的公司最佳项目一等奖。 </p>
<h4 id="背景（why）："><a href="#背景（why）：" class="headerlink" title="背景（why）："></a>背景（why）：</h4><p>观察数据，发现到家配送履约率只有96.5%，100单就有4单没有配送。分析其原因：配送只有达达一方，有些地方达达运力覆盖不足，导致无人配送。于是萌生出到家配送联盟的idea。订单抛给达达，达达在X（可配置）分钟内未接单，同时抛单给美团、顺丰、点我达、闪送。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>hackthon获奖后，一人独自开发完整的到家配送联盟系统，一周之内对接完所有的三方配送并且上线。并且之后对业务做了一些优化。（1）高价值的数码订单交给顺丰、闪送。（2）按时段抛单，每个时段的抛单时间不对。（医药订单的夜间配送直接抛给美团。）</p>
<h4 id="后续对配送联盟的下一步思考："><a href="#后续对配送联盟的下一步思考：" class="headerlink" title="后续对配送联盟的下一步思考："></a>后续对配送联盟的下一步思考：</h4><p>抛单策略比较粗暴。需要一个抛单策略算法，由算法综合各个因需（ 各个配送运力情况，配送完成率，每单成本【0-3公里 美团便宜；3公里以上，点我达便宜】等）评估，最终做到最适合抛单的配送。</p>
<h2 id="商家中心"><a href="#商家中心" class="headerlink" title="商家中心"></a>商家中心</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><p>对接开放平台  对接商家，提供商家各种操作订单的能力（接单-》打印-》捡货-〉配送-》妥投，异常流程）。</p>
<h3 id="技术优化："><a href="#技术优化：" class="headerlink" title="技术优化："></a>技术优化：</h3><h4 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h4><p>Young Gc慢，一次Young Gc达到了夸张的4000ms。造成很多对外提供的的接口响应时间超时，所有接口的 tp 999都超过了4s，对商家的生产造成了很大的影响。</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>常规方法：打印Gc日志，并分析Gc日志。但是观察Gc日志，Young gc的详细过程【1、级联扫描Young区根对象。2、扫描卡表时间。3、扫描根直接在old区的根对象】并没有，无法查明具体原因。通过查阅资料和观察，发现young gc慢的机器，长时间【5天】不执行full gc。回忆young gc过程，发现耗时应该是出现在扫描卡表这块。</p>
<p><strong>卡表：</strong></p>
<p>执行young gc的时候，如果有老年代的对象引用年轻代的对象，年轻代的对象不应该被标记清理。然而young gc是不可能是扫描整个old区，这样young gc时间大幅增加。并且old区引用年轻代情况不到1%。于是引入卡表，将old区分成许多大小相等的卡表，如果卡表里有对象引用年轻代对象，卡表标记为脏。下次young gc的时候只用扫描卡表，避免扫描整个old区。</p>
<p>扫描卡表的时间，ali jdk有参数可以打印时间，普通的jdk没有。</p>
<p>长时间不执行full gc，导致状态为脏的卡表越来越多，扫描越来越耗时。</p>
<h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>（1）调整Jdk参数，调小old区，调小晋升年龄，适当加大young区，适当增加gc线程【减少young gc次数，提高系统吞吐量】。</p>
<p>（2）每天夜里12点，业务量很小的时候，在服务器起一个定时任务手动执行gc。</p>
<p>2者一起使用。gc参数随着系统的访问量而调整，在上最后一道保险是手动执行gc。</p>
<h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p> 最终Ygc 时间从4000ms到50ms。</p>
<h3 id="业务升级"><a href="#业务升级" class="headerlink" title="业务升级"></a>业务升级</h3><p>商家中心做了很多事为商家赋能，提高商家的生产力。主要的2项：长链接推送中台服务，合流墙项目。</p>
<h4 id="长链接推送服务"><a href="#长链接推送服务" class="headerlink" title="长链接推送服务"></a>长链接推送服务</h4><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>商家经常抱怨订单来了，他们不知道。自驱开发基于netty长链接的高性能推送中台服务解决漏订单问题。之前的声音提醒是用Ajax 实时轮询查询后端es，门店不管有没有单，都会定时轮讯查询Es，查询条件很复杂，并且是很耗费性能的聚合查询，造成Es集群压力很大，常常影响到其他查询服务。在经过技术调研和预演，最终使用Netty开发出基于websocket协议的长链接推送中台服务。目前长链接服务主要用于Web端的自动打印和声音提醒。具体的过程【拿声音提醒为例】是这样：长链接服务接受Mq【比如订单中心下发商家订单Mq】，向前端发送消息，前端接到消息后播放声音提醒语音，同时回传接收成功消息。如果没有回传，长链接服务器会再次发出消息，直至前端回传成功。这样保证了消息的触达。</p>
<p>效果很好，其他团队也在接入使用。长链接数量上升，在100万左右。单机会出现瓶颈，单点故障等问题。</p>
<p>架构升级：分布式改造中台推送服务遇到的困难：</p>
<p>（1）长链接自动断开。</p>
<p>起初以为是长链接服务代码的问题。经过许多次的测试和发现，发现前端链接长链接服务如果是通过Ip直联的方式不存在断开问题，故排除长链接服务问题。为了实现负载均衡前端通过京东网关链接长链接服务器， 而网关有一个心跳检查机制，每隔5分钟检查客户端和服务端的通讯状态，如果5分钟内没有通讯，则会断开长链接服务。</p>
<p><strong>解决：</strong></p>
<p>​    自写前端js脚本，实现每隔3分钟，向后端发送心跳信息，长链接服务器在应答，这样便实现一次通讯。成功欺骗过京东网关，实现长链接永不断开。并且及时长链接被断开，也实现了断开也会重连。</p>
<p>（2）路由问题。长链接中台服务后端有多台机器，推送的时候是不知道具体建立的长链接通道在那台服务器。</p>
<p>解决：</p>
<p>1、扩展长链接服务，由于使用netty，很容易支持http。方案是A、B任意一台服务器接收到mq消息，向所有的长链接服务器发送http服务，把消息推给所有服务器，最总只会有一台服务器推送成功，其他服务器没有推送通道</p>
<p>2、mq广播</p>
<p>3、引入redis缓存记录路由关系。key：门店编号，value：ip地址列表</p>
<p>4、引入注册中心，每次链接都向注册中心注册，下次接到mq后，从注册中心获取长链接通道所在的机器ip</p>
<p>最终选择1，实现简单，还能对外对接方便，并且内网的http调用开销很小，部署机器3台不多，多2次http而已。</p>
<h4 id="合流墙项目"><a href="#合流墙项目" class="headerlink" title="合流墙项目"></a>合流墙项目</h4><h5 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h5><p>目前到家对接了全国基本所有的大型超市。比如永辉，沃尔玛等。但是这个大超市有一个特点门店面积很大，达到几万平米。订单时效是1小时，顾客买的东西遍布于几万平米的各个地方，于是如何快速的捡货成为了发展瓶颈。前期设置前置仓解决了大部分问题。前置仓就是超市特定为到家设置200平米的捡货区域，这个区域包含最热门的sku商品。但是这样做提供的服务是有损的，不能买到超市的所有东西，把超市的所有sku都搬到线上去。于是合流墙便产生了。</p>
<p>合流墙项目是我带领3人小团队突击开发在一个月内完成上线的。从0到1搭建了整个项目的架构，并且实现了所有核心流程的代码。</p>
<p>合流墙的思想是：将订单按商品分类拆分成多个捡货单，每个分类安排几个捡货员，这样实现了并行捡货，最后每个捡货任务捡完后合并打包送出。</p>
<p>合流墙上线后大大提高了商家捡货能力，捡货时间由30分钟下降为15分钟左右。让商家原来每天只能生产2000订单，可以攀升到5000单。</p>
<h2 id="整体思考"><a href="#整体思考" class="headerlink" title="整体思考"></a>整体思考</h2><p>订单业务越来越复杂，定制化需求越来越多，代码复杂度越来越高，最终导致难以维护。</p>
<p>目前订单中心对接了线下赋能业务，京东订单中心业务，自提业务。 于是大中台概念</p>
<p>要做的事：</p>
<p>（1）订单中台只负责订单的基本操作【定义订单生产的各个节点：支付完成-&gt; 暂停补全信息-〉下发商家-&gt; 等待出库-&gt;配送中-〉妥投完成。订单状态的变更通知，查询订单基础信息】，并且每个操作都是原子性的，不牵扯任何业务逻辑。单独提供sdk给其他业务系统，各自定制订单的各个流程【比如线下自提订单，订单流程：支付完成-》妥投】。各个流程可以供其他业务随意定义。这样订单中心可以应对各种复杂业务场景，实现自配置。</p>
<p>技术上：</p>
<p>实现高可用，可伸缩，可熔断降级。 rpc框架提供远程调用服务，jmq提供削峰，异步处理，消息通知。</p>
<p>搭建异地多数据中心，实现数据高可用。 搭建es冷热双集群，实现查询服务的高可用。</p>
<p>考虑新技术TiDb，完全兼容mysql协议，不用分库分表【扩容迁移数据问题，多表join问题，聚合查询问题】，可以无限水平扩容。</p>
<p>问问题：</p>
<p>公司对新入职的员工的培养机制是什么样的呢</p>
<p>新人怎么快速融入团队。</p>
<p>核算是一个什么部门，可以介绍下吗，我的理解就是计费？</p>
<p>团队现在面临的最大挑战是什么</p>
<p>针对我的面试表现，你觉得我还有那些地方可以提高？</p>
<p>薪资。3月加薪加7月升值，期望35k，至少32k</p>
<p>看中长远发展，看中大平台。全球领先的平台，服务于几十亿用户，做更有挑战的事。和更优秀的人共事，成长得更快。</p>
<p>缺点：容易紧张。表达能力一般，需要提高。</p>
<p>优点：吃苦耐劳，肯专研，技术有追求。</p>
<p>杭州。北方不习惯。</p>
]]></content>
      <categories>
        <category>summary</category>
      </categories>
  </entry>
  <entry>
    <title>Java 知识大全</title>
    <url>/2018/03/04/Java-%E7%9F%A5%E8%AF%86%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Java学习+面试指南</a></p>
<p><a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java</a></p>
<p><a href="https://github.com/nivelle/javaInterview" target="_blank" rel="noopener">java中高级基础指南</a></p>
<p><a href="https://www.zybuluo.com/kiraSally/note/857726" target="_blank" rel="noopener">并发番</a></p>
<p><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">labuladong的算法小抄</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>面试知识</category>
      </categories>
  </entry>
</search>
